
FreeRTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003c60  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000050  00800060  00003c60  00003cf4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000004c1  008000b0  008000b0  00003d44  2**0
                  ALLOC
  3 .stab         0000672c  00000000  00000000  00003d44  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00003dda  00000000  00000000  0000a470  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 1a 11 	jmp	0x2234	; 0x2234 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 d8 01 	jmp	0x3b0	; 0x3b0 <__vector_10>
      2c:	0c 94 0b 02 	jmp	0x416	; 0x416 <__vector_11>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e0 e6       	ldi	r30, 0x60	; 96
      68:	fc e3       	ldi	r31, 0x3C	; 60
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a0 3b       	cpi	r26, 0xB0	; 176
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	15 e0       	ldi	r17, 0x05	; 5
      78:	a0 eb       	ldi	r26, 0xB0	; 176
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a1 37       	cpi	r26, 0x71	; 113
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 6f 1d 	call	0x3ade	; 0x3ade <main>
      8a:	0c 94 2e 1e 	jmp	0x3c5c	; 0x3c5c <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <MUSART_Init>:
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	00 d0       	rcall	.+0      	; 0x98 <MUSART_Init+0x6>
      98:	0f 92       	push	r0
      9a:	cd b7       	in	r28, 0x3d	; 61
      9c:	de b7       	in	r29, 0x3e	; 62
      9e:	1b 82       	std	Y+3, r1	; 0x03
      a0:	8b 81       	ldd	r24, Y+3	; 0x03
      a2:	8f 7b       	andi	r24, 0xBF	; 191
      a4:	8b 83       	std	Y+3, r24	; 0x03
      a6:	8b 81       	ldd	r24, Y+3	; 0x03
      a8:	8f 7e       	andi	r24, 0xEF	; 239
      aa:	8b 83       	std	Y+3, r24	; 0x03
      ac:	8b 81       	ldd	r24, Y+3	; 0x03
      ae:	8f 7d       	andi	r24, 0xDF	; 223
      b0:	8b 83       	std	Y+3, r24	; 0x03
      b2:	8b 81       	ldd	r24, Y+3	; 0x03
      b4:	87 7f       	andi	r24, 0xF7	; 247
      b6:	8b 83       	std	Y+3, r24	; 0x03
      b8:	8b 81       	ldd	r24, Y+3	; 0x03
      ba:	82 60       	ori	r24, 0x02	; 2
      bc:	8b 83       	std	Y+3, r24	; 0x03
      be:	8b 81       	ldd	r24, Y+3	; 0x03
      c0:	84 60       	ori	r24, 0x04	; 4
      c2:	8b 83       	std	Y+3, r24	; 0x03
      c4:	aa e2       	ldi	r26, 0x2A	; 42
      c6:	b0 e0       	ldi	r27, 0x00	; 0
      c8:	ea e2       	ldi	r30, 0x2A	; 42
      ca:	f0 e0       	ldi	r31, 0x00	; 0
      cc:	80 81       	ld	r24, Z
      ce:	8b 7f       	andi	r24, 0xFB	; 251
      d0:	8c 93       	st	X, r24
      d2:	8b 81       	ldd	r24, Y+3	; 0x03
      d4:	80 68       	ori	r24, 0x80	; 128
      d6:	8b 83       	std	Y+3, r24	; 0x03
      d8:	e0 e4       	ldi	r30, 0x40	; 64
      da:	f0 e0       	ldi	r31, 0x00	; 0
      dc:	8b 81       	ldd	r24, Y+3	; 0x03
      de:	80 83       	st	Z, r24
      e0:	88 e6       	ldi	r24, 0x68	; 104
      e2:	90 e0       	ldi	r25, 0x00	; 0
      e4:	9a 83       	std	Y+2, r25	; 0x02
      e6:	89 83       	std	Y+1, r24	; 0x01
      e8:	e9 e2       	ldi	r30, 0x29	; 41
      ea:	f0 e0       	ldi	r31, 0x00	; 0
      ec:	89 81       	ldd	r24, Y+1	; 0x01
      ee:	80 83       	st	Z, r24
      f0:	e0 e4       	ldi	r30, 0x40	; 64
      f2:	f0 e0       	ldi	r31, 0x00	; 0
      f4:	89 81       	ldd	r24, Y+1	; 0x01
      f6:	9a 81       	ldd	r25, Y+2	; 0x02
      f8:	89 2f       	mov	r24, r25
      fa:	99 27       	eor	r25, r25
      fc:	80 83       	st	Z, r24
      fe:	aa e2       	ldi	r26, 0x2A	; 42
     100:	b0 e0       	ldi	r27, 0x00	; 0
     102:	ea e2       	ldi	r30, 0x2A	; 42
     104:	f0 e0       	ldi	r31, 0x00	; 0
     106:	80 81       	ld	r24, Z
     108:	88 60       	ori	r24, 0x08	; 8
     10a:	8c 93       	st	X, r24
     10c:	aa e2       	ldi	r26, 0x2A	; 42
     10e:	b0 e0       	ldi	r27, 0x00	; 0
     110:	ea e2       	ldi	r30, 0x2A	; 42
     112:	f0 e0       	ldi	r31, 0x00	; 0
     114:	80 81       	ld	r24, Z
     116:	80 61       	ori	r24, 0x10	; 16
     118:	8c 93       	st	X, r24
     11a:	0f 90       	pop	r0
     11c:	0f 90       	pop	r0
     11e:	0f 90       	pop	r0
     120:	cf 91       	pop	r28
     122:	df 91       	pop	r29
     124:	08 95       	ret

00000126 <MUSART_SendChar>:
	SET_BIT(UCSRB,4);
}


void MUSART_SendChar(u8 TransmitValue)
{
     126:	df 93       	push	r29
     128:	cf 93       	push	r28
     12a:	0f 92       	push	r0
     12c:	cd b7       	in	r28, 0x3d	; 61
     12e:	de b7       	in	r29, 0x3e	; 62
     130:	89 83       	std	Y+1, r24	; 0x01
	/*Poll on UDRE Flag*/
	while(GET_BIT(UCSRA,5)==0)
     132:	eb e2       	ldi	r30, 0x2B	; 43
     134:	f0 e0       	ldi	r31, 0x00	; 0
     136:	80 81       	ld	r24, Z
     138:	82 95       	swap	r24
     13a:	86 95       	lsr	r24
     13c:	87 70       	andi	r24, 0x07	; 7
     13e:	88 2f       	mov	r24, r24
     140:	90 e0       	ldi	r25, 0x00	; 0
     142:	81 70       	andi	r24, 0x01	; 1
     144:	90 70       	andi	r25, 0x00	; 0
     146:	00 97       	sbiw	r24, 0x00	; 0
     148:	a1 f3       	breq	.-24     	; 0x132 <MUSART_SendChar+0xc>
	{
		/*Do Nothing */
	}
	//Send Value to UDR
	UDR=TransmitValue;
     14a:	ec e2       	ldi	r30, 0x2C	; 44
     14c:	f0 e0       	ldi	r31, 0x00	; 0
     14e:	89 81       	ldd	r24, Y+1	; 0x01
     150:	80 83       	st	Z, r24
}
     152:	0f 90       	pop	r0
     154:	cf 91       	pop	r28
     156:	df 91       	pop	r29
     158:	08 95       	ret

0000015a <MUSART_ReceiveChar>:

u8 MUSART_ReceiveChar()
{
     15a:	df 93       	push	r29
     15c:	cf 93       	push	r28
     15e:	cd b7       	in	r28, 0x3d	; 61
     160:	de b7       	in	r29, 0x3e	; 62
	/*Poll on RXC Flag*/
	while(GET_BIT(UCSRA,7)==0)
     162:	eb e2       	ldi	r30, 0x2B	; 43
     164:	f0 e0       	ldi	r31, 0x00	; 0
     166:	80 81       	ld	r24, Z
     168:	88 23       	and	r24, r24
     16a:	dc f7       	brge	.-10     	; 0x162 <MUSART_ReceiveChar+0x8>
	{
		/*Do Nothing */
	}
	//Save UDR Content
	return UDR;
     16c:	ec e2       	ldi	r30, 0x2C	; 44
     16e:	f0 e0       	ldi	r31, 0x00	; 0
     170:	80 81       	ld	r24, Z
}
     172:	cf 91       	pop	r28
     174:	df 91       	pop	r29
     176:	08 95       	ret

00000178 <MUSART_SendString>:



void MUSART_SendString(u8* P_TransmitString)
{
     178:	df 93       	push	r29
     17a:	cf 93       	push	r28
     17c:	00 d0       	rcall	.+0      	; 0x17e <MUSART_SendString+0x6>
     17e:	0f 92       	push	r0
     180:	cd b7       	in	r28, 0x3d	; 61
     182:	de b7       	in	r29, 0x3e	; 62
     184:	9b 83       	std	Y+3, r25	; 0x03
     186:	8a 83       	std	Y+2, r24	; 0x02
	u8 Loc_TransmitCounter=0;
     188:	19 82       	std	Y+1, r1	; 0x01
     18a:	0e c0       	rjmp	.+28     	; 0x1a8 <MUSART_SendString+0x30>

	while(P_TransmitString[Loc_TransmitCounter]!=NULL)
	{
		MUSART_SendChar(P_TransmitString[Loc_TransmitCounter]);
     18c:	89 81       	ldd	r24, Y+1	; 0x01
     18e:	28 2f       	mov	r18, r24
     190:	30 e0       	ldi	r19, 0x00	; 0
     192:	8a 81       	ldd	r24, Y+2	; 0x02
     194:	9b 81       	ldd	r25, Y+3	; 0x03
     196:	fc 01       	movw	r30, r24
     198:	e2 0f       	add	r30, r18
     19a:	f3 1f       	adc	r31, r19
     19c:	80 81       	ld	r24, Z
     19e:	0e 94 93 00 	call	0x126	; 0x126 <MUSART_SendChar>
		Loc_TransmitCounter++;
     1a2:	89 81       	ldd	r24, Y+1	; 0x01
     1a4:	8f 5f       	subi	r24, 0xFF	; 255
     1a6:	89 83       	std	Y+1, r24	; 0x01

void MUSART_SendString(u8* P_TransmitString)
{
	u8 Loc_TransmitCounter=0;

	while(P_TransmitString[Loc_TransmitCounter]!=NULL)
     1a8:	89 81       	ldd	r24, Y+1	; 0x01
     1aa:	28 2f       	mov	r18, r24
     1ac:	30 e0       	ldi	r19, 0x00	; 0
     1ae:	8a 81       	ldd	r24, Y+2	; 0x02
     1b0:	9b 81       	ldd	r25, Y+3	; 0x03
     1b2:	fc 01       	movw	r30, r24
     1b4:	e2 0f       	add	r30, r18
     1b6:	f3 1f       	adc	r31, r19
     1b8:	80 81       	ld	r24, Z
     1ba:	88 23       	and	r24, r24
     1bc:	39 f7       	brne	.-50     	; 0x18c <MUSART_SendString+0x14>
	{
		MUSART_SendChar(P_TransmitString[Loc_TransmitCounter]);
		Loc_TransmitCounter++;
	}
}
     1be:	0f 90       	pop	r0
     1c0:	0f 90       	pop	r0
     1c2:	0f 90       	pop	r0
     1c4:	cf 91       	pop	r28
     1c6:	df 91       	pop	r29
     1c8:	08 95       	ret

000001ca <MUSART_ReceiveString>:


void MUSART_ReceiveString(u8* P_ReceiveString)
{
     1ca:	0f 93       	push	r16
     1cc:	1f 93       	push	r17
     1ce:	df 93       	push	r29
     1d0:	cf 93       	push	r28
     1d2:	00 d0       	rcall	.+0      	; 0x1d4 <MUSART_ReceiveString+0xa>
     1d4:	0f 92       	push	r0
     1d6:	cd b7       	in	r28, 0x3d	; 61
     1d8:	de b7       	in	r29, 0x3e	; 62
     1da:	9b 83       	std	Y+3, r25	; 0x03
     1dc:	8a 83       	std	Y+2, r24	; 0x02
	u8 Loc_ReceiveCounter=0;
     1de:	19 82       	std	Y+1, r1	; 0x01
     1e0:	0f c0       	rjmp	.+30     	; 0x200 <MUSART_ReceiveString+0x36>

	while(P_ReceiveString[Loc_ReceiveCounter]!='\n')
	{
		//Receive
	P_ReceiveString[Loc_ReceiveCounter]=MUSART_ReceiveChar();
     1e2:	89 81       	ldd	r24, Y+1	; 0x01
     1e4:	28 2f       	mov	r18, r24
     1e6:	30 e0       	ldi	r19, 0x00	; 0
     1e8:	8a 81       	ldd	r24, Y+2	; 0x02
     1ea:	9b 81       	ldd	r25, Y+3	; 0x03
     1ec:	8c 01       	movw	r16, r24
     1ee:	02 0f       	add	r16, r18
     1f0:	13 1f       	adc	r17, r19
     1f2:	0e 94 ad 00 	call	0x15a	; 0x15a <MUSART_ReceiveChar>
     1f6:	f8 01       	movw	r30, r16
     1f8:	80 83       	st	Z, r24
	Loc_ReceiveCounter++;
     1fa:	89 81       	ldd	r24, Y+1	; 0x01
     1fc:	8f 5f       	subi	r24, 0xFF	; 255
     1fe:	89 83       	std	Y+1, r24	; 0x01

void MUSART_ReceiveString(u8* P_ReceiveString)
{
	u8 Loc_ReceiveCounter=0;

	while(P_ReceiveString[Loc_ReceiveCounter]!='\n')
     200:	89 81       	ldd	r24, Y+1	; 0x01
     202:	28 2f       	mov	r18, r24
     204:	30 e0       	ldi	r19, 0x00	; 0
     206:	8a 81       	ldd	r24, Y+2	; 0x02
     208:	9b 81       	ldd	r25, Y+3	; 0x03
     20a:	fc 01       	movw	r30, r24
     20c:	e2 0f       	add	r30, r18
     20e:	f3 1f       	adc	r31, r19
     210:	80 81       	ld	r24, Z
     212:	8a 30       	cpi	r24, 0x0A	; 10
     214:	31 f7       	brne	.-52     	; 0x1e2 <MUSART_ReceiveString+0x18>
	{
		//Receive
	P_ReceiveString[Loc_ReceiveCounter]=MUSART_ReceiveChar();
	Loc_ReceiveCounter++;
	}
}
     216:	0f 90       	pop	r0
     218:	0f 90       	pop	r0
     21a:	0f 90       	pop	r0
     21c:	cf 91       	pop	r28
     21e:	df 91       	pop	r29
     220:	1f 91       	pop	r17
     222:	0f 91       	pop	r16
     224:	08 95       	ret

00000226 <MTIMER0_Init>:
 * 3-Set Interrupt State
 * 4-Set Prescalar
 */

void MTIMER0_Init()
{
     226:	df 93       	push	r29
     228:	cf 93       	push	r28
     22a:	cd b7       	in	r28, 0x3d	; 61
     22c:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(TIMSK,0);
#endif

	//============================CTC Mode
#elif TIMER0_MODE==TIMER_CTC_MODE
	SET_BIT(TCCR0,3);
     22e:	a3 e5       	ldi	r26, 0x53	; 83
     230:	b0 e0       	ldi	r27, 0x00	; 0
     232:	e3 e5       	ldi	r30, 0x53	; 83
     234:	f0 e0       	ldi	r31, 0x00	; 0
     236:	80 81       	ld	r24, Z
     238:	88 60       	ori	r24, 0x08	; 8
     23a:	8c 93       	st	X, r24
	CLR_BIT(TCCR0,6);
     23c:	a3 e5       	ldi	r26, 0x53	; 83
     23e:	b0 e0       	ldi	r27, 0x00	; 0
     240:	e3 e5       	ldi	r30, 0x53	; 83
     242:	f0 e0       	ldi	r31, 0x00	; 0
     244:	80 81       	ld	r24, Z
     246:	8f 7b       	andi	r24, 0xBF	; 191
     248:	8c 93       	st	X, r24


	//Set OC0 Mode
#if TIMER0_OC0_MODE==OC0_PIN_DISCONNECTED
	CLR_BIT(TCCR0,4);
     24a:	a3 e5       	ldi	r26, 0x53	; 83
     24c:	b0 e0       	ldi	r27, 0x00	; 0
     24e:	e3 e5       	ldi	r30, 0x53	; 83
     250:	f0 e0       	ldi	r31, 0x00	; 0
     252:	80 81       	ld	r24, Z
     254:	8f 7e       	andi	r24, 0xEF	; 239
     256:	8c 93       	st	X, r24
	CLR_BIT(TCCR0,5);
     258:	a3 e5       	ldi	r26, 0x53	; 83
     25a:	b0 e0       	ldi	r27, 0x00	; 0
     25c:	e3 e5       	ldi	r30, 0x53	; 83
     25e:	f0 e0       	ldi	r31, 0x00	; 0
     260:	80 81       	ld	r24, Z
     262:	8f 7d       	andi	r24, 0xDF	; 223
     264:	8c 93       	st	X, r24

	//Set CTC Mode interrupt
#if TIMER0_CTC_MODE_INTERRUPT_STATE==NORMAL_MODE_INTERRUPT_DISABLED
	CLR_BIT(TIMSK,1);
#elif TIMER0_CTC_MODE_INTERRUPT_STATE==NORMAL_MODE_INTERRUPT_ENABLED
	SET_BIT(TIMSK,1);
     266:	a9 e5       	ldi	r26, 0x59	; 89
     268:	b0 e0       	ldi	r27, 0x00	; 0
     26a:	e9 e5       	ldi	r30, 0x59	; 89
     26c:	f0 e0       	ldi	r31, 0x00	; 0
     26e:	80 81       	ld	r24, Z
     270:	82 60       	ori	r24, 0x02	; 2
     272:	8c 93       	st	X, r24
#elif TIMER0_CLOCK_SOURCE==PRESCALAR_OVER_256
	CLR_BIT(TCCR0,0);
	CLR_BIT(TCCR0,1);
	SET_BIT(TCCR0,2);
#elif TIMER0_CLOCK_SOURCE==PRESCALAR_OVER_1024
	SET_BIT(TCCR0,0);
     274:	a3 e5       	ldi	r26, 0x53	; 83
     276:	b0 e0       	ldi	r27, 0x00	; 0
     278:	e3 e5       	ldi	r30, 0x53	; 83
     27a:	f0 e0       	ldi	r31, 0x00	; 0
     27c:	80 81       	ld	r24, Z
     27e:	81 60       	ori	r24, 0x01	; 1
     280:	8c 93       	st	X, r24
	CLR_BIT(TCCR0,1);
     282:	a3 e5       	ldi	r26, 0x53	; 83
     284:	b0 e0       	ldi	r27, 0x00	; 0
     286:	e3 e5       	ldi	r30, 0x53	; 83
     288:	f0 e0       	ldi	r31, 0x00	; 0
     28a:	80 81       	ld	r24, Z
     28c:	8d 7f       	andi	r24, 0xFD	; 253
     28e:	8c 93       	st	X, r24
	SET_BIT(TCCR0,2);
     290:	a3 e5       	ldi	r26, 0x53	; 83
     292:	b0 e0       	ldi	r27, 0x00	; 0
     294:	e3 e5       	ldi	r30, 0x53	; 83
     296:	f0 e0       	ldi	r31, 0x00	; 0
     298:	80 81       	ld	r24, Z
     29a:	84 60       	ori	r24, 0x04	; 4
     29c:	8c 93       	st	X, r24
	SET_BIT(TCCR0,0);
	SET_BIT(TCCR0,1);
	SET_BIT(TCCR0,2);
#endif

}
     29e:	cf 91       	pop	r28
     2a0:	df 91       	pop	r29
     2a2:	08 95       	ret

000002a4 <MTIMER0_SetPreload>:

void MTIMER0_SetPreload(u8 Copy_u8Preload)
{
     2a4:	df 93       	push	r29
     2a6:	cf 93       	push	r28
     2a8:	0f 92       	push	r0
     2aa:	cd b7       	in	r28, 0x3d	; 61
     2ac:	de b7       	in	r29, 0x3e	; 62
     2ae:	89 83       	std	Y+1, r24	; 0x01
	TCCR0=Copy_u8Preload;
     2b0:	e3 e5       	ldi	r30, 0x53	; 83
     2b2:	f0 e0       	ldi	r31, 0x00	; 0
     2b4:	89 81       	ldd	r24, Y+1	; 0x01
     2b6:	80 83       	st	Z, r24

}
     2b8:	0f 90       	pop	r0
     2ba:	cf 91       	pop	r28
     2bc:	df 91       	pop	r29
     2be:	08 95       	ret

000002c0 <MTIMER0_SetCTC>:

void MTIMER0_SetCTC(u8 Copy_u8OCR)
{
     2c0:	df 93       	push	r29
     2c2:	cf 93       	push	r28
     2c4:	0f 92       	push	r0
     2c6:	cd b7       	in	r28, 0x3d	; 61
     2c8:	de b7       	in	r29, 0x3e	; 62
     2ca:	89 83       	std	Y+1, r24	; 0x01
	OCR0=Copy_u8OCR;
     2cc:	ec e5       	ldi	r30, 0x5C	; 92
     2ce:	f0 e0       	ldi	r31, 0x00	; 0
     2d0:	89 81       	ldd	r24, Y+1	; 0x01
     2d2:	80 83       	st	Z, r24
}
     2d4:	0f 90       	pop	r0
     2d6:	cf 91       	pop	r28
     2d8:	df 91       	pop	r29
     2da:	08 95       	ret

000002dc <MTIMER0_OVERFLOW_CALLBACK>:


void MTIMER0_OVERFLOW_CALLBACK(void(*Ptr_OverflowApp)(void))
{
     2dc:	df 93       	push	r29
     2de:	cf 93       	push	r28
     2e0:	00 d0       	rcall	.+0      	; 0x2e2 <MTIMER0_OVERFLOW_CALLBACK+0x6>
     2e2:	cd b7       	in	r28, 0x3d	; 61
     2e4:	de b7       	in	r29, 0x3e	; 62
     2e6:	9a 83       	std	Y+2, r25	; 0x02
     2e8:	89 83       	std	Y+1, r24	; 0x01
	if(Ptr_OverflowApp!=NULL)
     2ea:	89 81       	ldd	r24, Y+1	; 0x01
     2ec:	9a 81       	ldd	r25, Y+2	; 0x02
     2ee:	00 97       	sbiw	r24, 0x00	; 0
     2f0:	61 f0       	breq	.+24     	; 0x30a <MTIMER0_OVERFLOW_CALLBACK+0x2e>
	{
		if(Glob_OverflowISR_Ptr==NULL)
     2f2:	80 91 b0 00 	lds	r24, 0x00B0
     2f6:	90 91 b1 00 	lds	r25, 0x00B1
     2fa:	00 97       	sbiw	r24, 0x00	; 0
     2fc:	31 f4       	brne	.+12     	; 0x30a <MTIMER0_OVERFLOW_CALLBACK+0x2e>
		{
			Glob_OverflowISR_Ptr=Ptr_OverflowApp;
     2fe:	89 81       	ldd	r24, Y+1	; 0x01
     300:	9a 81       	ldd	r25, Y+2	; 0x02
     302:	90 93 b1 00 	sts	0x00B1, r25
     306:	80 93 b0 00 	sts	0x00B0, r24
		}
	}
}
     30a:	0f 90       	pop	r0
     30c:	0f 90       	pop	r0
     30e:	cf 91       	pop	r28
     310:	df 91       	pop	r29
     312:	08 95       	ret

00000314 <MTIMER0_CTC_CALLBACK>:


void MTIMER0_CTC_CALLBACK(void(*Ptr_CTCApp)(void))
{
     314:	df 93       	push	r29
     316:	cf 93       	push	r28
     318:	00 d0       	rcall	.+0      	; 0x31a <MTIMER0_CTC_CALLBACK+0x6>
     31a:	cd b7       	in	r28, 0x3d	; 61
     31c:	de b7       	in	r29, 0x3e	; 62
     31e:	9a 83       	std	Y+2, r25	; 0x02
     320:	89 83       	std	Y+1, r24	; 0x01
	if(Ptr_CTCApp !=NULL)
     322:	89 81       	ldd	r24, Y+1	; 0x01
     324:	9a 81       	ldd	r25, Y+2	; 0x02
     326:	00 97       	sbiw	r24, 0x00	; 0
     328:	61 f0       	breq	.+24     	; 0x342 <MTIMER0_CTC_CALLBACK+0x2e>
	{
		if(Glob_CTC_ISR_Ptr==NULL)
     32a:	80 91 b2 00 	lds	r24, 0x00B2
     32e:	90 91 b3 00 	lds	r25, 0x00B3
     332:	00 97       	sbiw	r24, 0x00	; 0
     334:	31 f4       	brne	.+12     	; 0x342 <MTIMER0_CTC_CALLBACK+0x2e>
		{
			Glob_CTC_ISR_Ptr=Ptr_CTCApp;
     336:	89 81       	ldd	r24, Y+1	; 0x01
     338:	9a 81       	ldd	r25, Y+2	; 0x02
     33a:	90 93 b3 00 	sts	0x00B3, r25
     33e:	80 93 b2 00 	sts	0x00B2, r24
		}
	}
}
     342:	0f 90       	pop	r0
     344:	0f 90       	pop	r0
     346:	cf 91       	pop	r28
     348:	df 91       	pop	r29
     34a:	08 95       	ret

0000034c <MTIMER0_SetDutyCycle>:


void MTIMER0_SetDutyCycle(u8 Copy_u8DutyCycle)
{
     34c:	df 93       	push	r29
     34e:	cf 93       	push	r28
     350:	00 d0       	rcall	.+0      	; 0x352 <MTIMER0_SetDutyCycle+0x6>
     352:	cd b7       	in	r28, 0x3d	; 61
     354:	de b7       	in	r29, 0x3e	; 62
     356:	8a 83       	std	Y+2, r24	; 0x02
	u8 CTC_Value;
	if((Copy_u8DutyCycle>=0)&&(Copy_u8DutyCycle<=100))
     358:	8a 81       	ldd	r24, Y+2	; 0x02
     35a:	85 36       	cpi	r24, 0x65	; 101
     35c:	20 f5       	brcc	.+72     	; 0x3a6 <MTIMER0_SetDutyCycle+0x5a>
	{
		CTC_Value=((u32)(Copy_u8DutyCycle*255))/100 ;
     35e:	8a 81       	ldd	r24, Y+2	; 0x02
     360:	48 2f       	mov	r20, r24
     362:	50 e0       	ldi	r21, 0x00	; 0
     364:	ca 01       	movw	r24, r20
     366:	9c 01       	movw	r18, r24
     368:	22 0f       	add	r18, r18
     36a:	33 1f       	adc	r19, r19
     36c:	c9 01       	movw	r24, r18
     36e:	96 95       	lsr	r25
     370:	98 2f       	mov	r25, r24
     372:	88 27       	eor	r24, r24
     374:	97 95       	ror	r25
     376:	87 95       	ror	r24
     378:	82 1b       	sub	r24, r18
     37a:	93 0b       	sbc	r25, r19
     37c:	84 0f       	add	r24, r20
     37e:	95 1f       	adc	r25, r21
     380:	aa 27       	eor	r26, r26
     382:	97 fd       	sbrc	r25, 7
     384:	a0 95       	com	r26
     386:	ba 2f       	mov	r27, r26
     388:	24 e6       	ldi	r18, 0x64	; 100
     38a:	30 e0       	ldi	r19, 0x00	; 0
     38c:	40 e0       	ldi	r20, 0x00	; 0
     38e:	50 e0       	ldi	r21, 0x00	; 0
     390:	bc 01       	movw	r22, r24
     392:	cd 01       	movw	r24, r26
     394:	0e 94 ed 1d 	call	0x3bda	; 0x3bda <__udivmodsi4>
     398:	da 01       	movw	r26, r20
     39a:	c9 01       	movw	r24, r18
     39c:	89 83       	std	Y+1, r24	; 0x01
		OCR0=CTC_Value;
     39e:	ec e5       	ldi	r30, 0x5C	; 92
     3a0:	f0 e0       	ldi	r31, 0x00	; 0
     3a2:	89 81       	ldd	r24, Y+1	; 0x01
     3a4:	80 83       	st	Z, r24
	}

}
     3a6:	0f 90       	pop	r0
     3a8:	0f 90       	pop	r0
     3aa:	cf 91       	pop	r28
     3ac:	df 91       	pop	r29
     3ae:	08 95       	ret

000003b0 <__vector_10>:


//CTC ISR
void __vector_10(void) __attribute__((signal));
void __vector_10(void)
{
     3b0:	1f 92       	push	r1
     3b2:	0f 92       	push	r0
     3b4:	0f b6       	in	r0, 0x3f	; 63
     3b6:	0f 92       	push	r0
     3b8:	11 24       	eor	r1, r1
     3ba:	2f 93       	push	r18
     3bc:	3f 93       	push	r19
     3be:	4f 93       	push	r20
     3c0:	5f 93       	push	r21
     3c2:	6f 93       	push	r22
     3c4:	7f 93       	push	r23
     3c6:	8f 93       	push	r24
     3c8:	9f 93       	push	r25
     3ca:	af 93       	push	r26
     3cc:	bf 93       	push	r27
     3ce:	ef 93       	push	r30
     3d0:	ff 93       	push	r31
     3d2:	df 93       	push	r29
     3d4:	cf 93       	push	r28
     3d6:	cd b7       	in	r28, 0x3d	; 61
     3d8:	de b7       	in	r29, 0x3e	; 62
	if(Glob_CTC_ISR_Ptr!=NULL)
     3da:	80 91 b2 00 	lds	r24, 0x00B2
     3de:	90 91 b3 00 	lds	r25, 0x00B3
     3e2:	00 97       	sbiw	r24, 0x00	; 0
     3e4:	29 f0       	breq	.+10     	; 0x3f0 <__vector_10+0x40>
	{
		Glob_CTC_ISR_Ptr();
     3e6:	e0 91 b2 00 	lds	r30, 0x00B2
     3ea:	f0 91 b3 00 	lds	r31, 0x00B3
     3ee:	09 95       	icall
	}
}
     3f0:	cf 91       	pop	r28
     3f2:	df 91       	pop	r29
     3f4:	ff 91       	pop	r31
     3f6:	ef 91       	pop	r30
     3f8:	bf 91       	pop	r27
     3fa:	af 91       	pop	r26
     3fc:	9f 91       	pop	r25
     3fe:	8f 91       	pop	r24
     400:	7f 91       	pop	r23
     402:	6f 91       	pop	r22
     404:	5f 91       	pop	r21
     406:	4f 91       	pop	r20
     408:	3f 91       	pop	r19
     40a:	2f 91       	pop	r18
     40c:	0f 90       	pop	r0
     40e:	0f be       	out	0x3f, r0	; 63
     410:	0f 90       	pop	r0
     412:	1f 90       	pop	r1
     414:	18 95       	reti

00000416 <__vector_11>:

//Overflow ISR
void __vector_11(void) __attribute__((signal));
void __vector_11(void)
{
     416:	1f 92       	push	r1
     418:	0f 92       	push	r0
     41a:	0f b6       	in	r0, 0x3f	; 63
     41c:	0f 92       	push	r0
     41e:	11 24       	eor	r1, r1
     420:	2f 93       	push	r18
     422:	3f 93       	push	r19
     424:	4f 93       	push	r20
     426:	5f 93       	push	r21
     428:	6f 93       	push	r22
     42a:	7f 93       	push	r23
     42c:	8f 93       	push	r24
     42e:	9f 93       	push	r25
     430:	af 93       	push	r26
     432:	bf 93       	push	r27
     434:	ef 93       	push	r30
     436:	ff 93       	push	r31
     438:	df 93       	push	r29
     43a:	cf 93       	push	r28
     43c:	cd b7       	in	r28, 0x3d	; 61
     43e:	de b7       	in	r29, 0x3e	; 62
	if(Glob_OverflowISR_Ptr!=NULL)
     440:	80 91 b0 00 	lds	r24, 0x00B0
     444:	90 91 b1 00 	lds	r25, 0x00B1
     448:	00 97       	sbiw	r24, 0x00	; 0
     44a:	29 f0       	breq	.+10     	; 0x456 <__vector_11+0x40>
	{
		Glob_OverflowISR_Ptr();
     44c:	e0 91 b0 00 	lds	r30, 0x00B0
     450:	f0 91 b1 00 	lds	r31, 0x00B1
     454:	09 95       	icall
	}
}
     456:	cf 91       	pop	r28
     458:	df 91       	pop	r29
     45a:	ff 91       	pop	r31
     45c:	ef 91       	pop	r30
     45e:	bf 91       	pop	r27
     460:	af 91       	pop	r26
     462:	9f 91       	pop	r25
     464:	8f 91       	pop	r24
     466:	7f 91       	pop	r23
     468:	6f 91       	pop	r22
     46a:	5f 91       	pop	r21
     46c:	4f 91       	pop	r20
     46e:	3f 91       	pop	r19
     470:	2f 91       	pop	r18
     472:	0f 90       	pop	r0
     474:	0f be       	out	0x3f, r0	; 63
     476:	0f 90       	pop	r0
     478:	1f 90       	pop	r1
     47a:	18 95       	reti

0000047c <MGIE_Enable>:
#include"../../LIB/BIT_MATH.h"
#include"MGIE_Private.h"

/*Functions Prototypes*/
void MGIE_Enable(void)
{
     47c:	df 93       	push	r29
     47e:	cf 93       	push	r28
     480:	cd b7       	in	r28, 0x3d	; 61
     482:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(SREG,7);
     484:	af e5       	ldi	r26, 0x5F	; 95
     486:	b0 e0       	ldi	r27, 0x00	; 0
     488:	ef e5       	ldi	r30, 0x5F	; 95
     48a:	f0 e0       	ldi	r31, 0x00	; 0
     48c:	80 81       	ld	r24, Z
     48e:	80 68       	ori	r24, 0x80	; 128
     490:	8c 93       	st	X, r24
}
     492:	cf 91       	pop	r28
     494:	df 91       	pop	r29
     496:	08 95       	ret

00000498 <MGIE_Disable>:

void MGIE_Disable(void)
{
     498:	df 93       	push	r29
     49a:	cf 93       	push	r28
     49c:	cd b7       	in	r28, 0x3d	; 61
     49e:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(SREG,7);
     4a0:	af e5       	ldi	r26, 0x5F	; 95
     4a2:	b0 e0       	ldi	r27, 0x00	; 0
     4a4:	ef e5       	ldi	r30, 0x5F	; 95
     4a6:	f0 e0       	ldi	r31, 0x00	; 0
     4a8:	80 81       	ld	r24, Z
     4aa:	8f 77       	andi	r24, 0x7F	; 127
     4ac:	8c 93       	st	X, r24
}
     4ae:	cf 91       	pop	r28
     4b0:	df 91       	pop	r29
     4b2:	08 95       	ret

000004b4 <MEXTI0_Init>:
#include"../../LIB/BIT_MATH.h"
#include"MEXTI_Config.h"


void MEXTI0_Init()
{
     4b4:	df 93       	push	r29
     4b6:	cf 93       	push	r28
     4b8:	cd b7       	in	r28, 0x3d	; 61
     4ba:	de b7       	in	r29, 0x3e	; 62
#if MEXTI_SENSE_CONTROL_STATE==MEXTI_LOW_LEVEL

	CLR_BIT(MCUCR,0);
     4bc:	a5 e5       	ldi	r26, 0x55	; 85
     4be:	b0 e0       	ldi	r27, 0x00	; 0
     4c0:	e5 e5       	ldi	r30, 0x55	; 85
     4c2:	f0 e0       	ldi	r31, 0x00	; 0
     4c4:	80 81       	ld	r24, Z
     4c6:	8e 7f       	andi	r24, 0xFE	; 254
     4c8:	8c 93       	st	X, r24
	CLR_BIT(MCUCR,1);
     4ca:	a5 e5       	ldi	r26, 0x55	; 85
     4cc:	b0 e0       	ldi	r27, 0x00	; 0
     4ce:	e5 e5       	ldi	r30, 0x55	; 85
     4d0:	f0 e0       	ldi	r31, 0x00	; 0
     4d2:	80 81       	ld	r24, Z
     4d4:	8d 7f       	andi	r24, 0xFD	; 253
     4d6:	8c 93       	st	X, r24
	SET_BIT(MCUCR,0);
	SET_BIT(MCUCR,1);
#endif

	/*Enable Interrupt on INT0 ==> PIE of Interrupt zero*/
	SET_BIT(GICR,6);
     4d8:	ab e5       	ldi	r26, 0x5B	; 91
     4da:	b0 e0       	ldi	r27, 0x00	; 0
     4dc:	eb e5       	ldi	r30, 0x5B	; 91
     4de:	f0 e0       	ldi	r31, 0x00	; 0
     4e0:	80 81       	ld	r24, Z
     4e2:	80 64       	ori	r24, 0x40	; 64
     4e4:	8c 93       	st	X, r24
}
     4e6:	cf 91       	pop	r28
     4e8:	df 91       	pop	r29
     4ea:	08 95       	ret

000004ec <MEXTI1_Init>:

void MEXTI1_Init()
{
     4ec:	df 93       	push	r29
     4ee:	cf 93       	push	r28
     4f0:	cd b7       	in	r28, 0x3d	; 61
     4f2:	de b7       	in	r29, 0x3e	; 62

}
     4f4:	cf 91       	pop	r28
     4f6:	df 91       	pop	r29
     4f8:	08 95       	ret

000004fa <MEXTI2_Init>:

void MEXTI2_Init()
{
     4fa:	df 93       	push	r29
     4fc:	cf 93       	push	r28
     4fe:	cd b7       	in	r28, 0x3d	; 61
     500:	de b7       	in	r29, 0x3e	; 62

}
     502:	cf 91       	pop	r28
     504:	df 91       	pop	r29
     506:	08 95       	ret

00000508 <MDIO_SetPortDirection>:
#include"../../LIB/BIT_MATH.h"
#include"MDIO_Interface.h"
#include"MDIO_Private.h"

void MDIO_SetPortDirection(u8 Copy_u8PortNumber, u8 Copy_u8PortDirection)
{
     508:	df 93       	push	r29
     50a:	cf 93       	push	r28
     50c:	00 d0       	rcall	.+0      	; 0x50e <MDIO_SetPortDirection+0x6>
     50e:	00 d0       	rcall	.+0      	; 0x510 <MDIO_SetPortDirection+0x8>
     510:	cd b7       	in	r28, 0x3d	; 61
     512:	de b7       	in	r29, 0x3e	; 62
     514:	89 83       	std	Y+1, r24	; 0x01
     516:	6a 83       	std	Y+2, r22	; 0x02
	if((Copy_u8PortDirection==PORT_OUTPUT)||(Copy_u8PortDirection==PORT_INPUT))
     518:	8a 81       	ldd	r24, Y+2	; 0x02
     51a:	8f 3f       	cpi	r24, 0xFF	; 255
     51c:	19 f0       	breq	.+6      	; 0x524 <MDIO_SetPortDirection+0x1c>
     51e:	8a 81       	ldd	r24, Y+2	; 0x02
     520:	88 23       	and	r24, r24
     522:	91 f5       	brne	.+100    	; 0x588 <MDIO_SetPortDirection+0x80>
	{
		/*Valid Port Direction given */
		switch(Copy_u8PortNumber)
     524:	89 81       	ldd	r24, Y+1	; 0x01
     526:	28 2f       	mov	r18, r24
     528:	30 e0       	ldi	r19, 0x00	; 0
     52a:	3c 83       	std	Y+4, r19	; 0x04
     52c:	2b 83       	std	Y+3, r18	; 0x03
     52e:	8b 81       	ldd	r24, Y+3	; 0x03
     530:	9c 81       	ldd	r25, Y+4	; 0x04
     532:	81 30       	cpi	r24, 0x01	; 1
     534:	91 05       	cpc	r25, r1
     536:	d1 f0       	breq	.+52     	; 0x56c <MDIO_SetPortDirection+0x64>
     538:	2b 81       	ldd	r18, Y+3	; 0x03
     53a:	3c 81       	ldd	r19, Y+4	; 0x04
     53c:	22 30       	cpi	r18, 0x02	; 2
     53e:	31 05       	cpc	r19, r1
     540:	2c f4       	brge	.+10     	; 0x54c <MDIO_SetPortDirection+0x44>
     542:	8b 81       	ldd	r24, Y+3	; 0x03
     544:	9c 81       	ldd	r25, Y+4	; 0x04
     546:	00 97       	sbiw	r24, 0x00	; 0
     548:	61 f0       	breq	.+24     	; 0x562 <MDIO_SetPortDirection+0x5a>
     54a:	1e c0       	rjmp	.+60     	; 0x588 <MDIO_SetPortDirection+0x80>
     54c:	2b 81       	ldd	r18, Y+3	; 0x03
     54e:	3c 81       	ldd	r19, Y+4	; 0x04
     550:	22 30       	cpi	r18, 0x02	; 2
     552:	31 05       	cpc	r19, r1
     554:	81 f0       	breq	.+32     	; 0x576 <MDIO_SetPortDirection+0x6e>
     556:	8b 81       	ldd	r24, Y+3	; 0x03
     558:	9c 81       	ldd	r25, Y+4	; 0x04
     55a:	83 30       	cpi	r24, 0x03	; 3
     55c:	91 05       	cpc	r25, r1
     55e:	81 f0       	breq	.+32     	; 0x580 <MDIO_SetPortDirection+0x78>
     560:	13 c0       	rjmp	.+38     	; 0x588 <MDIO_SetPortDirection+0x80>
		{
		case MDIO_PORTA:
			DDRA=Copy_u8PortDirection;
     562:	ea e3       	ldi	r30, 0x3A	; 58
     564:	f0 e0       	ldi	r31, 0x00	; 0
     566:	8a 81       	ldd	r24, Y+2	; 0x02
     568:	80 83       	st	Z, r24
     56a:	0e c0       	rjmp	.+28     	; 0x588 <MDIO_SetPortDirection+0x80>
			break;
		case MDIO_PORTB:
			DDRB=Copy_u8PortDirection;
     56c:	e7 e3       	ldi	r30, 0x37	; 55
     56e:	f0 e0       	ldi	r31, 0x00	; 0
     570:	8a 81       	ldd	r24, Y+2	; 0x02
     572:	80 83       	st	Z, r24
     574:	09 c0       	rjmp	.+18     	; 0x588 <MDIO_SetPortDirection+0x80>
			break;
		case MDIO_PORTC:
			DDRC=Copy_u8PortDirection;
     576:	e4 e3       	ldi	r30, 0x34	; 52
     578:	f0 e0       	ldi	r31, 0x00	; 0
     57a:	8a 81       	ldd	r24, Y+2	; 0x02
     57c:	80 83       	st	Z, r24
     57e:	04 c0       	rjmp	.+8      	; 0x588 <MDIO_SetPortDirection+0x80>
			break;
		case MDIO_PORTD:
			DDRD=Copy_u8PortDirection;
     580:	e1 e3       	ldi	r30, 0x31	; 49
     582:	f0 e0       	ldi	r31, 0x00	; 0
     584:	8a 81       	ldd	r24, Y+2	; 0x02
     586:	80 83       	st	Z, r24
	}
	else
	{
		/*Invalid Port Direction given */
	}
}
     588:	0f 90       	pop	r0
     58a:	0f 90       	pop	r0
     58c:	0f 90       	pop	r0
     58e:	0f 90       	pop	r0
     590:	cf 91       	pop	r28
     592:	df 91       	pop	r29
     594:	08 95       	ret

00000596 <MDIO_SetPinDirection>:



void MDIO_SetPinDirection(u8 Copy_u8PinNumber,u8 Copy_u8PortNumber, u8 Copy_u8PinDirection)
{
     596:	df 93       	push	r29
     598:	cf 93       	push	r28
     59a:	00 d0       	rcall	.+0      	; 0x59c <MDIO_SetPinDirection+0x6>
     59c:	00 d0       	rcall	.+0      	; 0x59e <MDIO_SetPinDirection+0x8>
     59e:	0f 92       	push	r0
     5a0:	cd b7       	in	r28, 0x3d	; 61
     5a2:	de b7       	in	r29, 0x3e	; 62
     5a4:	89 83       	std	Y+1, r24	; 0x01
     5a6:	6a 83       	std	Y+2, r22	; 0x02
     5a8:	4b 83       	std	Y+3, r20	; 0x03
	if((Copy_u8PinNumber>=0)&&(Copy_u8PinNumber<8))
     5aa:	89 81       	ldd	r24, Y+1	; 0x01
     5ac:	88 30       	cpi	r24, 0x08	; 8
     5ae:	08 f0       	brcs	.+2      	; 0x5b2 <MDIO_SetPinDirection+0x1c>
     5b0:	e0 c0       	rjmp	.+448    	; 0x772 <MDIO_SetPinDirection+0x1dc>
	{
		switch(Copy_u8PortNumber)
     5b2:	8a 81       	ldd	r24, Y+2	; 0x02
     5b4:	28 2f       	mov	r18, r24
     5b6:	30 e0       	ldi	r19, 0x00	; 0
     5b8:	3d 83       	std	Y+5, r19	; 0x05
     5ba:	2c 83       	std	Y+4, r18	; 0x04
     5bc:	8c 81       	ldd	r24, Y+4	; 0x04
     5be:	9d 81       	ldd	r25, Y+5	; 0x05
     5c0:	81 30       	cpi	r24, 0x01	; 1
     5c2:	91 05       	cpc	r25, r1
     5c4:	09 f4       	brne	.+2      	; 0x5c8 <MDIO_SetPinDirection+0x32>
     5c6:	47 c0       	rjmp	.+142    	; 0x656 <MDIO_SetPinDirection+0xc0>
     5c8:	2c 81       	ldd	r18, Y+4	; 0x04
     5ca:	3d 81       	ldd	r19, Y+5	; 0x05
     5cc:	22 30       	cpi	r18, 0x02	; 2
     5ce:	31 05       	cpc	r19, r1
     5d0:	2c f4       	brge	.+10     	; 0x5dc <MDIO_SetPinDirection+0x46>
     5d2:	8c 81       	ldd	r24, Y+4	; 0x04
     5d4:	9d 81       	ldd	r25, Y+5	; 0x05
     5d6:	00 97       	sbiw	r24, 0x00	; 0
     5d8:	71 f0       	breq	.+28     	; 0x5f6 <MDIO_SetPinDirection+0x60>
     5da:	cb c0       	rjmp	.+406    	; 0x772 <MDIO_SetPinDirection+0x1dc>
     5dc:	2c 81       	ldd	r18, Y+4	; 0x04
     5de:	3d 81       	ldd	r19, Y+5	; 0x05
     5e0:	22 30       	cpi	r18, 0x02	; 2
     5e2:	31 05       	cpc	r19, r1
     5e4:	09 f4       	brne	.+2      	; 0x5e8 <MDIO_SetPinDirection+0x52>
     5e6:	67 c0       	rjmp	.+206    	; 0x6b6 <MDIO_SetPinDirection+0x120>
     5e8:	8c 81       	ldd	r24, Y+4	; 0x04
     5ea:	9d 81       	ldd	r25, Y+5	; 0x05
     5ec:	83 30       	cpi	r24, 0x03	; 3
     5ee:	91 05       	cpc	r25, r1
     5f0:	09 f4       	brne	.+2      	; 0x5f4 <MDIO_SetPinDirection+0x5e>
     5f2:	91 c0       	rjmp	.+290    	; 0x716 <MDIO_SetPinDirection+0x180>
     5f4:	be c0       	rjmp	.+380    	; 0x772 <MDIO_SetPinDirection+0x1dc>
		{
		case MDIO_PORTA:
			if(Copy_u8PinDirection==PIN_OUTPUT)
     5f6:	8b 81       	ldd	r24, Y+3	; 0x03
     5f8:	81 30       	cpi	r24, 0x01	; 1
     5fa:	a1 f4       	brne	.+40     	; 0x624 <MDIO_SetPinDirection+0x8e>
			{
				SET_BIT(DDRA,Copy_u8PinNumber);
     5fc:	aa e3       	ldi	r26, 0x3A	; 58
     5fe:	b0 e0       	ldi	r27, 0x00	; 0
     600:	ea e3       	ldi	r30, 0x3A	; 58
     602:	f0 e0       	ldi	r31, 0x00	; 0
     604:	80 81       	ld	r24, Z
     606:	48 2f       	mov	r20, r24
     608:	89 81       	ldd	r24, Y+1	; 0x01
     60a:	28 2f       	mov	r18, r24
     60c:	30 e0       	ldi	r19, 0x00	; 0
     60e:	81 e0       	ldi	r24, 0x01	; 1
     610:	90 e0       	ldi	r25, 0x00	; 0
     612:	02 2e       	mov	r0, r18
     614:	02 c0       	rjmp	.+4      	; 0x61a <MDIO_SetPinDirection+0x84>
     616:	88 0f       	add	r24, r24
     618:	99 1f       	adc	r25, r25
     61a:	0a 94       	dec	r0
     61c:	e2 f7       	brpl	.-8      	; 0x616 <MDIO_SetPinDirection+0x80>
     61e:	84 2b       	or	r24, r20
     620:	8c 93       	st	X, r24
     622:	a7 c0       	rjmp	.+334    	; 0x772 <MDIO_SetPinDirection+0x1dc>
			}
			else if(Copy_u8PinDirection==PIN_INPUT)
     624:	8b 81       	ldd	r24, Y+3	; 0x03
     626:	88 23       	and	r24, r24
     628:	09 f0       	breq	.+2      	; 0x62c <MDIO_SetPinDirection+0x96>
     62a:	a3 c0       	rjmp	.+326    	; 0x772 <MDIO_SetPinDirection+0x1dc>
			{
				CLR_BIT(DDRA,Copy_u8PinNumber);
     62c:	aa e3       	ldi	r26, 0x3A	; 58
     62e:	b0 e0       	ldi	r27, 0x00	; 0
     630:	ea e3       	ldi	r30, 0x3A	; 58
     632:	f0 e0       	ldi	r31, 0x00	; 0
     634:	80 81       	ld	r24, Z
     636:	48 2f       	mov	r20, r24
     638:	89 81       	ldd	r24, Y+1	; 0x01
     63a:	28 2f       	mov	r18, r24
     63c:	30 e0       	ldi	r19, 0x00	; 0
     63e:	81 e0       	ldi	r24, 0x01	; 1
     640:	90 e0       	ldi	r25, 0x00	; 0
     642:	02 2e       	mov	r0, r18
     644:	02 c0       	rjmp	.+4      	; 0x64a <MDIO_SetPinDirection+0xb4>
     646:	88 0f       	add	r24, r24
     648:	99 1f       	adc	r25, r25
     64a:	0a 94       	dec	r0
     64c:	e2 f7       	brpl	.-8      	; 0x646 <MDIO_SetPinDirection+0xb0>
     64e:	80 95       	com	r24
     650:	84 23       	and	r24, r20
     652:	8c 93       	st	X, r24
     654:	8e c0       	rjmp	.+284    	; 0x772 <MDIO_SetPinDirection+0x1dc>
			{
				//Invalid Pin Direction
			}
			break;
		case MDIO_PORTB:
			if(Copy_u8PinDirection==PIN_OUTPUT)
     656:	8b 81       	ldd	r24, Y+3	; 0x03
     658:	81 30       	cpi	r24, 0x01	; 1
     65a:	a1 f4       	brne	.+40     	; 0x684 <MDIO_SetPinDirection+0xee>
			{
				SET_BIT(DDRB,Copy_u8PinNumber);
     65c:	a7 e3       	ldi	r26, 0x37	; 55
     65e:	b0 e0       	ldi	r27, 0x00	; 0
     660:	e7 e3       	ldi	r30, 0x37	; 55
     662:	f0 e0       	ldi	r31, 0x00	; 0
     664:	80 81       	ld	r24, Z
     666:	48 2f       	mov	r20, r24
     668:	89 81       	ldd	r24, Y+1	; 0x01
     66a:	28 2f       	mov	r18, r24
     66c:	30 e0       	ldi	r19, 0x00	; 0
     66e:	81 e0       	ldi	r24, 0x01	; 1
     670:	90 e0       	ldi	r25, 0x00	; 0
     672:	02 2e       	mov	r0, r18
     674:	02 c0       	rjmp	.+4      	; 0x67a <MDIO_SetPinDirection+0xe4>
     676:	88 0f       	add	r24, r24
     678:	99 1f       	adc	r25, r25
     67a:	0a 94       	dec	r0
     67c:	e2 f7       	brpl	.-8      	; 0x676 <MDIO_SetPinDirection+0xe0>
     67e:	84 2b       	or	r24, r20
     680:	8c 93       	st	X, r24
     682:	77 c0       	rjmp	.+238    	; 0x772 <MDIO_SetPinDirection+0x1dc>
			}
			else if(Copy_u8PinDirection==PIN_INPUT)
     684:	8b 81       	ldd	r24, Y+3	; 0x03
     686:	88 23       	and	r24, r24
     688:	09 f0       	breq	.+2      	; 0x68c <MDIO_SetPinDirection+0xf6>
     68a:	73 c0       	rjmp	.+230    	; 0x772 <MDIO_SetPinDirection+0x1dc>
			{
				CLR_BIT(DDRB,Copy_u8PinNumber);
     68c:	a7 e3       	ldi	r26, 0x37	; 55
     68e:	b0 e0       	ldi	r27, 0x00	; 0
     690:	e7 e3       	ldi	r30, 0x37	; 55
     692:	f0 e0       	ldi	r31, 0x00	; 0
     694:	80 81       	ld	r24, Z
     696:	48 2f       	mov	r20, r24
     698:	89 81       	ldd	r24, Y+1	; 0x01
     69a:	28 2f       	mov	r18, r24
     69c:	30 e0       	ldi	r19, 0x00	; 0
     69e:	81 e0       	ldi	r24, 0x01	; 1
     6a0:	90 e0       	ldi	r25, 0x00	; 0
     6a2:	02 2e       	mov	r0, r18
     6a4:	02 c0       	rjmp	.+4      	; 0x6aa <MDIO_SetPinDirection+0x114>
     6a6:	88 0f       	add	r24, r24
     6a8:	99 1f       	adc	r25, r25
     6aa:	0a 94       	dec	r0
     6ac:	e2 f7       	brpl	.-8      	; 0x6a6 <MDIO_SetPinDirection+0x110>
     6ae:	80 95       	com	r24
     6b0:	84 23       	and	r24, r20
     6b2:	8c 93       	st	X, r24
     6b4:	5e c0       	rjmp	.+188    	; 0x772 <MDIO_SetPinDirection+0x1dc>
			{
				//Invalid Pin Direction
			}
			break;
		case MDIO_PORTC:
			if(Copy_u8PinDirection==PIN_OUTPUT)
     6b6:	8b 81       	ldd	r24, Y+3	; 0x03
     6b8:	81 30       	cpi	r24, 0x01	; 1
     6ba:	a1 f4       	brne	.+40     	; 0x6e4 <MDIO_SetPinDirection+0x14e>
			{
				SET_BIT(DDRC,Copy_u8PinNumber);
     6bc:	a4 e3       	ldi	r26, 0x34	; 52
     6be:	b0 e0       	ldi	r27, 0x00	; 0
     6c0:	e4 e3       	ldi	r30, 0x34	; 52
     6c2:	f0 e0       	ldi	r31, 0x00	; 0
     6c4:	80 81       	ld	r24, Z
     6c6:	48 2f       	mov	r20, r24
     6c8:	89 81       	ldd	r24, Y+1	; 0x01
     6ca:	28 2f       	mov	r18, r24
     6cc:	30 e0       	ldi	r19, 0x00	; 0
     6ce:	81 e0       	ldi	r24, 0x01	; 1
     6d0:	90 e0       	ldi	r25, 0x00	; 0
     6d2:	02 2e       	mov	r0, r18
     6d4:	02 c0       	rjmp	.+4      	; 0x6da <MDIO_SetPinDirection+0x144>
     6d6:	88 0f       	add	r24, r24
     6d8:	99 1f       	adc	r25, r25
     6da:	0a 94       	dec	r0
     6dc:	e2 f7       	brpl	.-8      	; 0x6d6 <MDIO_SetPinDirection+0x140>
     6de:	84 2b       	or	r24, r20
     6e0:	8c 93       	st	X, r24
     6e2:	47 c0       	rjmp	.+142    	; 0x772 <MDIO_SetPinDirection+0x1dc>
			}
			else if(Copy_u8PinDirection==PIN_INPUT)
     6e4:	8b 81       	ldd	r24, Y+3	; 0x03
     6e6:	88 23       	and	r24, r24
     6e8:	09 f0       	breq	.+2      	; 0x6ec <MDIO_SetPinDirection+0x156>
     6ea:	43 c0       	rjmp	.+134    	; 0x772 <MDIO_SetPinDirection+0x1dc>
			{
				CLR_BIT(DDRC,Copy_u8PinNumber);
     6ec:	a4 e3       	ldi	r26, 0x34	; 52
     6ee:	b0 e0       	ldi	r27, 0x00	; 0
     6f0:	e4 e3       	ldi	r30, 0x34	; 52
     6f2:	f0 e0       	ldi	r31, 0x00	; 0
     6f4:	80 81       	ld	r24, Z
     6f6:	48 2f       	mov	r20, r24
     6f8:	89 81       	ldd	r24, Y+1	; 0x01
     6fa:	28 2f       	mov	r18, r24
     6fc:	30 e0       	ldi	r19, 0x00	; 0
     6fe:	81 e0       	ldi	r24, 0x01	; 1
     700:	90 e0       	ldi	r25, 0x00	; 0
     702:	02 2e       	mov	r0, r18
     704:	02 c0       	rjmp	.+4      	; 0x70a <MDIO_SetPinDirection+0x174>
     706:	88 0f       	add	r24, r24
     708:	99 1f       	adc	r25, r25
     70a:	0a 94       	dec	r0
     70c:	e2 f7       	brpl	.-8      	; 0x706 <MDIO_SetPinDirection+0x170>
     70e:	80 95       	com	r24
     710:	84 23       	and	r24, r20
     712:	8c 93       	st	X, r24
     714:	2e c0       	rjmp	.+92     	; 0x772 <MDIO_SetPinDirection+0x1dc>
			{
				//Invalid Pin Direction
			}
			break;
		case MDIO_PORTD:
			if(Copy_u8PinDirection==PIN_OUTPUT)
     716:	8b 81       	ldd	r24, Y+3	; 0x03
     718:	81 30       	cpi	r24, 0x01	; 1
     71a:	a1 f4       	brne	.+40     	; 0x744 <MDIO_SetPinDirection+0x1ae>
			{
				SET_BIT(DDRD,Copy_u8PinNumber);
     71c:	a1 e3       	ldi	r26, 0x31	; 49
     71e:	b0 e0       	ldi	r27, 0x00	; 0
     720:	e1 e3       	ldi	r30, 0x31	; 49
     722:	f0 e0       	ldi	r31, 0x00	; 0
     724:	80 81       	ld	r24, Z
     726:	48 2f       	mov	r20, r24
     728:	89 81       	ldd	r24, Y+1	; 0x01
     72a:	28 2f       	mov	r18, r24
     72c:	30 e0       	ldi	r19, 0x00	; 0
     72e:	81 e0       	ldi	r24, 0x01	; 1
     730:	90 e0       	ldi	r25, 0x00	; 0
     732:	02 2e       	mov	r0, r18
     734:	02 c0       	rjmp	.+4      	; 0x73a <MDIO_SetPinDirection+0x1a4>
     736:	88 0f       	add	r24, r24
     738:	99 1f       	adc	r25, r25
     73a:	0a 94       	dec	r0
     73c:	e2 f7       	brpl	.-8      	; 0x736 <MDIO_SetPinDirection+0x1a0>
     73e:	84 2b       	or	r24, r20
     740:	8c 93       	st	X, r24
     742:	17 c0       	rjmp	.+46     	; 0x772 <MDIO_SetPinDirection+0x1dc>
			}
			else if(Copy_u8PinDirection==PIN_INPUT)
     744:	8b 81       	ldd	r24, Y+3	; 0x03
     746:	88 23       	and	r24, r24
     748:	a1 f4       	brne	.+40     	; 0x772 <MDIO_SetPinDirection+0x1dc>
			{
				CLR_BIT(DDRD,Copy_u8PinNumber);
     74a:	a1 e3       	ldi	r26, 0x31	; 49
     74c:	b0 e0       	ldi	r27, 0x00	; 0
     74e:	e1 e3       	ldi	r30, 0x31	; 49
     750:	f0 e0       	ldi	r31, 0x00	; 0
     752:	80 81       	ld	r24, Z
     754:	48 2f       	mov	r20, r24
     756:	89 81       	ldd	r24, Y+1	; 0x01
     758:	28 2f       	mov	r18, r24
     75a:	30 e0       	ldi	r19, 0x00	; 0
     75c:	81 e0       	ldi	r24, 0x01	; 1
     75e:	90 e0       	ldi	r25, 0x00	; 0
     760:	02 2e       	mov	r0, r18
     762:	02 c0       	rjmp	.+4      	; 0x768 <MDIO_SetPinDirection+0x1d2>
     764:	88 0f       	add	r24, r24
     766:	99 1f       	adc	r25, r25
     768:	0a 94       	dec	r0
     76a:	e2 f7       	brpl	.-8      	; 0x764 <MDIO_SetPinDirection+0x1ce>
     76c:	80 95       	com	r24
     76e:	84 23       	and	r24, r20
     770:	8c 93       	st	X, r24
	}
	else
	{
		/*Wrong Pin Number*/
	}
}
     772:	0f 90       	pop	r0
     774:	0f 90       	pop	r0
     776:	0f 90       	pop	r0
     778:	0f 90       	pop	r0
     77a:	0f 90       	pop	r0
     77c:	cf 91       	pop	r28
     77e:	df 91       	pop	r29
     780:	08 95       	ret

00000782 <MDIO_SetPortValue>:


void MDIO_SetPortValue(u8 Copy_u8PortNumber, u8 Copy_u8PortValue)
{
     782:	df 93       	push	r29
     784:	cf 93       	push	r28
     786:	00 d0       	rcall	.+0      	; 0x788 <MDIO_SetPortValue+0x6>
     788:	00 d0       	rcall	.+0      	; 0x78a <MDIO_SetPortValue+0x8>
     78a:	cd b7       	in	r28, 0x3d	; 61
     78c:	de b7       	in	r29, 0x3e	; 62
     78e:	89 83       	std	Y+1, r24	; 0x01
     790:	6a 83       	std	Y+2, r22	; 0x02
	if((Copy_u8PortValue==PORT_HIGH)||(Copy_u8PortValue==PORT_LOW))
     792:	8a 81       	ldd	r24, Y+2	; 0x02
     794:	8f 3f       	cpi	r24, 0xFF	; 255
     796:	19 f0       	breq	.+6      	; 0x79e <MDIO_SetPortValue+0x1c>
     798:	8a 81       	ldd	r24, Y+2	; 0x02
     79a:	88 23       	and	r24, r24
     79c:	91 f5       	brne	.+100    	; 0x802 <MDIO_SetPortValue+0x80>
	{
		/*Valid Port Direction given */
		switch(Copy_u8PortNumber)
     79e:	89 81       	ldd	r24, Y+1	; 0x01
     7a0:	28 2f       	mov	r18, r24
     7a2:	30 e0       	ldi	r19, 0x00	; 0
     7a4:	3c 83       	std	Y+4, r19	; 0x04
     7a6:	2b 83       	std	Y+3, r18	; 0x03
     7a8:	8b 81       	ldd	r24, Y+3	; 0x03
     7aa:	9c 81       	ldd	r25, Y+4	; 0x04
     7ac:	81 30       	cpi	r24, 0x01	; 1
     7ae:	91 05       	cpc	r25, r1
     7b0:	d1 f0       	breq	.+52     	; 0x7e6 <MDIO_SetPortValue+0x64>
     7b2:	2b 81       	ldd	r18, Y+3	; 0x03
     7b4:	3c 81       	ldd	r19, Y+4	; 0x04
     7b6:	22 30       	cpi	r18, 0x02	; 2
     7b8:	31 05       	cpc	r19, r1
     7ba:	2c f4       	brge	.+10     	; 0x7c6 <MDIO_SetPortValue+0x44>
     7bc:	8b 81       	ldd	r24, Y+3	; 0x03
     7be:	9c 81       	ldd	r25, Y+4	; 0x04
     7c0:	00 97       	sbiw	r24, 0x00	; 0
     7c2:	61 f0       	breq	.+24     	; 0x7dc <MDIO_SetPortValue+0x5a>
     7c4:	1e c0       	rjmp	.+60     	; 0x802 <MDIO_SetPortValue+0x80>
     7c6:	2b 81       	ldd	r18, Y+3	; 0x03
     7c8:	3c 81       	ldd	r19, Y+4	; 0x04
     7ca:	22 30       	cpi	r18, 0x02	; 2
     7cc:	31 05       	cpc	r19, r1
     7ce:	81 f0       	breq	.+32     	; 0x7f0 <MDIO_SetPortValue+0x6e>
     7d0:	8b 81       	ldd	r24, Y+3	; 0x03
     7d2:	9c 81       	ldd	r25, Y+4	; 0x04
     7d4:	83 30       	cpi	r24, 0x03	; 3
     7d6:	91 05       	cpc	r25, r1
     7d8:	81 f0       	breq	.+32     	; 0x7fa <MDIO_SetPortValue+0x78>
     7da:	13 c0       	rjmp	.+38     	; 0x802 <MDIO_SetPortValue+0x80>
		{
		case MDIO_PORTA:
			PORTA=Copy_u8PortValue;
     7dc:	eb e3       	ldi	r30, 0x3B	; 59
     7de:	f0 e0       	ldi	r31, 0x00	; 0
     7e0:	8a 81       	ldd	r24, Y+2	; 0x02
     7e2:	80 83       	st	Z, r24
     7e4:	0e c0       	rjmp	.+28     	; 0x802 <MDIO_SetPortValue+0x80>
			break;
		case MDIO_PORTB:
			PORTB=Copy_u8PortValue;
     7e6:	e8 e3       	ldi	r30, 0x38	; 56
     7e8:	f0 e0       	ldi	r31, 0x00	; 0
     7ea:	8a 81       	ldd	r24, Y+2	; 0x02
     7ec:	80 83       	st	Z, r24
     7ee:	09 c0       	rjmp	.+18     	; 0x802 <MDIO_SetPortValue+0x80>
			break;
		case MDIO_PORTC:
			PORTC=Copy_u8PortValue;
     7f0:	e5 e3       	ldi	r30, 0x35	; 53
     7f2:	f0 e0       	ldi	r31, 0x00	; 0
     7f4:	8a 81       	ldd	r24, Y+2	; 0x02
     7f6:	80 83       	st	Z, r24
     7f8:	04 c0       	rjmp	.+8      	; 0x802 <MDIO_SetPortValue+0x80>
			break;
		case MDIO_PORTD:
			PORTD=Copy_u8PortValue;
     7fa:	e2 e3       	ldi	r30, 0x32	; 50
     7fc:	f0 e0       	ldi	r31, 0x00	; 0
     7fe:	8a 81       	ldd	r24, Y+2	; 0x02
     800:	80 83       	st	Z, r24
	}
	else
	{
		/*Invalid Port Value given */
	}
}
     802:	0f 90       	pop	r0
     804:	0f 90       	pop	r0
     806:	0f 90       	pop	r0
     808:	0f 90       	pop	r0
     80a:	cf 91       	pop	r28
     80c:	df 91       	pop	r29
     80e:	08 95       	ret

00000810 <MDIO_SetPinValue>:

void MDIO_SetPinValue(u8 Copy_u8PinNumber,u8 Copy_u8PortNumber, u8 Copy_u8PinValue)
{
     810:	df 93       	push	r29
     812:	cf 93       	push	r28
     814:	00 d0       	rcall	.+0      	; 0x816 <MDIO_SetPinValue+0x6>
     816:	00 d0       	rcall	.+0      	; 0x818 <MDIO_SetPinValue+0x8>
     818:	0f 92       	push	r0
     81a:	cd b7       	in	r28, 0x3d	; 61
     81c:	de b7       	in	r29, 0x3e	; 62
     81e:	89 83       	std	Y+1, r24	; 0x01
     820:	6a 83       	std	Y+2, r22	; 0x02
     822:	4b 83       	std	Y+3, r20	; 0x03
	if((Copy_u8PinNumber>=0)&&(Copy_u8PinNumber<8))
     824:	89 81       	ldd	r24, Y+1	; 0x01
     826:	88 30       	cpi	r24, 0x08	; 8
     828:	08 f0       	brcs	.+2      	; 0x82c <MDIO_SetPinValue+0x1c>
     82a:	e0 c0       	rjmp	.+448    	; 0x9ec <__stack+0x18d>
	{
		switch(Copy_u8PortNumber)
     82c:	8a 81       	ldd	r24, Y+2	; 0x02
     82e:	28 2f       	mov	r18, r24
     830:	30 e0       	ldi	r19, 0x00	; 0
     832:	3d 83       	std	Y+5, r19	; 0x05
     834:	2c 83       	std	Y+4, r18	; 0x04
     836:	8c 81       	ldd	r24, Y+4	; 0x04
     838:	9d 81       	ldd	r25, Y+5	; 0x05
     83a:	81 30       	cpi	r24, 0x01	; 1
     83c:	91 05       	cpc	r25, r1
     83e:	09 f4       	brne	.+2      	; 0x842 <MDIO_SetPinValue+0x32>
     840:	47 c0       	rjmp	.+142    	; 0x8d0 <__stack+0x71>
     842:	2c 81       	ldd	r18, Y+4	; 0x04
     844:	3d 81       	ldd	r19, Y+5	; 0x05
     846:	22 30       	cpi	r18, 0x02	; 2
     848:	31 05       	cpc	r19, r1
     84a:	2c f4       	brge	.+10     	; 0x856 <MDIO_SetPinValue+0x46>
     84c:	8c 81       	ldd	r24, Y+4	; 0x04
     84e:	9d 81       	ldd	r25, Y+5	; 0x05
     850:	00 97       	sbiw	r24, 0x00	; 0
     852:	71 f0       	breq	.+28     	; 0x870 <__stack+0x11>
     854:	cb c0       	rjmp	.+406    	; 0x9ec <__stack+0x18d>
     856:	2c 81       	ldd	r18, Y+4	; 0x04
     858:	3d 81       	ldd	r19, Y+5	; 0x05
     85a:	22 30       	cpi	r18, 0x02	; 2
     85c:	31 05       	cpc	r19, r1
     85e:	09 f4       	brne	.+2      	; 0x862 <__stack+0x3>
     860:	67 c0       	rjmp	.+206    	; 0x930 <__stack+0xd1>
     862:	8c 81       	ldd	r24, Y+4	; 0x04
     864:	9d 81       	ldd	r25, Y+5	; 0x05
     866:	83 30       	cpi	r24, 0x03	; 3
     868:	91 05       	cpc	r25, r1
     86a:	09 f4       	brne	.+2      	; 0x86e <__stack+0xf>
     86c:	91 c0       	rjmp	.+290    	; 0x990 <__stack+0x131>
     86e:	be c0       	rjmp	.+380    	; 0x9ec <__stack+0x18d>
		{
		case MDIO_PORTA:
			if(Copy_u8PinValue==PIN_HIGH)
     870:	8b 81       	ldd	r24, Y+3	; 0x03
     872:	81 30       	cpi	r24, 0x01	; 1
     874:	a1 f4       	brne	.+40     	; 0x89e <__stack+0x3f>
			{
				SET_BIT(PORTA,Copy_u8PinNumber);
     876:	ab e3       	ldi	r26, 0x3B	; 59
     878:	b0 e0       	ldi	r27, 0x00	; 0
     87a:	eb e3       	ldi	r30, 0x3B	; 59
     87c:	f0 e0       	ldi	r31, 0x00	; 0
     87e:	80 81       	ld	r24, Z
     880:	48 2f       	mov	r20, r24
     882:	89 81       	ldd	r24, Y+1	; 0x01
     884:	28 2f       	mov	r18, r24
     886:	30 e0       	ldi	r19, 0x00	; 0
     888:	81 e0       	ldi	r24, 0x01	; 1
     88a:	90 e0       	ldi	r25, 0x00	; 0
     88c:	02 2e       	mov	r0, r18
     88e:	02 c0       	rjmp	.+4      	; 0x894 <__stack+0x35>
     890:	88 0f       	add	r24, r24
     892:	99 1f       	adc	r25, r25
     894:	0a 94       	dec	r0
     896:	e2 f7       	brpl	.-8      	; 0x890 <__stack+0x31>
     898:	84 2b       	or	r24, r20
     89a:	8c 93       	st	X, r24
     89c:	a7 c0       	rjmp	.+334    	; 0x9ec <__stack+0x18d>
			}
			else if(Copy_u8PinValue==PIN_LOW)
     89e:	8b 81       	ldd	r24, Y+3	; 0x03
     8a0:	88 23       	and	r24, r24
     8a2:	09 f0       	breq	.+2      	; 0x8a6 <__stack+0x47>
     8a4:	a3 c0       	rjmp	.+326    	; 0x9ec <__stack+0x18d>
			{
				CLR_BIT(PORTA,Copy_u8PinNumber);
     8a6:	ab e3       	ldi	r26, 0x3B	; 59
     8a8:	b0 e0       	ldi	r27, 0x00	; 0
     8aa:	eb e3       	ldi	r30, 0x3B	; 59
     8ac:	f0 e0       	ldi	r31, 0x00	; 0
     8ae:	80 81       	ld	r24, Z
     8b0:	48 2f       	mov	r20, r24
     8b2:	89 81       	ldd	r24, Y+1	; 0x01
     8b4:	28 2f       	mov	r18, r24
     8b6:	30 e0       	ldi	r19, 0x00	; 0
     8b8:	81 e0       	ldi	r24, 0x01	; 1
     8ba:	90 e0       	ldi	r25, 0x00	; 0
     8bc:	02 2e       	mov	r0, r18
     8be:	02 c0       	rjmp	.+4      	; 0x8c4 <__stack+0x65>
     8c0:	88 0f       	add	r24, r24
     8c2:	99 1f       	adc	r25, r25
     8c4:	0a 94       	dec	r0
     8c6:	e2 f7       	brpl	.-8      	; 0x8c0 <__stack+0x61>
     8c8:	80 95       	com	r24
     8ca:	84 23       	and	r24, r20
     8cc:	8c 93       	st	X, r24
     8ce:	8e c0       	rjmp	.+284    	; 0x9ec <__stack+0x18d>
			{
				//Invalid Pin Value
			}
			break;
		case MDIO_PORTB:
			if(Copy_u8PinValue==PIN_HIGH)
     8d0:	8b 81       	ldd	r24, Y+3	; 0x03
     8d2:	81 30       	cpi	r24, 0x01	; 1
     8d4:	a1 f4       	brne	.+40     	; 0x8fe <__stack+0x9f>
			{
				SET_BIT(PORTB,Copy_u8PinNumber);
     8d6:	a8 e3       	ldi	r26, 0x38	; 56
     8d8:	b0 e0       	ldi	r27, 0x00	; 0
     8da:	e8 e3       	ldi	r30, 0x38	; 56
     8dc:	f0 e0       	ldi	r31, 0x00	; 0
     8de:	80 81       	ld	r24, Z
     8e0:	48 2f       	mov	r20, r24
     8e2:	89 81       	ldd	r24, Y+1	; 0x01
     8e4:	28 2f       	mov	r18, r24
     8e6:	30 e0       	ldi	r19, 0x00	; 0
     8e8:	81 e0       	ldi	r24, 0x01	; 1
     8ea:	90 e0       	ldi	r25, 0x00	; 0
     8ec:	02 2e       	mov	r0, r18
     8ee:	02 c0       	rjmp	.+4      	; 0x8f4 <__stack+0x95>
     8f0:	88 0f       	add	r24, r24
     8f2:	99 1f       	adc	r25, r25
     8f4:	0a 94       	dec	r0
     8f6:	e2 f7       	brpl	.-8      	; 0x8f0 <__stack+0x91>
     8f8:	84 2b       	or	r24, r20
     8fa:	8c 93       	st	X, r24
     8fc:	77 c0       	rjmp	.+238    	; 0x9ec <__stack+0x18d>
			}
			else if(Copy_u8PinValue==PIN_INPUT)
     8fe:	8b 81       	ldd	r24, Y+3	; 0x03
     900:	88 23       	and	r24, r24
     902:	09 f0       	breq	.+2      	; 0x906 <__stack+0xa7>
     904:	73 c0       	rjmp	.+230    	; 0x9ec <__stack+0x18d>
			{
				CLR_BIT(PORTB,Copy_u8PinNumber);
     906:	a8 e3       	ldi	r26, 0x38	; 56
     908:	b0 e0       	ldi	r27, 0x00	; 0
     90a:	e8 e3       	ldi	r30, 0x38	; 56
     90c:	f0 e0       	ldi	r31, 0x00	; 0
     90e:	80 81       	ld	r24, Z
     910:	48 2f       	mov	r20, r24
     912:	89 81       	ldd	r24, Y+1	; 0x01
     914:	28 2f       	mov	r18, r24
     916:	30 e0       	ldi	r19, 0x00	; 0
     918:	81 e0       	ldi	r24, 0x01	; 1
     91a:	90 e0       	ldi	r25, 0x00	; 0
     91c:	02 2e       	mov	r0, r18
     91e:	02 c0       	rjmp	.+4      	; 0x924 <__stack+0xc5>
     920:	88 0f       	add	r24, r24
     922:	99 1f       	adc	r25, r25
     924:	0a 94       	dec	r0
     926:	e2 f7       	brpl	.-8      	; 0x920 <__stack+0xc1>
     928:	80 95       	com	r24
     92a:	84 23       	and	r24, r20
     92c:	8c 93       	st	X, r24
     92e:	5e c0       	rjmp	.+188    	; 0x9ec <__stack+0x18d>
			{
				//Invalid Pin Value
			}
			break;
		case MDIO_PORTC:
			if(Copy_u8PinValue==PIN_OUTPUT)
     930:	8b 81       	ldd	r24, Y+3	; 0x03
     932:	81 30       	cpi	r24, 0x01	; 1
     934:	a1 f4       	brne	.+40     	; 0x95e <__stack+0xff>
			{
				SET_BIT(PORTC,Copy_u8PinNumber);
     936:	a5 e3       	ldi	r26, 0x35	; 53
     938:	b0 e0       	ldi	r27, 0x00	; 0
     93a:	e5 e3       	ldi	r30, 0x35	; 53
     93c:	f0 e0       	ldi	r31, 0x00	; 0
     93e:	80 81       	ld	r24, Z
     940:	48 2f       	mov	r20, r24
     942:	89 81       	ldd	r24, Y+1	; 0x01
     944:	28 2f       	mov	r18, r24
     946:	30 e0       	ldi	r19, 0x00	; 0
     948:	81 e0       	ldi	r24, 0x01	; 1
     94a:	90 e0       	ldi	r25, 0x00	; 0
     94c:	02 2e       	mov	r0, r18
     94e:	02 c0       	rjmp	.+4      	; 0x954 <__stack+0xf5>
     950:	88 0f       	add	r24, r24
     952:	99 1f       	adc	r25, r25
     954:	0a 94       	dec	r0
     956:	e2 f7       	brpl	.-8      	; 0x950 <__stack+0xf1>
     958:	84 2b       	or	r24, r20
     95a:	8c 93       	st	X, r24
     95c:	47 c0       	rjmp	.+142    	; 0x9ec <__stack+0x18d>
			}
			else if(Copy_u8PinValue==PIN_INPUT)
     95e:	8b 81       	ldd	r24, Y+3	; 0x03
     960:	88 23       	and	r24, r24
     962:	09 f0       	breq	.+2      	; 0x966 <__stack+0x107>
     964:	43 c0       	rjmp	.+134    	; 0x9ec <__stack+0x18d>
			{
				CLR_BIT(PORTC,Copy_u8PinNumber);
     966:	a5 e3       	ldi	r26, 0x35	; 53
     968:	b0 e0       	ldi	r27, 0x00	; 0
     96a:	e5 e3       	ldi	r30, 0x35	; 53
     96c:	f0 e0       	ldi	r31, 0x00	; 0
     96e:	80 81       	ld	r24, Z
     970:	48 2f       	mov	r20, r24
     972:	89 81       	ldd	r24, Y+1	; 0x01
     974:	28 2f       	mov	r18, r24
     976:	30 e0       	ldi	r19, 0x00	; 0
     978:	81 e0       	ldi	r24, 0x01	; 1
     97a:	90 e0       	ldi	r25, 0x00	; 0
     97c:	02 2e       	mov	r0, r18
     97e:	02 c0       	rjmp	.+4      	; 0x984 <__stack+0x125>
     980:	88 0f       	add	r24, r24
     982:	99 1f       	adc	r25, r25
     984:	0a 94       	dec	r0
     986:	e2 f7       	brpl	.-8      	; 0x980 <__stack+0x121>
     988:	80 95       	com	r24
     98a:	84 23       	and	r24, r20
     98c:	8c 93       	st	X, r24
     98e:	2e c0       	rjmp	.+92     	; 0x9ec <__stack+0x18d>
			{
				//Invalid Pin Value
			}
			break;
		case MDIO_PORTD:
			if(Copy_u8PinValue==PIN_OUTPUT)
     990:	8b 81       	ldd	r24, Y+3	; 0x03
     992:	81 30       	cpi	r24, 0x01	; 1
     994:	a1 f4       	brne	.+40     	; 0x9be <__stack+0x15f>
			{
				SET_BIT(PORTD,Copy_u8PinNumber);
     996:	a2 e3       	ldi	r26, 0x32	; 50
     998:	b0 e0       	ldi	r27, 0x00	; 0
     99a:	e2 e3       	ldi	r30, 0x32	; 50
     99c:	f0 e0       	ldi	r31, 0x00	; 0
     99e:	80 81       	ld	r24, Z
     9a0:	48 2f       	mov	r20, r24
     9a2:	89 81       	ldd	r24, Y+1	; 0x01
     9a4:	28 2f       	mov	r18, r24
     9a6:	30 e0       	ldi	r19, 0x00	; 0
     9a8:	81 e0       	ldi	r24, 0x01	; 1
     9aa:	90 e0       	ldi	r25, 0x00	; 0
     9ac:	02 2e       	mov	r0, r18
     9ae:	02 c0       	rjmp	.+4      	; 0x9b4 <__stack+0x155>
     9b0:	88 0f       	add	r24, r24
     9b2:	99 1f       	adc	r25, r25
     9b4:	0a 94       	dec	r0
     9b6:	e2 f7       	brpl	.-8      	; 0x9b0 <__stack+0x151>
     9b8:	84 2b       	or	r24, r20
     9ba:	8c 93       	st	X, r24
     9bc:	17 c0       	rjmp	.+46     	; 0x9ec <__stack+0x18d>
			}
			else if(Copy_u8PinValue==PIN_INPUT)
     9be:	8b 81       	ldd	r24, Y+3	; 0x03
     9c0:	88 23       	and	r24, r24
     9c2:	a1 f4       	brne	.+40     	; 0x9ec <__stack+0x18d>
			{
				CLR_BIT(PORTD,Copy_u8PinNumber);
     9c4:	a2 e3       	ldi	r26, 0x32	; 50
     9c6:	b0 e0       	ldi	r27, 0x00	; 0
     9c8:	e2 e3       	ldi	r30, 0x32	; 50
     9ca:	f0 e0       	ldi	r31, 0x00	; 0
     9cc:	80 81       	ld	r24, Z
     9ce:	48 2f       	mov	r20, r24
     9d0:	89 81       	ldd	r24, Y+1	; 0x01
     9d2:	28 2f       	mov	r18, r24
     9d4:	30 e0       	ldi	r19, 0x00	; 0
     9d6:	81 e0       	ldi	r24, 0x01	; 1
     9d8:	90 e0       	ldi	r25, 0x00	; 0
     9da:	02 2e       	mov	r0, r18
     9dc:	02 c0       	rjmp	.+4      	; 0x9e2 <__stack+0x183>
     9de:	88 0f       	add	r24, r24
     9e0:	99 1f       	adc	r25, r25
     9e2:	0a 94       	dec	r0
     9e4:	e2 f7       	brpl	.-8      	; 0x9de <__stack+0x17f>
     9e6:	80 95       	com	r24
     9e8:	84 23       	and	r24, r20
     9ea:	8c 93       	st	X, r24
	}
	else
	{
		/*Wrong Pin Number*/
	}
}
     9ec:	0f 90       	pop	r0
     9ee:	0f 90       	pop	r0
     9f0:	0f 90       	pop	r0
     9f2:	0f 90       	pop	r0
     9f4:	0f 90       	pop	r0
     9f6:	cf 91       	pop	r28
     9f8:	df 91       	pop	r29
     9fa:	08 95       	ret

000009fc <MDIO_ReadPort>:

void MDIO_ReadPort(u8 Copy_u8PortNumber, u8 * P_u8PortReading)
{
     9fc:	df 93       	push	r29
     9fe:	cf 93       	push	r28
     a00:	00 d0       	rcall	.+0      	; 0xa02 <MDIO_ReadPort+0x6>
     a02:	00 d0       	rcall	.+0      	; 0xa04 <MDIO_ReadPort+0x8>
     a04:	0f 92       	push	r0
     a06:	cd b7       	in	r28, 0x3d	; 61
     a08:	de b7       	in	r29, 0x3e	; 62
     a0a:	89 83       	std	Y+1, r24	; 0x01
     a0c:	7b 83       	std	Y+3, r23	; 0x03
     a0e:	6a 83       	std	Y+2, r22	; 0x02
	if(P_u8PortReading!=NULL)
     a10:	8a 81       	ldd	r24, Y+2	; 0x02
     a12:	9b 81       	ldd	r25, Y+3	; 0x03
     a14:	00 97       	sbiw	r24, 0x00	; 0
     a16:	d1 f1       	breq	.+116    	; 0xa8c <MDIO_ReadPort+0x90>
	{
		switch(Copy_u8PortNumber)
     a18:	89 81       	ldd	r24, Y+1	; 0x01
     a1a:	28 2f       	mov	r18, r24
     a1c:	30 e0       	ldi	r19, 0x00	; 0
     a1e:	3d 83       	std	Y+5, r19	; 0x05
     a20:	2c 83       	std	Y+4, r18	; 0x04
     a22:	8c 81       	ldd	r24, Y+4	; 0x04
     a24:	9d 81       	ldd	r25, Y+5	; 0x05
     a26:	81 30       	cpi	r24, 0x01	; 1
     a28:	91 05       	cpc	r25, r1
     a2a:	e1 f0       	breq	.+56     	; 0xa64 <MDIO_ReadPort+0x68>
     a2c:	2c 81       	ldd	r18, Y+4	; 0x04
     a2e:	3d 81       	ldd	r19, Y+5	; 0x05
     a30:	22 30       	cpi	r18, 0x02	; 2
     a32:	31 05       	cpc	r19, r1
     a34:	2c f4       	brge	.+10     	; 0xa40 <MDIO_ReadPort+0x44>
     a36:	8c 81       	ldd	r24, Y+4	; 0x04
     a38:	9d 81       	ldd	r25, Y+5	; 0x05
     a3a:	00 97       	sbiw	r24, 0x00	; 0
     a3c:	61 f0       	breq	.+24     	; 0xa56 <MDIO_ReadPort+0x5a>
     a3e:	26 c0       	rjmp	.+76     	; 0xa8c <MDIO_ReadPort+0x90>
     a40:	2c 81       	ldd	r18, Y+4	; 0x04
     a42:	3d 81       	ldd	r19, Y+5	; 0x05
     a44:	22 30       	cpi	r18, 0x02	; 2
     a46:	31 05       	cpc	r19, r1
     a48:	a1 f0       	breq	.+40     	; 0xa72 <MDIO_ReadPort+0x76>
     a4a:	8c 81       	ldd	r24, Y+4	; 0x04
     a4c:	9d 81       	ldd	r25, Y+5	; 0x05
     a4e:	83 30       	cpi	r24, 0x03	; 3
     a50:	91 05       	cpc	r25, r1
     a52:	b1 f0       	breq	.+44     	; 0xa80 <MDIO_ReadPort+0x84>
     a54:	1b c0       	rjmp	.+54     	; 0xa8c <MDIO_ReadPort+0x90>
		{
		case MDIO_PORTA:
			*P_u8PortReading=PINA;
     a56:	e9 e3       	ldi	r30, 0x39	; 57
     a58:	f0 e0       	ldi	r31, 0x00	; 0
     a5a:	80 81       	ld	r24, Z
     a5c:	ea 81       	ldd	r30, Y+2	; 0x02
     a5e:	fb 81       	ldd	r31, Y+3	; 0x03
     a60:	80 83       	st	Z, r24
     a62:	14 c0       	rjmp	.+40     	; 0xa8c <MDIO_ReadPort+0x90>
			break;
		case MDIO_PORTB:
			*P_u8PortReading=PINB;
     a64:	e6 e3       	ldi	r30, 0x36	; 54
     a66:	f0 e0       	ldi	r31, 0x00	; 0
     a68:	80 81       	ld	r24, Z
     a6a:	ea 81       	ldd	r30, Y+2	; 0x02
     a6c:	fb 81       	ldd	r31, Y+3	; 0x03
     a6e:	80 83       	st	Z, r24
     a70:	0d c0       	rjmp	.+26     	; 0xa8c <MDIO_ReadPort+0x90>
			break;
		case MDIO_PORTC:
			*P_u8PortReading=PINC;
     a72:	e3 e3       	ldi	r30, 0x33	; 51
     a74:	f0 e0       	ldi	r31, 0x00	; 0
     a76:	80 81       	ld	r24, Z
     a78:	ea 81       	ldd	r30, Y+2	; 0x02
     a7a:	fb 81       	ldd	r31, Y+3	; 0x03
     a7c:	80 83       	st	Z, r24
     a7e:	06 c0       	rjmp	.+12     	; 0xa8c <MDIO_ReadPort+0x90>
			break;
		case MDIO_PORTD:
			*P_u8PortReading=PIND;
     a80:	e0 e3       	ldi	r30, 0x30	; 48
     a82:	f0 e0       	ldi	r31, 0x00	; 0
     a84:	80 81       	ld	r24, Z
     a86:	ea 81       	ldd	r30, Y+2	; 0x02
     a88:	fb 81       	ldd	r31, Y+3	; 0x03
     a8a:	80 83       	st	Z, r24
	}
	else
	{
		//Null Pointer
	}
}
     a8c:	0f 90       	pop	r0
     a8e:	0f 90       	pop	r0
     a90:	0f 90       	pop	r0
     a92:	0f 90       	pop	r0
     a94:	0f 90       	pop	r0
     a96:	cf 91       	pop	r28
     a98:	df 91       	pop	r29
     a9a:	08 95       	ret

00000a9c <MDIO_ReadPin>:


void MDIO_ReadPin(u8 Copy_u8PinNumber,u8 Copy_u8PortNumber, u8 * P_u8PortReading)
{
     a9c:	df 93       	push	r29
     a9e:	cf 93       	push	r28
     aa0:	00 d0       	rcall	.+0      	; 0xaa2 <MDIO_ReadPin+0x6>
     aa2:	00 d0       	rcall	.+0      	; 0xaa4 <MDIO_ReadPin+0x8>
     aa4:	00 d0       	rcall	.+0      	; 0xaa6 <MDIO_ReadPin+0xa>
     aa6:	cd b7       	in	r28, 0x3d	; 61
     aa8:	de b7       	in	r29, 0x3e	; 62
     aaa:	89 83       	std	Y+1, r24	; 0x01
     aac:	6a 83       	std	Y+2, r22	; 0x02
     aae:	5c 83       	std	Y+4, r21	; 0x04
     ab0:	4b 83       	std	Y+3, r20	; 0x03
	if((Copy_u8PinNumber>=0)&&(Copy_u8PinNumber<8))
     ab2:	89 81       	ldd	r24, Y+1	; 0x01
     ab4:	88 30       	cpi	r24, 0x08	; 8
     ab6:	08 f0       	brcs	.+2      	; 0xaba <MDIO_ReadPin+0x1e>
     ab8:	70 c0       	rjmp	.+224    	; 0xb9a <MDIO_ReadPin+0xfe>
	{
		switch(Copy_u8PortNumber)
     aba:	8a 81       	ldd	r24, Y+2	; 0x02
     abc:	28 2f       	mov	r18, r24
     abe:	30 e0       	ldi	r19, 0x00	; 0
     ac0:	3e 83       	std	Y+6, r19	; 0x06
     ac2:	2d 83       	std	Y+5, r18	; 0x05
     ac4:	4d 81       	ldd	r20, Y+5	; 0x05
     ac6:	5e 81       	ldd	r21, Y+6	; 0x06
     ac8:	41 30       	cpi	r20, 0x01	; 1
     aca:	51 05       	cpc	r21, r1
     acc:	59 f1       	breq	.+86     	; 0xb24 <MDIO_ReadPin+0x88>
     ace:	8d 81       	ldd	r24, Y+5	; 0x05
     ad0:	9e 81       	ldd	r25, Y+6	; 0x06
     ad2:	82 30       	cpi	r24, 0x02	; 2
     ad4:	91 05       	cpc	r25, r1
     ad6:	34 f4       	brge	.+12     	; 0xae4 <MDIO_ReadPin+0x48>
     ad8:	2d 81       	ldd	r18, Y+5	; 0x05
     ada:	3e 81       	ldd	r19, Y+6	; 0x06
     adc:	21 15       	cp	r18, r1
     ade:	31 05       	cpc	r19, r1
     ae0:	69 f0       	breq	.+26     	; 0xafc <MDIO_ReadPin+0x60>
     ae2:	5b c0       	rjmp	.+182    	; 0xb9a <MDIO_ReadPin+0xfe>
     ae4:	4d 81       	ldd	r20, Y+5	; 0x05
     ae6:	5e 81       	ldd	r21, Y+6	; 0x06
     ae8:	42 30       	cpi	r20, 0x02	; 2
     aea:	51 05       	cpc	r21, r1
     aec:	79 f1       	breq	.+94     	; 0xb4c <MDIO_ReadPin+0xb0>
     aee:	8d 81       	ldd	r24, Y+5	; 0x05
     af0:	9e 81       	ldd	r25, Y+6	; 0x06
     af2:	83 30       	cpi	r24, 0x03	; 3
     af4:	91 05       	cpc	r25, r1
     af6:	09 f4       	brne	.+2      	; 0xafa <MDIO_ReadPin+0x5e>
     af8:	3d c0       	rjmp	.+122    	; 0xb74 <MDIO_ReadPin+0xd8>
     afa:	4f c0       	rjmp	.+158    	; 0xb9a <MDIO_ReadPin+0xfe>
		{
		case MDIO_PORTA:
			*P_u8PortReading=GET_BIT(PINA,Copy_u8PinNumber);
     afc:	e9 e3       	ldi	r30, 0x39	; 57
     afe:	f0 e0       	ldi	r31, 0x00	; 0
     b00:	80 81       	ld	r24, Z
     b02:	28 2f       	mov	r18, r24
     b04:	30 e0       	ldi	r19, 0x00	; 0
     b06:	89 81       	ldd	r24, Y+1	; 0x01
     b08:	88 2f       	mov	r24, r24
     b0a:	90 e0       	ldi	r25, 0x00	; 0
     b0c:	a9 01       	movw	r20, r18
     b0e:	02 c0       	rjmp	.+4      	; 0xb14 <MDIO_ReadPin+0x78>
     b10:	55 95       	asr	r21
     b12:	47 95       	ror	r20
     b14:	8a 95       	dec	r24
     b16:	e2 f7       	brpl	.-8      	; 0xb10 <MDIO_ReadPin+0x74>
     b18:	ca 01       	movw	r24, r20
     b1a:	81 70       	andi	r24, 0x01	; 1
     b1c:	eb 81       	ldd	r30, Y+3	; 0x03
     b1e:	fc 81       	ldd	r31, Y+4	; 0x04
     b20:	80 83       	st	Z, r24
     b22:	3b c0       	rjmp	.+118    	; 0xb9a <MDIO_ReadPin+0xfe>
			break;
		case MDIO_PORTB:
			*P_u8PortReading=GET_BIT(PINB,Copy_u8PinNumber);
     b24:	e6 e3       	ldi	r30, 0x36	; 54
     b26:	f0 e0       	ldi	r31, 0x00	; 0
     b28:	80 81       	ld	r24, Z
     b2a:	28 2f       	mov	r18, r24
     b2c:	30 e0       	ldi	r19, 0x00	; 0
     b2e:	89 81       	ldd	r24, Y+1	; 0x01
     b30:	88 2f       	mov	r24, r24
     b32:	90 e0       	ldi	r25, 0x00	; 0
     b34:	a9 01       	movw	r20, r18
     b36:	02 c0       	rjmp	.+4      	; 0xb3c <MDIO_ReadPin+0xa0>
     b38:	55 95       	asr	r21
     b3a:	47 95       	ror	r20
     b3c:	8a 95       	dec	r24
     b3e:	e2 f7       	brpl	.-8      	; 0xb38 <MDIO_ReadPin+0x9c>
     b40:	ca 01       	movw	r24, r20
     b42:	81 70       	andi	r24, 0x01	; 1
     b44:	eb 81       	ldd	r30, Y+3	; 0x03
     b46:	fc 81       	ldd	r31, Y+4	; 0x04
     b48:	80 83       	st	Z, r24
     b4a:	27 c0       	rjmp	.+78     	; 0xb9a <MDIO_ReadPin+0xfe>
			break;
		case MDIO_PORTC:
			*P_u8PortReading=GET_BIT(PINC,Copy_u8PinNumber);
     b4c:	e3 e3       	ldi	r30, 0x33	; 51
     b4e:	f0 e0       	ldi	r31, 0x00	; 0
     b50:	80 81       	ld	r24, Z
     b52:	28 2f       	mov	r18, r24
     b54:	30 e0       	ldi	r19, 0x00	; 0
     b56:	89 81       	ldd	r24, Y+1	; 0x01
     b58:	88 2f       	mov	r24, r24
     b5a:	90 e0       	ldi	r25, 0x00	; 0
     b5c:	a9 01       	movw	r20, r18
     b5e:	02 c0       	rjmp	.+4      	; 0xb64 <MDIO_ReadPin+0xc8>
     b60:	55 95       	asr	r21
     b62:	47 95       	ror	r20
     b64:	8a 95       	dec	r24
     b66:	e2 f7       	brpl	.-8      	; 0xb60 <MDIO_ReadPin+0xc4>
     b68:	ca 01       	movw	r24, r20
     b6a:	81 70       	andi	r24, 0x01	; 1
     b6c:	eb 81       	ldd	r30, Y+3	; 0x03
     b6e:	fc 81       	ldd	r31, Y+4	; 0x04
     b70:	80 83       	st	Z, r24
     b72:	13 c0       	rjmp	.+38     	; 0xb9a <MDIO_ReadPin+0xfe>
			break;
		case MDIO_PORTD:
			*P_u8PortReading=GET_BIT(PIND,Copy_u8PinNumber);
     b74:	e0 e3       	ldi	r30, 0x30	; 48
     b76:	f0 e0       	ldi	r31, 0x00	; 0
     b78:	80 81       	ld	r24, Z
     b7a:	28 2f       	mov	r18, r24
     b7c:	30 e0       	ldi	r19, 0x00	; 0
     b7e:	89 81       	ldd	r24, Y+1	; 0x01
     b80:	88 2f       	mov	r24, r24
     b82:	90 e0       	ldi	r25, 0x00	; 0
     b84:	a9 01       	movw	r20, r18
     b86:	02 c0       	rjmp	.+4      	; 0xb8c <MDIO_ReadPin+0xf0>
     b88:	55 95       	asr	r21
     b8a:	47 95       	ror	r20
     b8c:	8a 95       	dec	r24
     b8e:	e2 f7       	brpl	.-8      	; 0xb88 <MDIO_ReadPin+0xec>
     b90:	ca 01       	movw	r24, r20
     b92:	81 70       	andi	r24, 0x01	; 1
     b94:	eb 81       	ldd	r30, Y+3	; 0x03
     b96:	fc 81       	ldd	r31, Y+4	; 0x04
     b98:	80 83       	st	Z, r24
	}
	else
	{
		/*Wrong Pin Number*/
	}
}
     b9a:	26 96       	adiw	r28, 0x06	; 6
     b9c:	0f b6       	in	r0, 0x3f	; 63
     b9e:	f8 94       	cli
     ba0:	de bf       	out	0x3e, r29	; 62
     ba2:	0f be       	out	0x3f, r0	; 63
     ba4:	cd bf       	out	0x3d, r28	; 61
     ba6:	cf 91       	pop	r28
     ba8:	df 91       	pop	r29
     baa:	08 95       	ret

00000bac <MDIO_TogglePin>:

void MDIO_TogglePin(u8 Copy_u8PinNumber,u8 Copy_u8PortNumber)
{
     bac:	df 93       	push	r29
     bae:	cf 93       	push	r28
     bb0:	00 d0       	rcall	.+0      	; 0xbb2 <MDIO_TogglePin+0x6>
     bb2:	00 d0       	rcall	.+0      	; 0xbb4 <MDIO_TogglePin+0x8>
     bb4:	cd b7       	in	r28, 0x3d	; 61
     bb6:	de b7       	in	r29, 0x3e	; 62
     bb8:	89 83       	std	Y+1, r24	; 0x01
     bba:	6a 83       	std	Y+2, r22	; 0x02
	if((Copy_u8PinNumber>=0)&&(Copy_u8PinNumber<8))
     bbc:	89 81       	ldd	r24, Y+1	; 0x01
     bbe:	88 30       	cpi	r24, 0x08	; 8
     bc0:	08 f0       	brcs	.+2      	; 0xbc4 <MDIO_TogglePin+0x18>
     bc2:	6e c0       	rjmp	.+220    	; 0xca0 <MDIO_TogglePin+0xf4>
	{
		switch(Copy_u8PortNumber)
     bc4:	8a 81       	ldd	r24, Y+2	; 0x02
     bc6:	28 2f       	mov	r18, r24
     bc8:	30 e0       	ldi	r19, 0x00	; 0
     bca:	3c 83       	std	Y+4, r19	; 0x04
     bcc:	2b 83       	std	Y+3, r18	; 0x03
     bce:	8b 81       	ldd	r24, Y+3	; 0x03
     bd0:	9c 81       	ldd	r25, Y+4	; 0x04
     bd2:	81 30       	cpi	r24, 0x01	; 1
     bd4:	91 05       	cpc	r25, r1
     bd6:	49 f1       	breq	.+82     	; 0xc2a <MDIO_TogglePin+0x7e>
     bd8:	2b 81       	ldd	r18, Y+3	; 0x03
     bda:	3c 81       	ldd	r19, Y+4	; 0x04
     bdc:	22 30       	cpi	r18, 0x02	; 2
     bde:	31 05       	cpc	r19, r1
     be0:	2c f4       	brge	.+10     	; 0xbec <MDIO_TogglePin+0x40>
     be2:	8b 81       	ldd	r24, Y+3	; 0x03
     be4:	9c 81       	ldd	r25, Y+4	; 0x04
     be6:	00 97       	sbiw	r24, 0x00	; 0
     be8:	61 f0       	breq	.+24     	; 0xc02 <MDIO_TogglePin+0x56>
     bea:	5a c0       	rjmp	.+180    	; 0xca0 <MDIO_TogglePin+0xf4>
     bec:	2b 81       	ldd	r18, Y+3	; 0x03
     bee:	3c 81       	ldd	r19, Y+4	; 0x04
     bf0:	22 30       	cpi	r18, 0x02	; 2
     bf2:	31 05       	cpc	r19, r1
     bf4:	71 f1       	breq	.+92     	; 0xc52 <MDIO_TogglePin+0xa6>
     bf6:	8b 81       	ldd	r24, Y+3	; 0x03
     bf8:	9c 81       	ldd	r25, Y+4	; 0x04
     bfa:	83 30       	cpi	r24, 0x03	; 3
     bfc:	91 05       	cpc	r25, r1
     bfe:	e9 f1       	breq	.+122    	; 0xc7a <MDIO_TogglePin+0xce>
     c00:	4f c0       	rjmp	.+158    	; 0xca0 <MDIO_TogglePin+0xf4>
		{
		case MDIO_PORTA:
			TOGGLE_BIT(PORTA,Copy_u8PinNumber);
     c02:	ab e3       	ldi	r26, 0x3B	; 59
     c04:	b0 e0       	ldi	r27, 0x00	; 0
     c06:	eb e3       	ldi	r30, 0x3B	; 59
     c08:	f0 e0       	ldi	r31, 0x00	; 0
     c0a:	80 81       	ld	r24, Z
     c0c:	48 2f       	mov	r20, r24
     c0e:	89 81       	ldd	r24, Y+1	; 0x01
     c10:	28 2f       	mov	r18, r24
     c12:	30 e0       	ldi	r19, 0x00	; 0
     c14:	81 e0       	ldi	r24, 0x01	; 1
     c16:	90 e0       	ldi	r25, 0x00	; 0
     c18:	02 2e       	mov	r0, r18
     c1a:	02 c0       	rjmp	.+4      	; 0xc20 <MDIO_TogglePin+0x74>
     c1c:	88 0f       	add	r24, r24
     c1e:	99 1f       	adc	r25, r25
     c20:	0a 94       	dec	r0
     c22:	e2 f7       	brpl	.-8      	; 0xc1c <MDIO_TogglePin+0x70>
     c24:	84 27       	eor	r24, r20
     c26:	8c 93       	st	X, r24
     c28:	3b c0       	rjmp	.+118    	; 0xca0 <MDIO_TogglePin+0xf4>
			break;
		case MDIO_PORTB:
			TOGGLE_BIT(PORTB,Copy_u8PinNumber);
     c2a:	a8 e3       	ldi	r26, 0x38	; 56
     c2c:	b0 e0       	ldi	r27, 0x00	; 0
     c2e:	e8 e3       	ldi	r30, 0x38	; 56
     c30:	f0 e0       	ldi	r31, 0x00	; 0
     c32:	80 81       	ld	r24, Z
     c34:	48 2f       	mov	r20, r24
     c36:	89 81       	ldd	r24, Y+1	; 0x01
     c38:	28 2f       	mov	r18, r24
     c3a:	30 e0       	ldi	r19, 0x00	; 0
     c3c:	81 e0       	ldi	r24, 0x01	; 1
     c3e:	90 e0       	ldi	r25, 0x00	; 0
     c40:	02 2e       	mov	r0, r18
     c42:	02 c0       	rjmp	.+4      	; 0xc48 <MDIO_TogglePin+0x9c>
     c44:	88 0f       	add	r24, r24
     c46:	99 1f       	adc	r25, r25
     c48:	0a 94       	dec	r0
     c4a:	e2 f7       	brpl	.-8      	; 0xc44 <MDIO_TogglePin+0x98>
     c4c:	84 27       	eor	r24, r20
     c4e:	8c 93       	st	X, r24
     c50:	27 c0       	rjmp	.+78     	; 0xca0 <MDIO_TogglePin+0xf4>
			break;
		case MDIO_PORTC:
			TOGGLE_BIT(PORTC,Copy_u8PinNumber);
     c52:	a5 e3       	ldi	r26, 0x35	; 53
     c54:	b0 e0       	ldi	r27, 0x00	; 0
     c56:	e5 e3       	ldi	r30, 0x35	; 53
     c58:	f0 e0       	ldi	r31, 0x00	; 0
     c5a:	80 81       	ld	r24, Z
     c5c:	48 2f       	mov	r20, r24
     c5e:	89 81       	ldd	r24, Y+1	; 0x01
     c60:	28 2f       	mov	r18, r24
     c62:	30 e0       	ldi	r19, 0x00	; 0
     c64:	81 e0       	ldi	r24, 0x01	; 1
     c66:	90 e0       	ldi	r25, 0x00	; 0
     c68:	02 2e       	mov	r0, r18
     c6a:	02 c0       	rjmp	.+4      	; 0xc70 <MDIO_TogglePin+0xc4>
     c6c:	88 0f       	add	r24, r24
     c6e:	99 1f       	adc	r25, r25
     c70:	0a 94       	dec	r0
     c72:	e2 f7       	brpl	.-8      	; 0xc6c <MDIO_TogglePin+0xc0>
     c74:	84 27       	eor	r24, r20
     c76:	8c 93       	st	X, r24
     c78:	13 c0       	rjmp	.+38     	; 0xca0 <MDIO_TogglePin+0xf4>
			break;
		case MDIO_PORTD:
			TOGGLE_BIT(PORTD,Copy_u8PinNumber);
     c7a:	a2 e3       	ldi	r26, 0x32	; 50
     c7c:	b0 e0       	ldi	r27, 0x00	; 0
     c7e:	e2 e3       	ldi	r30, 0x32	; 50
     c80:	f0 e0       	ldi	r31, 0x00	; 0
     c82:	80 81       	ld	r24, Z
     c84:	48 2f       	mov	r20, r24
     c86:	89 81       	ldd	r24, Y+1	; 0x01
     c88:	28 2f       	mov	r18, r24
     c8a:	30 e0       	ldi	r19, 0x00	; 0
     c8c:	81 e0       	ldi	r24, 0x01	; 1
     c8e:	90 e0       	ldi	r25, 0x00	; 0
     c90:	02 2e       	mov	r0, r18
     c92:	02 c0       	rjmp	.+4      	; 0xc98 <MDIO_TogglePin+0xec>
     c94:	88 0f       	add	r24, r24
     c96:	99 1f       	adc	r25, r25
     c98:	0a 94       	dec	r0
     c9a:	e2 f7       	brpl	.-8      	; 0xc94 <MDIO_TogglePin+0xe8>
     c9c:	84 27       	eor	r24, r20
     c9e:	8c 93       	st	X, r24
	}
	else
	{
		/*Wrong Pin Number*/
	}
}
     ca0:	0f 90       	pop	r0
     ca2:	0f 90       	pop	r0
     ca4:	0f 90       	pop	r0
     ca6:	0f 90       	pop	r0
     ca8:	cf 91       	pop	r28
     caa:	df 91       	pop	r29
     cac:	08 95       	ret

00000cae <MDIO_SetNibbleValue>:


void MDIO_SetNibbleValue(u8 Copy_u8PinStart, u8 Copy_u8PortNumber, u8 Copy_u8Value)
{
     cae:	df 93       	push	r29
     cb0:	cf 93       	push	r28
     cb2:	00 d0       	rcall	.+0      	; 0xcb4 <MDIO_SetNibbleValue+0x6>
     cb4:	00 d0       	rcall	.+0      	; 0xcb6 <MDIO_SetNibbleValue+0x8>
     cb6:	00 d0       	rcall	.+0      	; 0xcb8 <MDIO_SetNibbleValue+0xa>
     cb8:	cd b7       	in	r28, 0x3d	; 61
     cba:	de b7       	in	r29, 0x3e	; 62
     cbc:	8a 83       	std	Y+2, r24	; 0x02
     cbe:	6b 83       	std	Y+3, r22	; 0x03
     cc0:	4c 83       	std	Y+4, r20	; 0x04
	u8 Loc_u8Value=Copy_u8Value;
     cc2:	8c 81       	ldd	r24, Y+4	; 0x04
     cc4:	89 83       	std	Y+1, r24	; 0x01

	//Handling of the Value
	Loc_u8Value=((Loc_u8Value&(0x0F))<<Copy_u8PinStart);
     cc6:	89 81       	ldd	r24, Y+1	; 0x01
     cc8:	88 2f       	mov	r24, r24
     cca:	90 e0       	ldi	r25, 0x00	; 0
     ccc:	9c 01       	movw	r18, r24
     cce:	2f 70       	andi	r18, 0x0F	; 15
     cd0:	30 70       	andi	r19, 0x00	; 0
     cd2:	8a 81       	ldd	r24, Y+2	; 0x02
     cd4:	88 2f       	mov	r24, r24
     cd6:	90 e0       	ldi	r25, 0x00	; 0
     cd8:	a9 01       	movw	r20, r18
     cda:	02 c0       	rjmp	.+4      	; 0xce0 <MDIO_SetNibbleValue+0x32>
     cdc:	44 0f       	add	r20, r20
     cde:	55 1f       	adc	r21, r21
     ce0:	8a 95       	dec	r24
     ce2:	e2 f7       	brpl	.-8      	; 0xcdc <MDIO_SetNibbleValue+0x2e>
     ce4:	ca 01       	movw	r24, r20
     ce6:	89 83       	std	Y+1, r24	; 0x01

	if((Copy_u8PinStart<=4)&&(Copy_u8PinStart>=0))
     ce8:	8a 81       	ldd	r24, Y+2	; 0x02
     cea:	85 30       	cpi	r24, 0x05	; 5
     cec:	08 f0       	brcs	.+2      	; 0xcf0 <MDIO_SetNibbleValue+0x42>
     cee:	95 c0       	rjmp	.+298    	; 0xe1a <MDIO_SetNibbleValue+0x16c>
	{
		switch(Copy_u8PortNumber)
     cf0:	8b 81       	ldd	r24, Y+3	; 0x03
     cf2:	28 2f       	mov	r18, r24
     cf4:	30 e0       	ldi	r19, 0x00	; 0
     cf6:	3e 83       	std	Y+6, r19	; 0x06
     cf8:	2d 83       	std	Y+5, r18	; 0x05
     cfa:	4d 81       	ldd	r20, Y+5	; 0x05
     cfc:	5e 81       	ldd	r21, Y+6	; 0x06
     cfe:	41 30       	cpi	r20, 0x01	; 1
     d00:	51 05       	cpc	r21, r1
     d02:	a9 f1       	breq	.+106    	; 0xd6e <MDIO_SetNibbleValue+0xc0>
     d04:	8d 81       	ldd	r24, Y+5	; 0x05
     d06:	9e 81       	ldd	r25, Y+6	; 0x06
     d08:	82 30       	cpi	r24, 0x02	; 2
     d0a:	91 05       	cpc	r25, r1
     d0c:	34 f4       	brge	.+12     	; 0xd1a <MDIO_SetNibbleValue+0x6c>
     d0e:	2d 81       	ldd	r18, Y+5	; 0x05
     d10:	3e 81       	ldd	r19, Y+6	; 0x06
     d12:	21 15       	cp	r18, r1
     d14:	31 05       	cpc	r19, r1
     d16:	71 f0       	breq	.+28     	; 0xd34 <MDIO_SetNibbleValue+0x86>
     d18:	80 c0       	rjmp	.+256    	; 0xe1a <MDIO_SetNibbleValue+0x16c>
     d1a:	4d 81       	ldd	r20, Y+5	; 0x05
     d1c:	5e 81       	ldd	r21, Y+6	; 0x06
     d1e:	42 30       	cpi	r20, 0x02	; 2
     d20:	51 05       	cpc	r21, r1
     d22:	09 f4       	brne	.+2      	; 0xd26 <MDIO_SetNibbleValue+0x78>
     d24:	41 c0       	rjmp	.+130    	; 0xda8 <MDIO_SetNibbleValue+0xfa>
     d26:	8d 81       	ldd	r24, Y+5	; 0x05
     d28:	9e 81       	ldd	r25, Y+6	; 0x06
     d2a:	83 30       	cpi	r24, 0x03	; 3
     d2c:	91 05       	cpc	r25, r1
     d2e:	09 f4       	brne	.+2      	; 0xd32 <MDIO_SetNibbleValue+0x84>
     d30:	58 c0       	rjmp	.+176    	; 0xde2 <MDIO_SetNibbleValue+0x134>
     d32:	73 c0       	rjmp	.+230    	; 0xe1a <MDIO_SetNibbleValue+0x16c>
		{
		case MDIO_PORTA:
			//Mask Port A
			PORTA&=(~(0x0F<<Copy_u8PinStart));
     d34:	ab e3       	ldi	r26, 0x3B	; 59
     d36:	b0 e0       	ldi	r27, 0x00	; 0
     d38:	eb e3       	ldi	r30, 0x3B	; 59
     d3a:	f0 e0       	ldi	r31, 0x00	; 0
     d3c:	80 81       	ld	r24, Z
     d3e:	48 2f       	mov	r20, r24
     d40:	8a 81       	ldd	r24, Y+2	; 0x02
     d42:	28 2f       	mov	r18, r24
     d44:	30 e0       	ldi	r19, 0x00	; 0
     d46:	8f e0       	ldi	r24, 0x0F	; 15
     d48:	90 e0       	ldi	r25, 0x00	; 0
     d4a:	02 2e       	mov	r0, r18
     d4c:	02 c0       	rjmp	.+4      	; 0xd52 <MDIO_SetNibbleValue+0xa4>
     d4e:	88 0f       	add	r24, r24
     d50:	99 1f       	adc	r25, r25
     d52:	0a 94       	dec	r0
     d54:	e2 f7       	brpl	.-8      	; 0xd4e <MDIO_SetNibbleValue+0xa0>
     d56:	80 95       	com	r24
     d58:	84 23       	and	r24, r20
     d5a:	8c 93       	st	X, r24
			PORTA|=Loc_u8Value;
     d5c:	ab e3       	ldi	r26, 0x3B	; 59
     d5e:	b0 e0       	ldi	r27, 0x00	; 0
     d60:	eb e3       	ldi	r30, 0x3B	; 59
     d62:	f0 e0       	ldi	r31, 0x00	; 0
     d64:	90 81       	ld	r25, Z
     d66:	89 81       	ldd	r24, Y+1	; 0x01
     d68:	89 2b       	or	r24, r25
     d6a:	8c 93       	st	X, r24
     d6c:	56 c0       	rjmp	.+172    	; 0xe1a <MDIO_SetNibbleValue+0x16c>

			break;
		case MDIO_PORTB:
			PORTB&=(~((0x0F)<<Copy_u8PinStart));
     d6e:	a8 e3       	ldi	r26, 0x38	; 56
     d70:	b0 e0       	ldi	r27, 0x00	; 0
     d72:	e8 e3       	ldi	r30, 0x38	; 56
     d74:	f0 e0       	ldi	r31, 0x00	; 0
     d76:	80 81       	ld	r24, Z
     d78:	48 2f       	mov	r20, r24
     d7a:	8a 81       	ldd	r24, Y+2	; 0x02
     d7c:	28 2f       	mov	r18, r24
     d7e:	30 e0       	ldi	r19, 0x00	; 0
     d80:	8f e0       	ldi	r24, 0x0F	; 15
     d82:	90 e0       	ldi	r25, 0x00	; 0
     d84:	02 2e       	mov	r0, r18
     d86:	02 c0       	rjmp	.+4      	; 0xd8c <MDIO_SetNibbleValue+0xde>
     d88:	88 0f       	add	r24, r24
     d8a:	99 1f       	adc	r25, r25
     d8c:	0a 94       	dec	r0
     d8e:	e2 f7       	brpl	.-8      	; 0xd88 <MDIO_SetNibbleValue+0xda>
     d90:	80 95       	com	r24
     d92:	84 23       	and	r24, r20
     d94:	8c 93       	st	X, r24
			PORTB|=Loc_u8Value;
     d96:	a8 e3       	ldi	r26, 0x38	; 56
     d98:	b0 e0       	ldi	r27, 0x00	; 0
     d9a:	e8 e3       	ldi	r30, 0x38	; 56
     d9c:	f0 e0       	ldi	r31, 0x00	; 0
     d9e:	90 81       	ld	r25, Z
     da0:	89 81       	ldd	r24, Y+1	; 0x01
     da2:	89 2b       	or	r24, r25
     da4:	8c 93       	st	X, r24
     da6:	39 c0       	rjmp	.+114    	; 0xe1a <MDIO_SetNibbleValue+0x16c>

			break;
		case MDIO_PORTC:
			PORTC&=(~((0x0F)<<Copy_u8PinStart));
     da8:	a5 e3       	ldi	r26, 0x35	; 53
     daa:	b0 e0       	ldi	r27, 0x00	; 0
     dac:	e5 e3       	ldi	r30, 0x35	; 53
     dae:	f0 e0       	ldi	r31, 0x00	; 0
     db0:	80 81       	ld	r24, Z
     db2:	48 2f       	mov	r20, r24
     db4:	8a 81       	ldd	r24, Y+2	; 0x02
     db6:	28 2f       	mov	r18, r24
     db8:	30 e0       	ldi	r19, 0x00	; 0
     dba:	8f e0       	ldi	r24, 0x0F	; 15
     dbc:	90 e0       	ldi	r25, 0x00	; 0
     dbe:	02 2e       	mov	r0, r18
     dc0:	02 c0       	rjmp	.+4      	; 0xdc6 <MDIO_SetNibbleValue+0x118>
     dc2:	88 0f       	add	r24, r24
     dc4:	99 1f       	adc	r25, r25
     dc6:	0a 94       	dec	r0
     dc8:	e2 f7       	brpl	.-8      	; 0xdc2 <MDIO_SetNibbleValue+0x114>
     dca:	80 95       	com	r24
     dcc:	84 23       	and	r24, r20
     dce:	8c 93       	st	X, r24
			PORTC|=Loc_u8Value;
     dd0:	a5 e3       	ldi	r26, 0x35	; 53
     dd2:	b0 e0       	ldi	r27, 0x00	; 0
     dd4:	e5 e3       	ldi	r30, 0x35	; 53
     dd6:	f0 e0       	ldi	r31, 0x00	; 0
     dd8:	90 81       	ld	r25, Z
     dda:	89 81       	ldd	r24, Y+1	; 0x01
     ddc:	89 2b       	or	r24, r25
     dde:	8c 93       	st	X, r24
     de0:	1c c0       	rjmp	.+56     	; 0xe1a <MDIO_SetNibbleValue+0x16c>

			break;
		case MDIO_PORTD:
			PORTD&=(~((0x0F)<<Copy_u8PinStart));
     de2:	a2 e3       	ldi	r26, 0x32	; 50
     de4:	b0 e0       	ldi	r27, 0x00	; 0
     de6:	e2 e3       	ldi	r30, 0x32	; 50
     de8:	f0 e0       	ldi	r31, 0x00	; 0
     dea:	80 81       	ld	r24, Z
     dec:	48 2f       	mov	r20, r24
     dee:	8a 81       	ldd	r24, Y+2	; 0x02
     df0:	28 2f       	mov	r18, r24
     df2:	30 e0       	ldi	r19, 0x00	; 0
     df4:	8f e0       	ldi	r24, 0x0F	; 15
     df6:	90 e0       	ldi	r25, 0x00	; 0
     df8:	02 2e       	mov	r0, r18
     dfa:	02 c0       	rjmp	.+4      	; 0xe00 <MDIO_SetNibbleValue+0x152>
     dfc:	88 0f       	add	r24, r24
     dfe:	99 1f       	adc	r25, r25
     e00:	0a 94       	dec	r0
     e02:	e2 f7       	brpl	.-8      	; 0xdfc <MDIO_SetNibbleValue+0x14e>
     e04:	80 95       	com	r24
     e06:	84 23       	and	r24, r20
     e08:	8c 93       	st	X, r24
			PORTD|=Loc_u8Value;
     e0a:	a2 e3       	ldi	r26, 0x32	; 50
     e0c:	b0 e0       	ldi	r27, 0x00	; 0
     e0e:	e2 e3       	ldi	r30, 0x32	; 50
     e10:	f0 e0       	ldi	r31, 0x00	; 0
     e12:	90 81       	ld	r25, Z
     e14:	89 81       	ldd	r24, Y+1	; 0x01
     e16:	89 2b       	or	r24, r25
     e18:	8c 93       	st	X, r24
	else
	{
		//Do Nothing

	}
}
     e1a:	26 96       	adiw	r28, 0x06	; 6
     e1c:	0f b6       	in	r0, 0x3f	; 63
     e1e:	f8 94       	cli
     e20:	de bf       	out	0x3e, r29	; 62
     e22:	0f be       	out	0x3f, r0	; 63
     e24:	cd bf       	out	0x3d, r28	; 61
     e26:	cf 91       	pop	r28
     e28:	df 91       	pop	r29
     e2a:	08 95       	ret

00000e2c <MADC_Init>:
#include"../../LIB/BIT_MATH.h"
#include"MADC_Private.h"
#include"MADC_Config.h"

void MADC_Init(void)
{
     e2c:	df 93       	push	r29
     e2e:	cf 93       	push	r28
     e30:	cd b7       	in	r28, 0x3d	; 61
     e32:	de b7       	in	r29, 0x3e	; 62
	//Set Vreference
#if MADC_SET_VREF==VREF_AREF_PIN
	CLR_BIT(ADMUX,6);
	CLR_BIT(ADMUX,7);
#elif MADC_SET_VREF==VREF_AVCC_PIN
	SET_BIT(ADMUX,6);
     e34:	a7 e2       	ldi	r26, 0x27	; 39
     e36:	b0 e0       	ldi	r27, 0x00	; 0
     e38:	e7 e2       	ldi	r30, 0x27	; 39
     e3a:	f0 e0       	ldi	r31, 0x00	; 0
     e3c:	80 81       	ld	r24, Z
     e3e:	80 64       	ori	r24, 0x40	; 64
     e40:	8c 93       	st	X, r24
	CLR_BIT(ADMUX,7);
     e42:	a7 e2       	ldi	r26, 0x27	; 39
     e44:	b0 e0       	ldi	r27, 0x00	; 0
     e46:	e7 e2       	ldi	r30, 0x27	; 39
     e48:	f0 e0       	ldi	r31, 0x00	; 0
     e4a:	80 81       	ld	r24, Z
     e4c:	8f 77       	andi	r24, 0x7F	; 127
     e4e:	8c 93       	st	X, r24
#elif MADC_SET_PRESCALAR==PRESCALER_DIVIDE_BY_8
SET_BIT(ADCSRA,0);
SET_BIT(ADCSRA,1);
CLR_BIT(ADCSRA,2);
#elif MADC_SET_PRESCALAR==PRESCALER_DIVIDE_BY_16
CLR_BIT(ADCSRA,0);
     e50:	a6 e2       	ldi	r26, 0x26	; 38
     e52:	b0 e0       	ldi	r27, 0x00	; 0
     e54:	e6 e2       	ldi	r30, 0x26	; 38
     e56:	f0 e0       	ldi	r31, 0x00	; 0
     e58:	80 81       	ld	r24, Z
     e5a:	8e 7f       	andi	r24, 0xFE	; 254
     e5c:	8c 93       	st	X, r24
CLR_BIT(ADCSRA,1);
     e5e:	a6 e2       	ldi	r26, 0x26	; 38
     e60:	b0 e0       	ldi	r27, 0x00	; 0
     e62:	e6 e2       	ldi	r30, 0x26	; 38
     e64:	f0 e0       	ldi	r31, 0x00	; 0
     e66:	80 81       	ld	r24, Z
     e68:	8d 7f       	andi	r24, 0xFD	; 253
     e6a:	8c 93       	st	X, r24
SET_BIT(ADCSRA,2);
     e6c:	a6 e2       	ldi	r26, 0x26	; 38
     e6e:	b0 e0       	ldi	r27, 0x00	; 0
     e70:	e6 e2       	ldi	r30, 0x26	; 38
     e72:	f0 e0       	ldi	r31, 0x00	; 0
     e74:	80 81       	ld	r24, Z
     e76:	84 60       	ori	r24, 0x04	; 4
     e78:	8c 93       	st	X, r24
#error"Wrong Prescalar Chosen"
#endif

//Left/Adjust
#if MADC_SET_ADJUST_LEVEL==MADC_RIGHT_ADJUST
CLR_BIT(ADMUX,5);
     e7a:	a7 e2       	ldi	r26, 0x27	; 39
     e7c:	b0 e0       	ldi	r27, 0x00	; 0
     e7e:	e7 e2       	ldi	r30, 0x27	; 39
     e80:	f0 e0       	ldi	r31, 0x00	; 0
     e82:	80 81       	ld	r24, Z
     e84:	8f 7d       	andi	r24, 0xDF	; 223
     e86:	8c 93       	st	X, r24
#elif MADC_SET_ADJUST_LEVEL==MADC_LEFT_ADJUST
SET_BIT(ADMUX,5);
#endif

/*Enable ADC*/
SET_BIT(ADCSRA,7);
     e88:	a6 e2       	ldi	r26, 0x26	; 38
     e8a:	b0 e0       	ldi	r27, 0x00	; 0
     e8c:	e6 e2       	ldi	r30, 0x26	; 38
     e8e:	f0 e0       	ldi	r31, 0x00	; 0
     e90:	80 81       	ld	r24, Z
     e92:	80 68       	ori	r24, 0x80	; 128
     e94:	8c 93       	st	X, r24
}
     e96:	cf 91       	pop	r28
     e98:	df 91       	pop	r29
     e9a:	08 95       	ret

00000e9c <MADC_StartConversion>:

u16 MADC_StartConversion(u8 Copy_u8ADC_Channel)
{
     e9c:	df 93       	push	r29
     e9e:	cf 93       	push	r28
     ea0:	00 d0       	rcall	.+0      	; 0xea2 <MADC_StartConversion+0x6>
     ea2:	cd b7       	in	r28, 0x3d	; 61
     ea4:	de b7       	in	r29, 0x3e	; 62
     ea6:	8a 83       	std	Y+2, r24	; 0x02
	//Set Channel
	u8 Loc_u8ADC_Channel =Copy_u8ADC_Channel&MADC_CHANNEL_INPUT_MASK;
     ea8:	8a 81       	ldd	r24, Y+2	; 0x02
     eaa:	8f 71       	andi	r24, 0x1F	; 31
     eac:	89 83       	std	Y+1, r24	; 0x01
	ADMUX&=MADC_ADMUX_REG_MASK;
     eae:	a7 e2       	ldi	r26, 0x27	; 39
     eb0:	b0 e0       	ldi	r27, 0x00	; 0
     eb2:	e7 e2       	ldi	r30, 0x27	; 39
     eb4:	f0 e0       	ldi	r31, 0x00	; 0
     eb6:	80 81       	ld	r24, Z
     eb8:	80 7e       	andi	r24, 0xE0	; 224
     eba:	8c 93       	st	X, r24
	ADMUX|=Loc_u8ADC_Channel;
     ebc:	a7 e2       	ldi	r26, 0x27	; 39
     ebe:	b0 e0       	ldi	r27, 0x00	; 0
     ec0:	e7 e2       	ldi	r30, 0x27	; 39
     ec2:	f0 e0       	ldi	r31, 0x00	; 0
     ec4:	90 81       	ld	r25, Z
     ec6:	89 81       	ldd	r24, Y+1	; 0x01
     ec8:	89 2b       	or	r24, r25
     eca:	8c 93       	st	X, r24

	//Start Conversion
	SET_BIT(ADCSRA,6);
     ecc:	a6 e2       	ldi	r26, 0x26	; 38
     ece:	b0 e0       	ldi	r27, 0x00	; 0
     ed0:	e6 e2       	ldi	r30, 0x26	; 38
     ed2:	f0 e0       	ldi	r31, 0x00	; 0
     ed4:	80 81       	ld	r24, Z
     ed6:	80 64       	ori	r24, 0x40	; 64
     ed8:	8c 93       	st	X, r24

	//Poll on the Flag
	while(GET_BIT(ADCSRA,4)==0);
     eda:	e6 e2       	ldi	r30, 0x26	; 38
     edc:	f0 e0       	ldi	r31, 0x00	; 0
     ede:	80 81       	ld	r24, Z
     ee0:	82 95       	swap	r24
     ee2:	8f 70       	andi	r24, 0x0F	; 15
     ee4:	88 2f       	mov	r24, r24
     ee6:	90 e0       	ldi	r25, 0x00	; 0
     ee8:	81 70       	andi	r24, 0x01	; 1
     eea:	90 70       	andi	r25, 0x00	; 0
     eec:	00 97       	sbiw	r24, 0x00	; 0
     eee:	a9 f3       	breq	.-22     	; 0xeda <MADC_StartConversion+0x3e>

	//Conversion finished
	return ADC;
     ef0:	e4 e2       	ldi	r30, 0x24	; 36
     ef2:	f0 e0       	ldi	r31, 0x00	; 0
     ef4:	80 81       	ld	r24, Z
     ef6:	91 81       	ldd	r25, Z+1	; 0x01
}
     ef8:	0f 90       	pop	r0
     efa:	0f 90       	pop	r0
     efc:	cf 91       	pop	r28
     efe:	df 91       	pop	r29
     f00:	08 95       	ret

00000f02 <HKPD_Init>:
#include"HKPD_Interface.h"
#include"HKPD_Private.h"
#include "../../FreeRTOS_Stack/FreeRTOS.h"

void HKPD_Init()
{
     f02:	df 93       	push	r29
     f04:	cf 93       	push	r28
     f06:	cd b7       	in	r28, 0x3d	; 61
     f08:	de b7       	in	r29, 0x3e	; 62
	/*Set Columns Pins Direction Output*/
	MDIO_SetPinDirection(HKPD_COLUMN_0_PIN,HKPD_COLUMN_PORT,PIN_OUTPUT);
     f0a:	80 e0       	ldi	r24, 0x00	; 0
     f0c:	62 e0       	ldi	r22, 0x02	; 2
     f0e:	41 e0       	ldi	r20, 0x01	; 1
     f10:	0e 94 cb 02 	call	0x596	; 0x596 <MDIO_SetPinDirection>
	MDIO_SetPinDirection(HKPD_COLUMN_1_PIN,HKPD_COLUMN_PORT,PIN_OUTPUT);
     f14:	81 e0       	ldi	r24, 0x01	; 1
     f16:	62 e0       	ldi	r22, 0x02	; 2
     f18:	41 e0       	ldi	r20, 0x01	; 1
     f1a:	0e 94 cb 02 	call	0x596	; 0x596 <MDIO_SetPinDirection>
	MDIO_SetPinDirection(HKPD_COLUMN_2_PIN,HKPD_COLUMN_PORT,PIN_OUTPUT);
     f1e:	82 e0       	ldi	r24, 0x02	; 2
     f20:	62 e0       	ldi	r22, 0x02	; 2
     f22:	41 e0       	ldi	r20, 0x01	; 1
     f24:	0e 94 cb 02 	call	0x596	; 0x596 <MDIO_SetPinDirection>
	MDIO_SetPinDirection(HKPD_COLUMN_3_PIN,HKPD_COLUMN_PORT,PIN_OUTPUT);
     f28:	83 e0       	ldi	r24, 0x03	; 3
     f2a:	62 e0       	ldi	r22, 0x02	; 2
     f2c:	41 e0       	ldi	r20, 0x01	; 1
     f2e:	0e 94 cb 02 	call	0x596	; 0x596 <MDIO_SetPinDirection>

	/*Set Row Pins Direction Input*/
	MDIO_SetPinDirection(HKPD_ROW_0_PIN,HKPD_ROW_PORT,PIN_INPUT);
     f32:	84 e0       	ldi	r24, 0x04	; 4
     f34:	62 e0       	ldi	r22, 0x02	; 2
     f36:	40 e0       	ldi	r20, 0x00	; 0
     f38:	0e 94 cb 02 	call	0x596	; 0x596 <MDIO_SetPinDirection>
	MDIO_SetPinDirection(HKPD_ROW_1_PIN,HKPD_ROW_PORT,PIN_INPUT);
     f3c:	85 e0       	ldi	r24, 0x05	; 5
     f3e:	62 e0       	ldi	r22, 0x02	; 2
     f40:	40 e0       	ldi	r20, 0x00	; 0
     f42:	0e 94 cb 02 	call	0x596	; 0x596 <MDIO_SetPinDirection>
	MDIO_SetPinDirection(HKPD_ROW_2_PIN,HKPD_ROW_PORT,PIN_INPUT);
     f46:	86 e0       	ldi	r24, 0x06	; 6
     f48:	62 e0       	ldi	r22, 0x02	; 2
     f4a:	40 e0       	ldi	r20, 0x00	; 0
     f4c:	0e 94 cb 02 	call	0x596	; 0x596 <MDIO_SetPinDirection>
	MDIO_SetPinDirection(HKPD_ROW_3_PIN,HKPD_ROW_PORT,PIN_INPUT);
     f50:	87 e0       	ldi	r24, 0x07	; 7
     f52:	62 e0       	ldi	r22, 0x02	; 2
     f54:	40 e0       	ldi	r20, 0x00	; 0
     f56:	0e 94 cb 02 	call	0x596	; 0x596 <MDIO_SetPinDirection>

	/*Activate Pull up Resistor */
	MDIO_SetPinValue(HKPD_ROW_0_PIN,HKPD_ROW_PORT,PIN_HIGH);
     f5a:	84 e0       	ldi	r24, 0x04	; 4
     f5c:	62 e0       	ldi	r22, 0x02	; 2
     f5e:	41 e0       	ldi	r20, 0x01	; 1
     f60:	0e 94 08 04 	call	0x810	; 0x810 <MDIO_SetPinValue>
	MDIO_SetPinValue(HKPD_ROW_1_PIN,HKPD_ROW_PORT,PIN_HIGH);
     f64:	85 e0       	ldi	r24, 0x05	; 5
     f66:	62 e0       	ldi	r22, 0x02	; 2
     f68:	41 e0       	ldi	r20, 0x01	; 1
     f6a:	0e 94 08 04 	call	0x810	; 0x810 <MDIO_SetPinValue>
	MDIO_SetPinValue(HKPD_ROW_2_PIN,HKPD_ROW_PORT,PIN_HIGH);
     f6e:	86 e0       	ldi	r24, 0x06	; 6
     f70:	62 e0       	ldi	r22, 0x02	; 2
     f72:	41 e0       	ldi	r20, 0x01	; 1
     f74:	0e 94 08 04 	call	0x810	; 0x810 <MDIO_SetPinValue>
	MDIO_SetPinValue(HKPD_ROW_3_PIN,HKPD_ROW_PORT,PIN_HIGH);
     f78:	87 e0       	ldi	r24, 0x07	; 7
     f7a:	62 e0       	ldi	r22, 0x02	; 2
     f7c:	41 e0       	ldi	r20, 0x01	; 1
     f7e:	0e 94 08 04 	call	0x810	; 0x810 <MDIO_SetPinValue>

	/*Deactivate Columns */
	MDIO_SetPinValue(HKPD_COLUMN_0_PIN,HKPD_COLUMN_PORT,PIN_HIGH);
     f82:	80 e0       	ldi	r24, 0x00	; 0
     f84:	62 e0       	ldi	r22, 0x02	; 2
     f86:	41 e0       	ldi	r20, 0x01	; 1
     f88:	0e 94 08 04 	call	0x810	; 0x810 <MDIO_SetPinValue>
	MDIO_SetPinValue(HKPD_COLUMN_1_PIN,HKPD_COLUMN_PORT,PIN_HIGH);
     f8c:	81 e0       	ldi	r24, 0x01	; 1
     f8e:	62 e0       	ldi	r22, 0x02	; 2
     f90:	41 e0       	ldi	r20, 0x01	; 1
     f92:	0e 94 08 04 	call	0x810	; 0x810 <MDIO_SetPinValue>
	MDIO_SetPinValue(HKPD_COLUMN_2_PIN,HKPD_COLUMN_PORT,PIN_HIGH);
     f96:	82 e0       	ldi	r24, 0x02	; 2
     f98:	62 e0       	ldi	r22, 0x02	; 2
     f9a:	41 e0       	ldi	r20, 0x01	; 1
     f9c:	0e 94 08 04 	call	0x810	; 0x810 <MDIO_SetPinValue>
	MDIO_SetPinValue(HKPD_COLUMN_3_PIN,HKPD_COLUMN_PORT,PIN_HIGH);
     fa0:	83 e0       	ldi	r24, 0x03	; 3
     fa2:	62 e0       	ldi	r22, 0x02	; 2
     fa4:	41 e0       	ldi	r20, 0x01	; 1
     fa6:	0e 94 08 04 	call	0x810	; 0x810 <MDIO_SetPinValue>

}
     faa:	cf 91       	pop	r28
     fac:	df 91       	pop	r29
     fae:	08 95       	ret

00000fb0 <HKPD_GetPressedButton>:


u8 HKPD_GetPressedButton()
{
     fb0:	df 93       	push	r29
     fb2:	cf 93       	push	r28
     fb4:	00 d0       	rcall	.+0      	; 0xfb6 <HKPD_GetPressedButton+0x6>
     fb6:	00 d0       	rcall	.+0      	; 0xfb8 <HKPD_GetPressedButton+0x8>
     fb8:	cd b7       	in	r28, 0x3d	; 61
     fba:	de b7       	in	r29, 0x3e	; 62
	u8 Loc_u8ColumnCounter=0;
     fbc:	1b 82       	std	Y+3, r1	; 0x03
	u8 Loc_u8RowCounter=0;
     fbe:	1a 82       	std	Y+2, r1	; 0x02

	u8 Loc_u8ReturnValue=HKPD_NOT_PRESSED;
     fc0:	84 e2       	ldi	r24, 0x24	; 36
     fc2:	89 83       	std	Y+1, r24	; 0x01

	u8 Loc_u8PinState=0;
     fc4:	1c 82       	std	Y+4, r1	; 0x04

	for (Loc_u8ColumnCounter=HKPD_COL_START;Loc_u8ColumnCounter<HKPD_COL_END;Loc_u8ColumnCounter++)
     fc6:	1b 82       	std	Y+3, r1	; 0x03
     fc8:	42 c0       	rjmp	.+132    	; 0x104e <HKPD_GetPressedButton+0x9e>
	{
		/*Activate the column*/
		MDIO_SetPinValue(Loc_u8ColumnCounter,HKPD_COLUMN_PORT,PIN_LOW);
     fca:	8b 81       	ldd	r24, Y+3	; 0x03
     fcc:	62 e0       	ldi	r22, 0x02	; 2
     fce:	40 e0       	ldi	r20, 0x00	; 0
     fd0:	0e 94 08 04 	call	0x810	; 0x810 <MDIO_SetPinValue>


		for(Loc_u8RowCounter=HKPD_ROW_START;Loc_u8RowCounter<HKPD_ROW_END;Loc_u8RowCounter++)
     fd4:	84 e0       	ldi	r24, 0x04	; 4
     fd6:	8a 83       	std	Y+2, r24	; 0x02
     fd8:	2f c0       	rjmp	.+94     	; 0x1038 <HKPD_GetPressedButton+0x88>
		{
			MDIO_ReadPin(Loc_u8RowCounter,HKPD_ROW_PORT,&Loc_u8PinState);
     fda:	9e 01       	movw	r18, r28
     fdc:	2c 5f       	subi	r18, 0xFC	; 252
     fde:	3f 4f       	sbci	r19, 0xFF	; 255
     fe0:	8a 81       	ldd	r24, Y+2	; 0x02
     fe2:	62 e0       	ldi	r22, 0x02	; 2
     fe4:	a9 01       	movw	r20, r18
     fe6:	0e 94 4e 05 	call	0xa9c	; 0xa9c <MDIO_ReadPin>

			if(Loc_u8PinState==0)
     fea:	8c 81       	ldd	r24, Y+4	; 0x04
     fec:	88 23       	and	r24, r24
     fee:	09 f5       	brne	.+66     	; 0x1032 <HKPD_GetPressedButton+0x82>
			{
				// Retrieve the Key Value
				Loc_u8ReturnValue=HKPD_SwitchValues[Loc_u8ColumnCounter-HKPD_COL_START][Loc_u8RowCounter-HKPD_ROW_START];
     ff0:	8b 81       	ldd	r24, Y+3	; 0x03
     ff2:	48 2f       	mov	r20, r24
     ff4:	50 e0       	ldi	r21, 0x00	; 0
     ff6:	8a 81       	ldd	r24, Y+2	; 0x02
     ff8:	88 2f       	mov	r24, r24
     ffa:	90 e0       	ldi	r25, 0x00	; 0
     ffc:	9c 01       	movw	r18, r24
     ffe:	24 50       	subi	r18, 0x04	; 4
    1000:	30 40       	sbci	r19, 0x00	; 0
    1002:	ca 01       	movw	r24, r20
    1004:	88 0f       	add	r24, r24
    1006:	99 1f       	adc	r25, r25
    1008:	88 0f       	add	r24, r24
    100a:	99 1f       	adc	r25, r25
    100c:	82 0f       	add	r24, r18
    100e:	93 1f       	adc	r25, r19
    1010:	fc 01       	movw	r30, r24
    1012:	ef 56       	subi	r30, 0x6F	; 111
    1014:	ff 4f       	sbci	r31, 0xFF	; 255
    1016:	80 81       	ld	r24, Z
    1018:	89 83       	std	Y+1, r24	; 0x01
    101a:	08 c0       	rjmp	.+16     	; 0x102c <HKPD_GetPressedButton+0x7c>

				while(Loc_u8PinState==0)
				{
					MDIO_ReadPin(Loc_u8RowCounter,HKPD_ROW_PORT,&Loc_u8PinState);
    101c:	9e 01       	movw	r18, r28
    101e:	2c 5f       	subi	r18, 0xFC	; 252
    1020:	3f 4f       	sbci	r19, 0xFF	; 255
    1022:	8a 81       	ldd	r24, Y+2	; 0x02
    1024:	62 e0       	ldi	r22, 0x02	; 2
    1026:	a9 01       	movw	r20, r18
    1028:	0e 94 4e 05 	call	0xa9c	; 0xa9c <MDIO_ReadPin>
			if(Loc_u8PinState==0)
			{
				// Retrieve the Key Value
				Loc_u8ReturnValue=HKPD_SwitchValues[Loc_u8ColumnCounter-HKPD_COL_START][Loc_u8RowCounter-HKPD_ROW_START];

				while(Loc_u8PinState==0)
    102c:	8c 81       	ldd	r24, Y+4	; 0x04
    102e:	88 23       	and	r24, r24
    1030:	a9 f3       	breq	.-22     	; 0x101c <HKPD_GetPressedButton+0x6c>
	{
		/*Activate the column*/
		MDIO_SetPinValue(Loc_u8ColumnCounter,HKPD_COLUMN_PORT,PIN_LOW);


		for(Loc_u8RowCounter=HKPD_ROW_START;Loc_u8RowCounter<HKPD_ROW_END;Loc_u8RowCounter++)
    1032:	8a 81       	ldd	r24, Y+2	; 0x02
    1034:	8f 5f       	subi	r24, 0xFF	; 255
    1036:	8a 83       	std	Y+2, r24	; 0x02
    1038:	8a 81       	ldd	r24, Y+2	; 0x02
    103a:	88 30       	cpi	r24, 0x08	; 8
    103c:	70 f2       	brcs	.-100    	; 0xfda <HKPD_GetPressedButton+0x2a>
				//Do Nothing
			}
		}

		//Deactivate Column
		MDIO_SetPinValue(Loc_u8ColumnCounter,HKPD_COLUMN_PORT,PIN_HIGH);
    103e:	8b 81       	ldd	r24, Y+3	; 0x03
    1040:	62 e0       	ldi	r22, 0x02	; 2
    1042:	41 e0       	ldi	r20, 0x01	; 1
    1044:	0e 94 08 04 	call	0x810	; 0x810 <MDIO_SetPinValue>

	u8 Loc_u8ReturnValue=HKPD_NOT_PRESSED;

	u8 Loc_u8PinState=0;

	for (Loc_u8ColumnCounter=HKPD_COL_START;Loc_u8ColumnCounter<HKPD_COL_END;Loc_u8ColumnCounter++)
    1048:	8b 81       	ldd	r24, Y+3	; 0x03
    104a:	8f 5f       	subi	r24, 0xFF	; 255
    104c:	8b 83       	std	Y+3, r24	; 0x03
    104e:	8b 81       	ldd	r24, Y+3	; 0x03
    1050:	84 30       	cpi	r24, 0x04	; 4
    1052:	08 f4       	brcc	.+2      	; 0x1056 <HKPD_GetPressedButton+0xa6>
    1054:	ba cf       	rjmp	.-140    	; 0xfca <HKPD_GetPressedButton+0x1a>
		}

		//Deactivate Column
		MDIO_SetPinValue(Loc_u8ColumnCounter,HKPD_COLUMN_PORT,PIN_HIGH);
	}
	return Loc_u8ReturnValue;
    1056:	89 81       	ldd	r24, Y+1	; 0x01
}
    1058:	0f 90       	pop	r0
    105a:	0f 90       	pop	r0
    105c:	0f 90       	pop	r0
    105e:	0f 90       	pop	r0
    1060:	cf 91       	pop	r28
    1062:	df 91       	pop	r29
    1064:	08 95       	ret

00001066 <HCLCD_WriteCommand4Bit>:
#include"HCLCD_Config.h"
#include "../../FreeRTOS_Stack/FreeRTOS.h"


void HCLCD_WriteCommand4Bit(u8 Copy_u8Command)
{
    1066:	df 93       	push	r29
    1068:	cf 93       	push	r28
    106a:	0f 92       	push	r0
    106c:	cd b7       	in	r28, 0x3d	; 61
    106e:	de b7       	in	r29, 0x3e	; 62
    1070:	89 83       	std	Y+1, r24	; 0x01
	//Set RW to Zero
	MDIO_SetPinValue(RW,CONTROL_PORT,PIN_LOW);
    1072:	82 e0       	ldi	r24, 0x02	; 2
    1074:	61 e0       	ldi	r22, 0x01	; 1
    1076:	40 e0       	ldi	r20, 0x00	; 0
    1078:	0e 94 08 04 	call	0x810	; 0x810 <MDIO_SetPinValue>

	//Set RS to Zero ==> to indicate a Command
	MDIO_SetPinValue(RS,CONTROL_PORT,PIN_LOW);
    107c:	81 e0       	ldi	r24, 0x01	; 1
    107e:	61 e0       	ldi	r22, 0x01	; 1
    1080:	40 e0       	ldi	r20, 0x00	; 0
    1082:	0e 94 08 04 	call	0x810	; 0x810 <MDIO_SetPinValue>

	//Set High Nibble Value of the Command
	MDIO_SetNibbleValue(HCLCD_PIN_START,DATA_PORT,Copy_u8Command>>4);
    1086:	89 81       	ldd	r24, Y+1	; 0x01
    1088:	98 2f       	mov	r25, r24
    108a:	92 95       	swap	r25
    108c:	9f 70       	andi	r25, 0x0F	; 15
    108e:	84 e0       	ldi	r24, 0x04	; 4
    1090:	60 e0       	ldi	r22, 0x00	; 0
    1092:	49 2f       	mov	r20, r25
    1094:	0e 94 57 06 	call	0xcae	; 0xcae <MDIO_SetNibbleValue>

	//Send the Falling Edge
	MDIO_SetPinValue(E,CONTROL_PORT,PIN_HIGH);
    1098:	84 e0       	ldi	r24, 0x04	; 4
    109a:	61 e0       	ldi	r22, 0x01	; 1
    109c:	41 e0       	ldi	r20, 0x01	; 1
    109e:	0e 94 08 04 	call	0x810	; 0x810 <MDIO_SetPinValue>


	//_delay_ms(2);
	vTaskDelay(2);
    10a2:	82 e0       	ldi	r24, 0x02	; 2
    10a4:	90 e0       	ldi	r25, 0x00	; 0
    10a6:	0e 94 62 17 	call	0x2ec4	; 0x2ec4 <vTaskDelay>
	MDIO_SetPinValue(E,CONTROL_PORT,PIN_LOW);
    10aa:	84 e0       	ldi	r24, 0x04	; 4
    10ac:	61 e0       	ldi	r22, 0x01	; 1
    10ae:	40 e0       	ldi	r20, 0x00	; 0
    10b0:	0e 94 08 04 	call	0x810	; 0x810 <MDIO_SetPinValue>

	//Send The Lower Nibble
	MDIO_SetNibbleValue(HCLCD_PIN_START,DATA_PORT,Copy_u8Command);
    10b4:	84 e0       	ldi	r24, 0x04	; 4
    10b6:	60 e0       	ldi	r22, 0x00	; 0
    10b8:	49 81       	ldd	r20, Y+1	; 0x01
    10ba:	0e 94 57 06 	call	0xcae	; 0xcae <MDIO_SetNibbleValue>

	//Send the Falling Edge
	MDIO_SetPinValue(E,CONTROL_PORT,PIN_HIGH);
    10be:	84 e0       	ldi	r24, 0x04	; 4
    10c0:	61 e0       	ldi	r22, 0x01	; 1
    10c2:	41 e0       	ldi	r20, 0x01	; 1
    10c4:	0e 94 08 04 	call	0x810	; 0x810 <MDIO_SetPinValue>
	//_delay_ms(2);
	vTaskDelay(2);
    10c8:	82 e0       	ldi	r24, 0x02	; 2
    10ca:	90 e0       	ldi	r25, 0x00	; 0
    10cc:	0e 94 62 17 	call	0x2ec4	; 0x2ec4 <vTaskDelay>
	MDIO_SetPinValue(E,CONTROL_PORT,PIN_LOW);
    10d0:	84 e0       	ldi	r24, 0x04	; 4
    10d2:	61 e0       	ldi	r22, 0x01	; 1
    10d4:	40 e0       	ldi	r20, 0x00	; 0
    10d6:	0e 94 08 04 	call	0x810	; 0x810 <MDIO_SetPinValue>
}
    10da:	0f 90       	pop	r0
    10dc:	cf 91       	pop	r28
    10de:	df 91       	pop	r29
    10e0:	08 95       	ret

000010e2 <HCLCD_Init4Bit>:

void HCLCD_Init4Bit()
{
    10e2:	df 93       	push	r29
    10e4:	cf 93       	push	r28
    10e6:	0f 92       	push	r0
    10e8:	cd b7       	in	r28, 0x3d	; 61
    10ea:	de b7       	in	r29, 0x3e	; 62
	//_delay_ms(30);
	vTaskDelay(30);
    10ec:	8e e1       	ldi	r24, 0x1E	; 30
    10ee:	90 e0       	ldi	r25, 0x00	; 0
    10f0:	0e 94 62 17 	call	0x2ec4	; 0x2ec4 <vTaskDelay>
	u8 Loc_u8Counter=0;
    10f4:	19 82       	std	Y+1, r1	; 0x01

	//Set Direction of Data the used pins
	for(Loc_u8Counter=HCLCD_PIN_START;Loc_u8Counter<(HCLCD_PIN_START+4);Loc_u8Counter++)
    10f6:	84 e0       	ldi	r24, 0x04	; 4
    10f8:	89 83       	std	Y+1, r24	; 0x01
    10fa:	08 c0       	rjmp	.+16     	; 0x110c <HCLCD_Init4Bit+0x2a>
	{
		MDIO_SetPinDirection(Loc_u8Counter,DATA_PORT,PIN_OUTPUT);
    10fc:	89 81       	ldd	r24, Y+1	; 0x01
    10fe:	60 e0       	ldi	r22, 0x00	; 0
    1100:	41 e0       	ldi	r20, 0x01	; 1
    1102:	0e 94 cb 02 	call	0x596	; 0x596 <MDIO_SetPinDirection>
	//_delay_ms(30);
	vTaskDelay(30);
	u8 Loc_u8Counter=0;

	//Set Direction of Data the used pins
	for(Loc_u8Counter=HCLCD_PIN_START;Loc_u8Counter<(HCLCD_PIN_START+4);Loc_u8Counter++)
    1106:	89 81       	ldd	r24, Y+1	; 0x01
    1108:	8f 5f       	subi	r24, 0xFF	; 255
    110a:	89 83       	std	Y+1, r24	; 0x01
    110c:	89 81       	ldd	r24, Y+1	; 0x01
    110e:	88 30       	cpi	r24, 0x08	; 8
    1110:	a8 f3       	brcs	.-22     	; 0x10fc <HCLCD_Init4Bit+0x1a>
	{
		MDIO_SetPinDirection(Loc_u8Counter,DATA_PORT,PIN_OUTPUT);
	}

	//Set Direction of the Control Pins
	MDIO_SetPinDirection(RS,CONTROL_PORT,PIN_OUTPUT);
    1112:	81 e0       	ldi	r24, 0x01	; 1
    1114:	61 e0       	ldi	r22, 0x01	; 1
    1116:	41 e0       	ldi	r20, 0x01	; 1
    1118:	0e 94 cb 02 	call	0x596	; 0x596 <MDIO_SetPinDirection>
	MDIO_SetPinDirection(RW,CONTROL_PORT,PIN_OUTPUT);
    111c:	82 e0       	ldi	r24, 0x02	; 2
    111e:	61 e0       	ldi	r22, 0x01	; 1
    1120:	41 e0       	ldi	r20, 0x01	; 1
    1122:	0e 94 cb 02 	call	0x596	; 0x596 <MDIO_SetPinDirection>
	MDIO_SetPinDirection(E,CONTROL_PORT,PIN_OUTPUT);
    1126:	84 e0       	ldi	r24, 0x04	; 4
    1128:	61 e0       	ldi	r22, 0x01	; 1
    112a:	41 e0       	ldi	r20, 0x01	; 1
    112c:	0e 94 cb 02 	call	0x596	; 0x596 <MDIO_SetPinDirection>
	 */
	//Send Function Set Command

	//1-Sending High Nibble of the Function Set Command

	MDIO_SetNibbleValue(HCLCD_PIN_START,DATA_PORT,FUNCTION_SET_MODE_COMMAND>>4);
    1130:	84 e0       	ldi	r24, 0x04	; 4
    1132:	60 e0       	ldi	r22, 0x00	; 0
    1134:	42 e0       	ldi	r20, 0x02	; 2
    1136:	0e 94 57 06 	call	0xcae	; 0xcae <MDIO_SetNibbleValue>

	//Send the Falling Edge
	MDIO_SetPinValue(E,CONTROL_PORT,PIN_HIGH);
    113a:	84 e0       	ldi	r24, 0x04	; 4
    113c:	61 e0       	ldi	r22, 0x01	; 1
    113e:	41 e0       	ldi	r20, 0x01	; 1
    1140:	0e 94 08 04 	call	0x810	; 0x810 <MDIO_SetPinValue>
	//_delay_ms(2);
	vTaskDelay(2);
    1144:	82 e0       	ldi	r24, 0x02	; 2
    1146:	90 e0       	ldi	r25, 0x00	; 0
    1148:	0e 94 62 17 	call	0x2ec4	; 0x2ec4 <vTaskDelay>
	MDIO_SetPinValue(E,CONTROL_PORT,PIN_LOW);
    114c:	84 e0       	ldi	r24, 0x04	; 4
    114e:	61 e0       	ldi	r22, 0x01	; 1
    1150:	40 e0       	ldi	r20, 0x00	; 0
    1152:	0e 94 08 04 	call	0x810	; 0x810 <MDIO_SetPinValue>


	//2-Sending Function Set Command
	HCLCD_WriteCommand4Bit(FUNCTION_SET_MODE_COMMAND);
    1156:	88 e2       	ldi	r24, 0x28	; 40
    1158:	0e 94 33 08 	call	0x1066	; 0x1066 <HCLCD_WriteCommand4Bit>

	//Send Display On/Off command
	//_delay_ms(1);
	vTaskDelay(1);
    115c:	81 e0       	ldi	r24, 0x01	; 1
    115e:	90 e0       	ldi	r25, 0x00	; 0
    1160:	0e 94 62 17 	call	0x2ec4	; 0x2ec4 <vTaskDelay>
	HCLCD_WriteCommand4Bit(DISPALY_ON_OFF_COMMAND);
    1164:	8f e0       	ldi	r24, 0x0F	; 15
    1166:	0e 94 33 08 	call	0x1066	; 0x1066 <HCLCD_WriteCommand4Bit>

	//Display Clear Mode
	//_delay_ms(1);
	vTaskDelay(1);
    116a:	81 e0       	ldi	r24, 0x01	; 1
    116c:	90 e0       	ldi	r25, 0x00	; 0
    116e:	0e 94 62 17 	call	0x2ec4	; 0x2ec4 <vTaskDelay>
	HCLCD_WriteCommand4Bit(DISPALY_CLEAR_COMMAND);
    1172:	81 e0       	ldi	r24, 0x01	; 1
    1174:	0e 94 33 08 	call	0x1066	; 0x1066 <HCLCD_WriteCommand4Bit>

	//Entry Mode
	//_delay_ms(2);
	vTaskDelay(2);
    1178:	82 e0       	ldi	r24, 0x02	; 2
    117a:	90 e0       	ldi	r25, 0x00	; 0
    117c:	0e 94 62 17 	call	0x2ec4	; 0x2ec4 <vTaskDelay>
	HCLCD_WriteCommand4Bit(ENTRY_MODE_COMMAND);
    1180:	86 e0       	ldi	r24, 0x06	; 6
    1182:	0e 94 33 08 	call	0x1066	; 0x1066 <HCLCD_WriteCommand4Bit>
}
    1186:	0f 90       	pop	r0
    1188:	cf 91       	pop	r28
    118a:	df 91       	pop	r29
    118c:	08 95       	ret

0000118e <HCLCD_WriteChar4Bit>:

void HCLCD_WriteChar4Bit(u8 Copy_u8Data)
{
    118e:	df 93       	push	r29
    1190:	cf 93       	push	r28
    1192:	0f 92       	push	r0
    1194:	cd b7       	in	r28, 0x3d	; 61
    1196:	de b7       	in	r29, 0x3e	; 62
    1198:	89 83       	std	Y+1, r24	; 0x01
	//Set RW to Zero
	MDIO_SetPinValue(RW,CONTROL_PORT,PIN_LOW);
    119a:	82 e0       	ldi	r24, 0x02	; 2
    119c:	61 e0       	ldi	r22, 0x01	; 1
    119e:	40 e0       	ldi	r20, 0x00	; 0
    11a0:	0e 94 08 04 	call	0x810	; 0x810 <MDIO_SetPinValue>

	//Set RS to One ==> to indicate a Data
	MDIO_SetPinValue(RS,CONTROL_PORT,PIN_HIGH);
    11a4:	81 e0       	ldi	r24, 0x01	; 1
    11a6:	61 e0       	ldi	r22, 0x01	; 1
    11a8:	41 e0       	ldi	r20, 0x01	; 1
    11aa:	0e 94 08 04 	call	0x810	; 0x810 <MDIO_SetPinValue>

	//Set High Nibble Value of the Command
	MDIO_SetNibbleValue(HCLCD_PIN_START,DATA_PORT,Copy_u8Data>>4);
    11ae:	89 81       	ldd	r24, Y+1	; 0x01
    11b0:	98 2f       	mov	r25, r24
    11b2:	92 95       	swap	r25
    11b4:	9f 70       	andi	r25, 0x0F	; 15
    11b6:	84 e0       	ldi	r24, 0x04	; 4
    11b8:	60 e0       	ldi	r22, 0x00	; 0
    11ba:	49 2f       	mov	r20, r25
    11bc:	0e 94 57 06 	call	0xcae	; 0xcae <MDIO_SetNibbleValue>

	//Send the Falling Edge
	MDIO_SetPinValue(E,CONTROL_PORT,PIN_HIGH);
    11c0:	84 e0       	ldi	r24, 0x04	; 4
    11c2:	61 e0       	ldi	r22, 0x01	; 1
    11c4:	41 e0       	ldi	r20, 0x01	; 1
    11c6:	0e 94 08 04 	call	0x810	; 0x810 <MDIO_SetPinValue>
	//_delay_ms(2);
	vTaskDelay(2);
    11ca:	82 e0       	ldi	r24, 0x02	; 2
    11cc:	90 e0       	ldi	r25, 0x00	; 0
    11ce:	0e 94 62 17 	call	0x2ec4	; 0x2ec4 <vTaskDelay>
	MDIO_SetPinValue(E,CONTROL_PORT,PIN_LOW);
    11d2:	84 e0       	ldi	r24, 0x04	; 4
    11d4:	61 e0       	ldi	r22, 0x01	; 1
    11d6:	40 e0       	ldi	r20, 0x00	; 0
    11d8:	0e 94 08 04 	call	0x810	; 0x810 <MDIO_SetPinValue>

	//Send The Lower Nibble
	MDIO_SetNibbleValue(HCLCD_PIN_START,DATA_PORT,Copy_u8Data);
    11dc:	84 e0       	ldi	r24, 0x04	; 4
    11de:	60 e0       	ldi	r22, 0x00	; 0
    11e0:	49 81       	ldd	r20, Y+1	; 0x01
    11e2:	0e 94 57 06 	call	0xcae	; 0xcae <MDIO_SetNibbleValue>

	//Send the Falling Edge
	MDIO_SetPinValue(E,CONTROL_PORT,PIN_HIGH);
    11e6:	84 e0       	ldi	r24, 0x04	; 4
    11e8:	61 e0       	ldi	r22, 0x01	; 1
    11ea:	41 e0       	ldi	r20, 0x01	; 1
    11ec:	0e 94 08 04 	call	0x810	; 0x810 <MDIO_SetPinValue>
	//_delay_ms(2);
	vTaskDelay(2);
    11f0:	82 e0       	ldi	r24, 0x02	; 2
    11f2:	90 e0       	ldi	r25, 0x00	; 0
    11f4:	0e 94 62 17 	call	0x2ec4	; 0x2ec4 <vTaskDelay>
	MDIO_SetPinValue(E,CONTROL_PORT,PIN_LOW);
    11f8:	84 e0       	ldi	r24, 0x04	; 4
    11fa:	61 e0       	ldi	r22, 0x01	; 1
    11fc:	40 e0       	ldi	r20, 0x00	; 0
    11fe:	0e 94 08 04 	call	0x810	; 0x810 <MDIO_SetPinValue>
}
    1202:	0f 90       	pop	r0
    1204:	cf 91       	pop	r28
    1206:	df 91       	pop	r29
    1208:	08 95       	ret

0000120a <HCLCD_SetCursorPosition>:

void HCLCD_SetCursorPosition(u8 Copy_u8LineNumber,u8 Copy_u8PositionNumber)
{
    120a:	df 93       	push	r29
    120c:	cf 93       	push	r28
    120e:	00 d0       	rcall	.+0      	; 0x1210 <HCLCD_SetCursorPosition+0x6>
    1210:	cd b7       	in	r28, 0x3d	; 61
    1212:	de b7       	in	r29, 0x3e	; 62
    1214:	89 83       	std	Y+1, r24	; 0x01
    1216:	6a 83       	std	Y+2, r22	; 0x02
	if((Copy_u8LineNumber==HCLCD_LINE_0)||(Copy_u8LineNumber==HCLCD_LINE_1))
    1218:	89 81       	ldd	r24, Y+1	; 0x01
    121a:	88 23       	and	r24, r24
    121c:	19 f0       	breq	.+6      	; 0x1224 <HCLCD_SetCursorPosition+0x1a>
    121e:	89 81       	ldd	r24, Y+1	; 0x01
    1220:	81 30       	cpi	r24, 0x01	; 1
    1222:	79 f4       	brne	.+30     	; 0x1242 <HCLCD_SetCursorPosition+0x38>
	{
		if(Copy_u8PositionNumber<16)
    1224:	8a 81       	ldd	r24, Y+2	; 0x02
    1226:	80 31       	cpi	r24, 0x10	; 16
    1228:	60 f4       	brcc	.+24     	; 0x1242 <HCLCD_SetCursorPosition+0x38>
		{
			if(Copy_u8LineNumber==HCLCD_LINE_0)
    122a:	89 81       	ldd	r24, Y+1	; 0x01
    122c:	88 23       	and	r24, r24
    122e:	29 f4       	brne	.+10     	; 0x123a <HCLCD_SetCursorPosition+0x30>
			{
				HCLCD_WriteCommand4Bit(Copy_u8PositionNumber+HCLCD_LINE0_OFFSET);
    1230:	8a 81       	ldd	r24, Y+2	; 0x02
    1232:	80 58       	subi	r24, 0x80	; 128
    1234:	0e 94 33 08 	call	0x1066	; 0x1066 <HCLCD_WriteCommand4Bit>
    1238:	04 c0       	rjmp	.+8      	; 0x1242 <HCLCD_SetCursorPosition+0x38>
			}
			else
			{
				HCLCD_WriteCommand4Bit(Copy_u8PositionNumber+HCLCD_LINE1_OFFSET);
    123a:	8a 81       	ldd	r24, Y+2	; 0x02
    123c:	80 54       	subi	r24, 0x40	; 64
    123e:	0e 94 33 08 	call	0x1066	; 0x1066 <HCLCD_WriteCommand4Bit>
	}
	else
	{
		//Wrong Line Chosen
	}
}
    1242:	0f 90       	pop	r0
    1244:	0f 90       	pop	r0
    1246:	cf 91       	pop	r28
    1248:	df 91       	pop	r29
    124a:	08 95       	ret

0000124c <HCLCD_WriteNumber>:


void HCLCD_WriteNumber(u32 Copy_u32Number)
{
    124c:	0f 93       	push	r16
    124e:	1f 93       	push	r17
    1250:	df 93       	push	r29
    1252:	cf 93       	push	r28
    1254:	cd b7       	in	r28, 0x3d	; 61
    1256:	de b7       	in	r29, 0x3e	; 62
    1258:	60 97       	sbiw	r28, 0x10	; 16
    125a:	0f b6       	in	r0, 0x3f	; 63
    125c:	f8 94       	cli
    125e:	de bf       	out	0x3e, r29	; 62
    1260:	0f be       	out	0x3f, r0	; 63
    1262:	cd bf       	out	0x3d, r28	; 61
    1264:	6d 87       	std	Y+13, r22	; 0x0d
    1266:	7e 87       	std	Y+14, r23	; 0x0e
    1268:	8f 87       	std	Y+15, r24	; 0x0f
    126a:	98 8b       	std	Y+16, r25	; 0x10
	which is 10 digits
	 */
	u8 Loc_u8Arr_Digits[10];

	/*Define a Local Counter to traverse the array*/
	u8 Loc_Counter=0;
    126c:	1a 82       	std	Y+2, r1	; 0x02

	/*Check on the upcoming number*/
	if(Copy_u32Number>0)
    126e:	8d 85       	ldd	r24, Y+13	; 0x0d
    1270:	9e 85       	ldd	r25, Y+14	; 0x0e
    1272:	af 85       	ldd	r26, Y+15	; 0x0f
    1274:	b8 89       	ldd	r27, Y+16	; 0x10
    1276:	00 97       	sbiw	r24, 0x00	; 0
    1278:	a1 05       	cpc	r26, r1
    127a:	b1 05       	cpc	r27, r1
    127c:	09 f4       	brne	.+2      	; 0x1280 <HCLCD_WriteNumber+0x34>
    127e:	4f c0       	rjmp	.+158    	; 0x131e <HCLCD_WriteNumber+0xd2>
    1280:	2d c0       	rjmp	.+90     	; 0x12dc <HCLCD_WriteNumber+0x90>
		/*Parsing the number into the array*/
		while(Copy_u32Number!=0) //Exit Condition means number is done parsing
		{
			//Extract the Least Significant Digit and Put it in the
			//Array
			Loc_u8Arr_Digits[Loc_Counter]=Copy_u32Number%10 ;
    1282:	8a 81       	ldd	r24, Y+2	; 0x02
    1284:	08 2f       	mov	r16, r24
    1286:	10 e0       	ldi	r17, 0x00	; 0
    1288:	8d 85       	ldd	r24, Y+13	; 0x0d
    128a:	9e 85       	ldd	r25, Y+14	; 0x0e
    128c:	af 85       	ldd	r26, Y+15	; 0x0f
    128e:	b8 89       	ldd	r27, Y+16	; 0x10
    1290:	2a e0       	ldi	r18, 0x0A	; 10
    1292:	30 e0       	ldi	r19, 0x00	; 0
    1294:	40 e0       	ldi	r20, 0x00	; 0
    1296:	50 e0       	ldi	r21, 0x00	; 0
    1298:	bc 01       	movw	r22, r24
    129a:	cd 01       	movw	r24, r26
    129c:	0e 94 ed 1d 	call	0x3bda	; 0x3bda <__udivmodsi4>
    12a0:	dc 01       	movw	r26, r24
    12a2:	cb 01       	movw	r24, r22
    12a4:	28 2f       	mov	r18, r24
    12a6:	ce 01       	movw	r24, r28
    12a8:	03 96       	adiw	r24, 0x03	; 3
    12aa:	fc 01       	movw	r30, r24
    12ac:	e0 0f       	add	r30, r16
    12ae:	f1 1f       	adc	r31, r17
    12b0:	20 83       	st	Z, r18

			//Removing the Extracted digit from the number
			Copy_u32Number=Copy_u32Number/10 ;
    12b2:	8d 85       	ldd	r24, Y+13	; 0x0d
    12b4:	9e 85       	ldd	r25, Y+14	; 0x0e
    12b6:	af 85       	ldd	r26, Y+15	; 0x0f
    12b8:	b8 89       	ldd	r27, Y+16	; 0x10
    12ba:	2a e0       	ldi	r18, 0x0A	; 10
    12bc:	30 e0       	ldi	r19, 0x00	; 0
    12be:	40 e0       	ldi	r20, 0x00	; 0
    12c0:	50 e0       	ldi	r21, 0x00	; 0
    12c2:	bc 01       	movw	r22, r24
    12c4:	cd 01       	movw	r24, r26
    12c6:	0e 94 ed 1d 	call	0x3bda	; 0x3bda <__udivmodsi4>
    12ca:	da 01       	movw	r26, r20
    12cc:	c9 01       	movw	r24, r18
    12ce:	8d 87       	std	Y+13, r24	; 0x0d
    12d0:	9e 87       	std	Y+14, r25	; 0x0e
    12d2:	af 87       	std	Y+15, r26	; 0x0f
    12d4:	b8 8b       	std	Y+16, r27	; 0x10

			//Increasing the counter so the digits are saved in next array element
			Loc_Counter++;
    12d6:	8a 81       	ldd	r24, Y+2	; 0x02
    12d8:	8f 5f       	subi	r24, 0xFF	; 255
    12da:	8a 83       	std	Y+2, r24	; 0x02

	/*Check on the upcoming number*/
	if(Copy_u32Number>0)
	{
		/*Parsing the number into the array*/
		while(Copy_u32Number!=0) //Exit Condition means number is done parsing
    12dc:	8d 85       	ldd	r24, Y+13	; 0x0d
    12de:	9e 85       	ldd	r25, Y+14	; 0x0e
    12e0:	af 85       	ldd	r26, Y+15	; 0x0f
    12e2:	b8 89       	ldd	r27, Y+16	; 0x10
    12e4:	00 97       	sbiw	r24, 0x00	; 0
    12e6:	a1 05       	cpc	r26, r1
    12e8:	b1 05       	cpc	r27, r1
    12ea:	59 f6       	brne	.-106    	; 0x1282 <HCLCD_WriteNumber+0x36>
		//in the array but backwards

		//Take Care Loc_forCounter is signed
		//because we are decrementing it
		s8 Loc_forCounter;
		for(Loc_forCounter=Loc_Counter-1;Loc_forCounter>=0;Loc_forCounter--)
    12ec:	8a 81       	ldd	r24, Y+2	; 0x02
    12ee:	81 50       	subi	r24, 0x01	; 1
    12f0:	89 83       	std	Y+1, r24	; 0x01
    12f2:	11 c0       	rjmp	.+34     	; 0x1316 <HCLCD_WriteNumber+0xca>
		{
			//Write the digits to the screen in their right order
			//Notice the addition of the number to the ASCII Code
			//of the number 0 because our Function takes ASCII of character
			//to Print on the LCD
			HCLCD_WriteChar4Bit(Loc_u8Arr_Digits[Loc_forCounter]+'0');
    12f4:	89 81       	ldd	r24, Y+1	; 0x01
    12f6:	28 2f       	mov	r18, r24
    12f8:	33 27       	eor	r19, r19
    12fa:	27 fd       	sbrc	r18, 7
    12fc:	30 95       	com	r19
    12fe:	ce 01       	movw	r24, r28
    1300:	03 96       	adiw	r24, 0x03	; 3
    1302:	fc 01       	movw	r30, r24
    1304:	e2 0f       	add	r30, r18
    1306:	f3 1f       	adc	r31, r19
    1308:	80 81       	ld	r24, Z
    130a:	80 5d       	subi	r24, 0xD0	; 208
    130c:	0e 94 c7 08 	call	0x118e	; 0x118e <HCLCD_WriteChar4Bit>
		//in the array but backwards

		//Take Care Loc_forCounter is signed
		//because we are decrementing it
		s8 Loc_forCounter;
		for(Loc_forCounter=Loc_Counter-1;Loc_forCounter>=0;Loc_forCounter--)
    1310:	89 81       	ldd	r24, Y+1	; 0x01
    1312:	81 50       	subi	r24, 0x01	; 1
    1314:	89 83       	std	Y+1, r24	; 0x01
    1316:	89 81       	ldd	r24, Y+1	; 0x01
    1318:	88 23       	and	r24, r24
    131a:	64 f7       	brge	.-40     	; 0x12f4 <HCLCD_WriteNumber+0xa8>
    131c:	03 c0       	rjmp	.+6      	; 0x1324 <HCLCD_WriteNumber+0xd8>

	}
	else
	{
		/*if the number is zero so we have to send ASCII Code of Zero*/
		HCLCD_WriteChar4Bit('0');
    131e:	80 e3       	ldi	r24, 0x30	; 48
    1320:	0e 94 c7 08 	call	0x118e	; 0x118e <HCLCD_WriteChar4Bit>
	}

}
    1324:	60 96       	adiw	r28, 0x10	; 16
    1326:	0f b6       	in	r0, 0x3f	; 63
    1328:	f8 94       	cli
    132a:	de bf       	out	0x3e, r29	; 62
    132c:	0f be       	out	0x3f, r0	; 63
    132e:	cd bf       	out	0x3d, r28	; 61
    1330:	cf 91       	pop	r28
    1332:	df 91       	pop	r29
    1334:	1f 91       	pop	r17
    1336:	0f 91       	pop	r16
    1338:	08 95       	ret

0000133a <HCLCD_WriteString>:



void HCLCD_WriteString(u8* P_String)
{
    133a:	df 93       	push	r29
    133c:	cf 93       	push	r28
    133e:	00 d0       	rcall	.+0      	; 0x1340 <HCLCD_WriteString+0x6>
    1340:	0f 92       	push	r0
    1342:	cd b7       	in	r28, 0x3d	; 61
    1344:	de b7       	in	r29, 0x3e	; 62
    1346:	9b 83       	std	Y+3, r25	; 0x03
    1348:	8a 83       	std	Y+2, r24	; 0x02
	if(P_String!=NULL)
    134a:	8a 81       	ldd	r24, Y+2	; 0x02
    134c:	9b 81       	ldd	r25, Y+3	; 0x03
    134e:	00 97       	sbiw	r24, 0x00	; 0
    1350:	e9 f0       	breq	.+58     	; 0x138c <HCLCD_WriteString+0x52>
	{
		u8 Loc_StringCounter=0;
    1352:	19 82       	std	Y+1, r1	; 0x01
    1354:	0e c0       	rjmp	.+28     	; 0x1372 <HCLCD_WriteString+0x38>
		while(P_String[Loc_StringCounter] != NULL)
		{
			HCLCD_WriteChar4Bit(P_String[Loc_StringCounter]);
    1356:	89 81       	ldd	r24, Y+1	; 0x01
    1358:	28 2f       	mov	r18, r24
    135a:	30 e0       	ldi	r19, 0x00	; 0
    135c:	8a 81       	ldd	r24, Y+2	; 0x02
    135e:	9b 81       	ldd	r25, Y+3	; 0x03
    1360:	fc 01       	movw	r30, r24
    1362:	e2 0f       	add	r30, r18
    1364:	f3 1f       	adc	r31, r19
    1366:	80 81       	ld	r24, Z
    1368:	0e 94 c7 08 	call	0x118e	; 0x118e <HCLCD_WriteChar4Bit>
			Loc_StringCounter++;
    136c:	89 81       	ldd	r24, Y+1	; 0x01
    136e:	8f 5f       	subi	r24, 0xFF	; 255
    1370:	89 83       	std	Y+1, r24	; 0x01
void HCLCD_WriteString(u8* P_String)
{
	if(P_String!=NULL)
	{
		u8 Loc_StringCounter=0;
		while(P_String[Loc_StringCounter] != NULL)
    1372:	89 81       	ldd	r24, Y+1	; 0x01
    1374:	28 2f       	mov	r18, r24
    1376:	30 e0       	ldi	r19, 0x00	; 0
    1378:	8a 81       	ldd	r24, Y+2	; 0x02
    137a:	9b 81       	ldd	r25, Y+3	; 0x03
    137c:	fc 01       	movw	r30, r24
    137e:	e2 0f       	add	r30, r18
    1380:	f3 1f       	adc	r31, r19
    1382:	80 81       	ld	r24, Z
    1384:	88 2f       	mov	r24, r24
    1386:	90 e0       	ldi	r25, 0x00	; 0
    1388:	00 97       	sbiw	r24, 0x00	; 0
    138a:	29 f7       	brne	.-54     	; 0x1356 <HCLCD_WriteString+0x1c>
	}
	else
	{
		//Pointer to Null is passed
	}
}
    138c:	0f 90       	pop	r0
    138e:	0f 90       	pop	r0
    1390:	0f 90       	pop	r0
    1392:	cf 91       	pop	r28
    1394:	df 91       	pop	r29
    1396:	08 95       	ret

00001398 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    1398:	df 93       	push	r29
    139a:	cf 93       	push	r28
    139c:	cd b7       	in	r28, 0x3d	; 61
    139e:	de b7       	in	r29, 0x3e	; 62
    13a0:	27 97       	sbiw	r28, 0x07	; 7
    13a2:	0f b6       	in	r0, 0x3f	; 63
    13a4:	f8 94       	cli
    13a6:	de bf       	out	0x3e, r29	; 62
    13a8:	0f be       	out	0x3f, r0	; 63
    13aa:	cd bf       	out	0x3d, r28	; 61
    13ac:	9d 83       	std	Y+5, r25	; 0x05
    13ae:	8c 83       	std	Y+4, r24	; 0x04
    13b0:	6e 83       	std	Y+6, r22	; 0x06
    13b2:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    13b4:	8a e1       	ldi	r24, 0x1A	; 26
    13b6:	90 e0       	ldi	r25, 0x00	; 0
    13b8:	0e 94 a4 0c 	call	0x1948	; 0x1948 <pvPortMalloc>
    13bc:	9a 83       	std	Y+2, r25	; 0x02
    13be:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
    13c0:	89 81       	ldd	r24, Y+1	; 0x01
    13c2:	9a 81       	ldd	r25, Y+2	; 0x02
    13c4:	00 97       	sbiw	r24, 0x00	; 0
    13c6:	09 f4       	brne	.+2      	; 0x13ca <xCoRoutineCreate+0x32>
    13c8:	6f c0       	rjmp	.+222    	; 0x14a8 <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    13ca:	80 91 b4 00 	lds	r24, 0x00B4
    13ce:	90 91 b5 00 	lds	r25, 0x00B5
    13d2:	00 97       	sbiw	r24, 0x00	; 0
    13d4:	41 f4       	brne	.+16     	; 0x13e6 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    13d6:	89 81       	ldd	r24, Y+1	; 0x01
    13d8:	9a 81       	ldd	r25, Y+2	; 0x02
    13da:	90 93 b5 00 	sts	0x00B5, r25
    13de:	80 93 b4 00 	sts	0x00B4, r24
			prvInitialiseCoRoutineLists();
    13e2:	0e 94 33 0c 	call	0x1866	; 0x1866 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    13e6:	8e 81       	ldd	r24, Y+6	; 0x06
    13e8:	82 30       	cpi	r24, 0x02	; 2
    13ea:	10 f0       	brcs	.+4      	; 0x13f0 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    13ec:	81 e0       	ldi	r24, 0x01	; 1
    13ee:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    13f0:	e9 81       	ldd	r30, Y+1	; 0x01
    13f2:	fa 81       	ldd	r31, Y+2	; 0x02
    13f4:	11 8e       	std	Z+25, r1	; 0x19
    13f6:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    13f8:	e9 81       	ldd	r30, Y+1	; 0x01
    13fa:	fa 81       	ldd	r31, Y+2	; 0x02
    13fc:	8e 81       	ldd	r24, Y+6	; 0x06
    13fe:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    1400:	e9 81       	ldd	r30, Y+1	; 0x01
    1402:	fa 81       	ldd	r31, Y+2	; 0x02
    1404:	8f 81       	ldd	r24, Y+7	; 0x07
    1406:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    1408:	e9 81       	ldd	r30, Y+1	; 0x01
    140a:	fa 81       	ldd	r31, Y+2	; 0x02
    140c:	8c 81       	ldd	r24, Y+4	; 0x04
    140e:	9d 81       	ldd	r25, Y+5	; 0x05
    1410:	91 83       	std	Z+1, r25	; 0x01
    1412:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    1414:	89 81       	ldd	r24, Y+1	; 0x01
    1416:	9a 81       	ldd	r25, Y+2	; 0x02
    1418:	02 96       	adiw	r24, 0x02	; 2
    141a:	0e 94 3a 0d 	call	0x1a74	; 0x1a74 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    141e:	89 81       	ldd	r24, Y+1	; 0x01
    1420:	9a 81       	ldd	r25, Y+2	; 0x02
    1422:	0c 96       	adiw	r24, 0x0c	; 12
    1424:	0e 94 3a 0d 	call	0x1a74	; 0x1a74 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    1428:	e9 81       	ldd	r30, Y+1	; 0x01
    142a:	fa 81       	ldd	r31, Y+2	; 0x02
    142c:	89 81       	ldd	r24, Y+1	; 0x01
    142e:	9a 81       	ldd	r25, Y+2	; 0x02
    1430:	91 87       	std	Z+9, r25	; 0x09
    1432:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    1434:	e9 81       	ldd	r30, Y+1	; 0x01
    1436:	fa 81       	ldd	r31, Y+2	; 0x02
    1438:	89 81       	ldd	r24, Y+1	; 0x01
    143a:	9a 81       	ldd	r25, Y+2	; 0x02
    143c:	93 8b       	std	Z+19, r25	; 0x13
    143e:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    1440:	8e 81       	ldd	r24, Y+6	; 0x06
    1442:	28 2f       	mov	r18, r24
    1444:	30 e0       	ldi	r19, 0x00	; 0
    1446:	8a e0       	ldi	r24, 0x0A	; 10
    1448:	90 e0       	ldi	r25, 0x00	; 0
    144a:	82 1b       	sub	r24, r18
    144c:	93 0b       	sbc	r25, r19
    144e:	e9 81       	ldd	r30, Y+1	; 0x01
    1450:	fa 81       	ldd	r31, Y+2	; 0x02
    1452:	95 87       	std	Z+13, r25	; 0x0d
    1454:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    1456:	e9 81       	ldd	r30, Y+1	; 0x01
    1458:	fa 81       	ldd	r31, Y+2	; 0x02
    145a:	96 89       	ldd	r25, Z+22	; 0x16
    145c:	80 91 b6 00 	lds	r24, 0x00B6
    1460:	89 17       	cp	r24, r25
    1462:	28 f4       	brcc	.+10     	; 0x146e <xCoRoutineCreate+0xd6>
    1464:	e9 81       	ldd	r30, Y+1	; 0x01
    1466:	fa 81       	ldd	r31, Y+2	; 0x02
    1468:	86 89       	ldd	r24, Z+22	; 0x16
    146a:	80 93 b6 00 	sts	0x00B6, r24
    146e:	e9 81       	ldd	r30, Y+1	; 0x01
    1470:	fa 81       	ldd	r31, Y+2	; 0x02
    1472:	86 89       	ldd	r24, Z+22	; 0x16
    1474:	28 2f       	mov	r18, r24
    1476:	30 e0       	ldi	r19, 0x00	; 0
    1478:	c9 01       	movw	r24, r18
    147a:	88 0f       	add	r24, r24
    147c:	99 1f       	adc	r25, r25
    147e:	88 0f       	add	r24, r24
    1480:	99 1f       	adc	r25, r25
    1482:	88 0f       	add	r24, r24
    1484:	99 1f       	adc	r25, r25
    1486:	82 0f       	add	r24, r18
    1488:	93 1f       	adc	r25, r19
    148a:	ac 01       	movw	r20, r24
    148c:	43 54       	subi	r20, 0x43	; 67
    148e:	5f 4f       	sbci	r21, 0xFF	; 255
    1490:	89 81       	ldd	r24, Y+1	; 0x01
    1492:	9a 81       	ldd	r25, Y+2	; 0x02
    1494:	9c 01       	movw	r18, r24
    1496:	2e 5f       	subi	r18, 0xFE	; 254
    1498:	3f 4f       	sbci	r19, 0xFF	; 255
    149a:	ca 01       	movw	r24, r20
    149c:	b9 01       	movw	r22, r18
    149e:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <vListInsertEnd>

		xReturn = pdPASS;
    14a2:	81 e0       	ldi	r24, 0x01	; 1
    14a4:	8b 83       	std	Y+3, r24	; 0x03
    14a6:	02 c0       	rjmp	.+4      	; 0x14ac <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    14a8:	8f ef       	ldi	r24, 0xFF	; 255
    14aa:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
    14ac:	8b 81       	ldd	r24, Y+3	; 0x03
}
    14ae:	27 96       	adiw	r28, 0x07	; 7
    14b0:	0f b6       	in	r0, 0x3f	; 63
    14b2:	f8 94       	cli
    14b4:	de bf       	out	0x3e, r29	; 62
    14b6:	0f be       	out	0x3f, r0	; 63
    14b8:	cd bf       	out	0x3d, r28	; 61
    14ba:	cf 91       	pop	r28
    14bc:	df 91       	pop	r29
    14be:	08 95       	ret

000014c0 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    14c0:	df 93       	push	r29
    14c2:	cf 93       	push	r28
    14c4:	00 d0       	rcall	.+0      	; 0x14c6 <vCoRoutineAddToDelayedList+0x6>
    14c6:	00 d0       	rcall	.+0      	; 0x14c8 <vCoRoutineAddToDelayedList+0x8>
    14c8:	00 d0       	rcall	.+0      	; 0x14ca <vCoRoutineAddToDelayedList+0xa>
    14ca:	cd b7       	in	r28, 0x3d	; 61
    14cc:	de b7       	in	r29, 0x3e	; 62
    14ce:	9c 83       	std	Y+4, r25	; 0x04
    14d0:	8b 83       	std	Y+3, r24	; 0x03
    14d2:	7e 83       	std	Y+6, r23	; 0x06
    14d4:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    14d6:	20 91 b7 00 	lds	r18, 0x00B7
    14da:	30 91 b8 00 	lds	r19, 0x00B8
    14de:	8b 81       	ldd	r24, Y+3	; 0x03
    14e0:	9c 81       	ldd	r25, Y+4	; 0x04
    14e2:	82 0f       	add	r24, r18
    14e4:	93 1f       	adc	r25, r19
    14e6:	9a 83       	std	Y+2, r25	; 0x02
    14e8:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    14ea:	80 91 b4 00 	lds	r24, 0x00B4
    14ee:	90 91 b5 00 	lds	r25, 0x00B5
    14f2:	02 96       	adiw	r24, 0x02	; 2
    14f4:	0e 94 02 0e 	call	0x1c04	; 0x1c04 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    14f8:	e0 91 b4 00 	lds	r30, 0x00B4
    14fc:	f0 91 b5 00 	lds	r31, 0x00B5
    1500:	89 81       	ldd	r24, Y+1	; 0x01
    1502:	9a 81       	ldd	r25, Y+2	; 0x02
    1504:	93 83       	std	Z+3, r25	; 0x03
    1506:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    1508:	20 91 b7 00 	lds	r18, 0x00B7
    150c:	30 91 b8 00 	lds	r19, 0x00B8
    1510:	89 81       	ldd	r24, Y+1	; 0x01
    1512:	9a 81       	ldd	r25, Y+2	; 0x02
    1514:	82 17       	cp	r24, r18
    1516:	93 07       	cpc	r25, r19
    1518:	70 f4       	brcc	.+28     	; 0x1536 <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    151a:	80 91 e3 00 	lds	r24, 0x00E3
    151e:	90 91 e4 00 	lds	r25, 0x00E4
    1522:	20 91 b4 00 	lds	r18, 0x00B4
    1526:	30 91 b5 00 	lds	r19, 0x00B5
    152a:	2e 5f       	subi	r18, 0xFE	; 254
    152c:	3f 4f       	sbci	r19, 0xFF	; 255
    152e:	b9 01       	movw	r22, r18
    1530:	0e 94 96 0d 	call	0x1b2c	; 0x1b2c <vListInsert>
    1534:	0d c0       	rjmp	.+26     	; 0x1550 <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1536:	80 91 e1 00 	lds	r24, 0x00E1
    153a:	90 91 e2 00 	lds	r25, 0x00E2
    153e:	20 91 b4 00 	lds	r18, 0x00B4
    1542:	30 91 b5 00 	lds	r19, 0x00B5
    1546:	2e 5f       	subi	r18, 0xFE	; 254
    1548:	3f 4f       	sbci	r19, 0xFF	; 255
    154a:	b9 01       	movw	r22, r18
    154c:	0e 94 96 0d 	call	0x1b2c	; 0x1b2c <vListInsert>
	}

	if( pxEventList )
    1550:	8d 81       	ldd	r24, Y+5	; 0x05
    1552:	9e 81       	ldd	r25, Y+6	; 0x06
    1554:	00 97       	sbiw	r24, 0x00	; 0
    1556:	61 f0       	breq	.+24     	; 0x1570 <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    1558:	80 91 b4 00 	lds	r24, 0x00B4
    155c:	90 91 b5 00 	lds	r25, 0x00B5
    1560:	9c 01       	movw	r18, r24
    1562:	24 5f       	subi	r18, 0xF4	; 244
    1564:	3f 4f       	sbci	r19, 0xFF	; 255
    1566:	8d 81       	ldd	r24, Y+5	; 0x05
    1568:	9e 81       	ldd	r25, Y+6	; 0x06
    156a:	b9 01       	movw	r22, r18
    156c:	0e 94 96 0d 	call	0x1b2c	; 0x1b2c <vListInsert>
	}
}
    1570:	26 96       	adiw	r28, 0x06	; 6
    1572:	0f b6       	in	r0, 0x3f	; 63
    1574:	f8 94       	cli
    1576:	de bf       	out	0x3e, r29	; 62
    1578:	0f be       	out	0x3f, r0	; 63
    157a:	cd bf       	out	0x3d, r28	; 61
    157c:	cf 91       	pop	r28
    157e:	df 91       	pop	r29
    1580:	08 95       	ret

00001582 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
    1582:	df 93       	push	r29
    1584:	cf 93       	push	r28
    1586:	00 d0       	rcall	.+0      	; 0x1588 <prvCheckPendingReadyList+0x6>
    1588:	cd b7       	in	r28, 0x3d	; 61
    158a:	de b7       	in	r29, 0x3e	; 62
    158c:	3a c0       	rjmp	.+116    	; 0x1602 <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    158e:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    1590:	e0 91 ea 00 	lds	r30, 0x00EA
    1594:	f0 91 eb 00 	lds	r31, 0x00EB
    1598:	86 81       	ldd	r24, Z+6	; 0x06
    159a:	97 81       	ldd	r25, Z+7	; 0x07
    159c:	9a 83       	std	Y+2, r25	; 0x02
    159e:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    15a0:	89 81       	ldd	r24, Y+1	; 0x01
    15a2:	9a 81       	ldd	r25, Y+2	; 0x02
    15a4:	0c 96       	adiw	r24, 0x0c	; 12
    15a6:	0e 94 02 0e 	call	0x1c04	; 0x1c04 <vListRemove>
		}
		portENABLE_INTERRUPTS();
    15aa:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    15ac:	89 81       	ldd	r24, Y+1	; 0x01
    15ae:	9a 81       	ldd	r25, Y+2	; 0x02
    15b0:	02 96       	adiw	r24, 0x02	; 2
    15b2:	0e 94 02 0e 	call	0x1c04	; 0x1c04 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    15b6:	e9 81       	ldd	r30, Y+1	; 0x01
    15b8:	fa 81       	ldd	r31, Y+2	; 0x02
    15ba:	96 89       	ldd	r25, Z+22	; 0x16
    15bc:	80 91 b6 00 	lds	r24, 0x00B6
    15c0:	89 17       	cp	r24, r25
    15c2:	28 f4       	brcc	.+10     	; 0x15ce <prvCheckPendingReadyList+0x4c>
    15c4:	e9 81       	ldd	r30, Y+1	; 0x01
    15c6:	fa 81       	ldd	r31, Y+2	; 0x02
    15c8:	86 89       	ldd	r24, Z+22	; 0x16
    15ca:	80 93 b6 00 	sts	0x00B6, r24
    15ce:	e9 81       	ldd	r30, Y+1	; 0x01
    15d0:	fa 81       	ldd	r31, Y+2	; 0x02
    15d2:	86 89       	ldd	r24, Z+22	; 0x16
    15d4:	28 2f       	mov	r18, r24
    15d6:	30 e0       	ldi	r19, 0x00	; 0
    15d8:	c9 01       	movw	r24, r18
    15da:	88 0f       	add	r24, r24
    15dc:	99 1f       	adc	r25, r25
    15de:	88 0f       	add	r24, r24
    15e0:	99 1f       	adc	r25, r25
    15e2:	88 0f       	add	r24, r24
    15e4:	99 1f       	adc	r25, r25
    15e6:	82 0f       	add	r24, r18
    15e8:	93 1f       	adc	r25, r19
    15ea:	ac 01       	movw	r20, r24
    15ec:	43 54       	subi	r20, 0x43	; 67
    15ee:	5f 4f       	sbci	r21, 0xFF	; 255
    15f0:	89 81       	ldd	r24, Y+1	; 0x01
    15f2:	9a 81       	ldd	r25, Y+2	; 0x02
    15f4:	9c 01       	movw	r18, r24
    15f6:	2e 5f       	subi	r18, 0xFE	; 254
    15f8:	3f 4f       	sbci	r19, 0xFF	; 255
    15fa:	ca 01       	movw	r24, r20
    15fc:	b9 01       	movw	r22, r18
    15fe:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    1602:	80 91 e5 00 	lds	r24, 0x00E5
    1606:	88 23       	and	r24, r24
    1608:	09 f0       	breq	.+2      	; 0x160c <prvCheckPendingReadyList+0x8a>
    160a:	c1 cf       	rjmp	.-126    	; 0x158e <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
    160c:	0f 90       	pop	r0
    160e:	0f 90       	pop	r0
    1610:	cf 91       	pop	r28
    1612:	df 91       	pop	r29
    1614:	08 95       	ret

00001616 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
    1616:	df 93       	push	r29
    1618:	cf 93       	push	r28
    161a:	00 d0       	rcall	.+0      	; 0x161c <prvCheckDelayedList+0x6>
    161c:	00 d0       	rcall	.+0      	; 0x161e <prvCheckDelayedList+0x8>
    161e:	cd b7       	in	r28, 0x3d	; 61
    1620:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    1622:	0e 94 70 18 	call	0x30e0	; 0x30e0 <xTaskGetTickCount>
    1626:	20 91 b9 00 	lds	r18, 0x00B9
    162a:	30 91 ba 00 	lds	r19, 0x00BA
    162e:	82 1b       	sub	r24, r18
    1630:	93 0b       	sbc	r25, r19
    1632:	90 93 bc 00 	sts	0x00BC, r25
    1636:	80 93 bb 00 	sts	0x00BB, r24
    163a:	85 c0       	rjmp	.+266    	; 0x1746 <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    163c:	80 91 b7 00 	lds	r24, 0x00B7
    1640:	90 91 b8 00 	lds	r25, 0x00B8
    1644:	01 96       	adiw	r24, 0x01	; 1
    1646:	90 93 b8 00 	sts	0x00B8, r25
    164a:	80 93 b7 00 	sts	0x00B7, r24
		xPassedTicks--;
    164e:	80 91 bb 00 	lds	r24, 0x00BB
    1652:	90 91 bc 00 	lds	r25, 0x00BC
    1656:	01 97       	sbiw	r24, 0x01	; 1
    1658:	90 93 bc 00 	sts	0x00BC, r25
    165c:	80 93 bb 00 	sts	0x00BB, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    1660:	80 91 b7 00 	lds	r24, 0x00B7
    1664:	90 91 b8 00 	lds	r25, 0x00B8
    1668:	00 97       	sbiw	r24, 0x00	; 0
    166a:	09 f0       	breq	.+2      	; 0x166e <prvCheckDelayedList+0x58>
    166c:	64 c0       	rjmp	.+200    	; 0x1736 <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    166e:	80 91 e1 00 	lds	r24, 0x00E1
    1672:	90 91 e2 00 	lds	r25, 0x00E2
    1676:	9a 83       	std	Y+2, r25	; 0x02
    1678:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    167a:	80 91 e3 00 	lds	r24, 0x00E3
    167e:	90 91 e4 00 	lds	r25, 0x00E4
    1682:	90 93 e2 00 	sts	0x00E2, r25
    1686:	80 93 e1 00 	sts	0x00E1, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    168a:	89 81       	ldd	r24, Y+1	; 0x01
    168c:	9a 81       	ldd	r25, Y+2	; 0x02
    168e:	90 93 e4 00 	sts	0x00E4, r25
    1692:	80 93 e3 00 	sts	0x00E3, r24
    1696:	4f c0       	rjmp	.+158    	; 0x1736 <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    1698:	e0 91 e1 00 	lds	r30, 0x00E1
    169c:	f0 91 e2 00 	lds	r31, 0x00E2
    16a0:	05 80       	ldd	r0, Z+5	; 0x05
    16a2:	f6 81       	ldd	r31, Z+6	; 0x06
    16a4:	e0 2d       	mov	r30, r0
    16a6:	86 81       	ldd	r24, Z+6	; 0x06
    16a8:	97 81       	ldd	r25, Z+7	; 0x07
    16aa:	9c 83       	std	Y+4, r25	; 0x04
    16ac:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    16ae:	eb 81       	ldd	r30, Y+3	; 0x03
    16b0:	fc 81       	ldd	r31, Y+4	; 0x04
    16b2:	22 81       	ldd	r18, Z+2	; 0x02
    16b4:	33 81       	ldd	r19, Z+3	; 0x03
    16b6:	80 91 b7 00 	lds	r24, 0x00B7
    16ba:	90 91 b8 00 	lds	r25, 0x00B8
    16be:	82 17       	cp	r24, r18
    16c0:	93 07       	cpc	r25, r19
    16c2:	08 f4       	brcc	.+2      	; 0x16c6 <prvCheckDelayedList+0xb0>
    16c4:	40 c0       	rjmp	.+128    	; 0x1746 <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    16c6:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    16c8:	8b 81       	ldd	r24, Y+3	; 0x03
    16ca:	9c 81       	ldd	r25, Y+4	; 0x04
    16cc:	02 96       	adiw	r24, 0x02	; 2
    16ce:	0e 94 02 0e 	call	0x1c04	; 0x1c04 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    16d2:	eb 81       	ldd	r30, Y+3	; 0x03
    16d4:	fc 81       	ldd	r31, Y+4	; 0x04
    16d6:	84 89       	ldd	r24, Z+20	; 0x14
    16d8:	95 89       	ldd	r25, Z+21	; 0x15
    16da:	00 97       	sbiw	r24, 0x00	; 0
    16dc:	29 f0       	breq	.+10     	; 0x16e8 <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    16de:	8b 81       	ldd	r24, Y+3	; 0x03
    16e0:	9c 81       	ldd	r25, Y+4	; 0x04
    16e2:	0c 96       	adiw	r24, 0x0c	; 12
    16e4:	0e 94 02 0e 	call	0x1c04	; 0x1c04 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    16e8:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    16ea:	eb 81       	ldd	r30, Y+3	; 0x03
    16ec:	fc 81       	ldd	r31, Y+4	; 0x04
    16ee:	96 89       	ldd	r25, Z+22	; 0x16
    16f0:	80 91 b6 00 	lds	r24, 0x00B6
    16f4:	89 17       	cp	r24, r25
    16f6:	28 f4       	brcc	.+10     	; 0x1702 <prvCheckDelayedList+0xec>
    16f8:	eb 81       	ldd	r30, Y+3	; 0x03
    16fa:	fc 81       	ldd	r31, Y+4	; 0x04
    16fc:	86 89       	ldd	r24, Z+22	; 0x16
    16fe:	80 93 b6 00 	sts	0x00B6, r24
    1702:	eb 81       	ldd	r30, Y+3	; 0x03
    1704:	fc 81       	ldd	r31, Y+4	; 0x04
    1706:	86 89       	ldd	r24, Z+22	; 0x16
    1708:	28 2f       	mov	r18, r24
    170a:	30 e0       	ldi	r19, 0x00	; 0
    170c:	c9 01       	movw	r24, r18
    170e:	88 0f       	add	r24, r24
    1710:	99 1f       	adc	r25, r25
    1712:	88 0f       	add	r24, r24
    1714:	99 1f       	adc	r25, r25
    1716:	88 0f       	add	r24, r24
    1718:	99 1f       	adc	r25, r25
    171a:	82 0f       	add	r24, r18
    171c:	93 1f       	adc	r25, r19
    171e:	ac 01       	movw	r20, r24
    1720:	43 54       	subi	r20, 0x43	; 67
    1722:	5f 4f       	sbci	r21, 0xFF	; 255
    1724:	8b 81       	ldd	r24, Y+3	; 0x03
    1726:	9c 81       	ldd	r25, Y+4	; 0x04
    1728:	9c 01       	movw	r18, r24
    172a:	2e 5f       	subi	r18, 0xFE	; 254
    172c:	3f 4f       	sbci	r19, 0xFF	; 255
    172e:	ca 01       	movw	r24, r20
    1730:	b9 01       	movw	r22, r18
    1732:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    1736:	e0 91 e1 00 	lds	r30, 0x00E1
    173a:	f0 91 e2 00 	lds	r31, 0x00E2
    173e:	80 81       	ld	r24, Z
    1740:	88 23       	and	r24, r24
    1742:	09 f0       	breq	.+2      	; 0x1746 <prvCheckDelayedList+0x130>
    1744:	a9 cf       	rjmp	.-174    	; 0x1698 <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    1746:	80 91 bb 00 	lds	r24, 0x00BB
    174a:	90 91 bc 00 	lds	r25, 0x00BC
    174e:	00 97       	sbiw	r24, 0x00	; 0
    1750:	09 f0       	breq	.+2      	; 0x1754 <prvCheckDelayedList+0x13e>
    1752:	74 cf       	rjmp	.-280    	; 0x163c <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    1754:	80 91 b7 00 	lds	r24, 0x00B7
    1758:	90 91 b8 00 	lds	r25, 0x00B8
    175c:	90 93 ba 00 	sts	0x00BA, r25
    1760:	80 93 b9 00 	sts	0x00B9, r24
}
    1764:	0f 90       	pop	r0
    1766:	0f 90       	pop	r0
    1768:	0f 90       	pop	r0
    176a:	0f 90       	pop	r0
    176c:	cf 91       	pop	r28
    176e:	df 91       	pop	r29
    1770:	08 95       	ret

00001772 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    1772:	df 93       	push	r29
    1774:	cf 93       	push	r28
    1776:	00 d0       	rcall	.+0      	; 0x1778 <vCoRoutineSchedule+0x6>
    1778:	cd b7       	in	r28, 0x3d	; 61
    177a:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    177c:	0e 94 c1 0a 	call	0x1582	; 0x1582 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    1780:	0e 94 0b 0b 	call	0x1616	; 0x1616 <prvCheckDelayedList>
    1784:	0a c0       	rjmp	.+20     	; 0x179a <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    1786:	80 91 b6 00 	lds	r24, 0x00B6
    178a:	88 23       	and	r24, r24
    178c:	09 f4       	brne	.+2      	; 0x1790 <vCoRoutineSchedule+0x1e>
    178e:	66 c0       	rjmp	.+204    	; 0x185c <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    1790:	80 91 b6 00 	lds	r24, 0x00B6
    1794:	81 50       	subi	r24, 0x01	; 1
    1796:	80 93 b6 00 	sts	0x00B6, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    179a:	80 91 b6 00 	lds	r24, 0x00B6
    179e:	28 2f       	mov	r18, r24
    17a0:	30 e0       	ldi	r19, 0x00	; 0
    17a2:	c9 01       	movw	r24, r18
    17a4:	88 0f       	add	r24, r24
    17a6:	99 1f       	adc	r25, r25
    17a8:	88 0f       	add	r24, r24
    17aa:	99 1f       	adc	r25, r25
    17ac:	88 0f       	add	r24, r24
    17ae:	99 1f       	adc	r25, r25
    17b0:	82 0f       	add	r24, r18
    17b2:	93 1f       	adc	r25, r19
    17b4:	fc 01       	movw	r30, r24
    17b6:	e3 54       	subi	r30, 0x43	; 67
    17b8:	ff 4f       	sbci	r31, 0xFF	; 255
    17ba:	80 81       	ld	r24, Z
    17bc:	88 23       	and	r24, r24
    17be:	19 f3       	breq	.-58     	; 0x1786 <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    17c0:	80 91 b6 00 	lds	r24, 0x00B6
    17c4:	28 2f       	mov	r18, r24
    17c6:	30 e0       	ldi	r19, 0x00	; 0
    17c8:	c9 01       	movw	r24, r18
    17ca:	88 0f       	add	r24, r24
    17cc:	99 1f       	adc	r25, r25
    17ce:	88 0f       	add	r24, r24
    17d0:	99 1f       	adc	r25, r25
    17d2:	88 0f       	add	r24, r24
    17d4:	99 1f       	adc	r25, r25
    17d6:	82 0f       	add	r24, r18
    17d8:	93 1f       	adc	r25, r19
    17da:	83 54       	subi	r24, 0x43	; 67
    17dc:	9f 4f       	sbci	r25, 0xFF	; 255
    17de:	9a 83       	std	Y+2, r25	; 0x02
    17e0:	89 83       	std	Y+1, r24	; 0x01
    17e2:	e9 81       	ldd	r30, Y+1	; 0x01
    17e4:	fa 81       	ldd	r31, Y+2	; 0x02
    17e6:	01 80       	ldd	r0, Z+1	; 0x01
    17e8:	f2 81       	ldd	r31, Z+2	; 0x02
    17ea:	e0 2d       	mov	r30, r0
    17ec:	82 81       	ldd	r24, Z+2	; 0x02
    17ee:	93 81       	ldd	r25, Z+3	; 0x03
    17f0:	e9 81       	ldd	r30, Y+1	; 0x01
    17f2:	fa 81       	ldd	r31, Y+2	; 0x02
    17f4:	92 83       	std	Z+2, r25	; 0x02
    17f6:	81 83       	std	Z+1, r24	; 0x01
    17f8:	e9 81       	ldd	r30, Y+1	; 0x01
    17fa:	fa 81       	ldd	r31, Y+2	; 0x02
    17fc:	21 81       	ldd	r18, Z+1	; 0x01
    17fe:	32 81       	ldd	r19, Z+2	; 0x02
    1800:	89 81       	ldd	r24, Y+1	; 0x01
    1802:	9a 81       	ldd	r25, Y+2	; 0x02
    1804:	03 96       	adiw	r24, 0x03	; 3
    1806:	28 17       	cp	r18, r24
    1808:	39 07       	cpc	r19, r25
    180a:	59 f4       	brne	.+22     	; 0x1822 <vCoRoutineSchedule+0xb0>
    180c:	e9 81       	ldd	r30, Y+1	; 0x01
    180e:	fa 81       	ldd	r31, Y+2	; 0x02
    1810:	01 80       	ldd	r0, Z+1	; 0x01
    1812:	f2 81       	ldd	r31, Z+2	; 0x02
    1814:	e0 2d       	mov	r30, r0
    1816:	82 81       	ldd	r24, Z+2	; 0x02
    1818:	93 81       	ldd	r25, Z+3	; 0x03
    181a:	e9 81       	ldd	r30, Y+1	; 0x01
    181c:	fa 81       	ldd	r31, Y+2	; 0x02
    181e:	92 83       	std	Z+2, r25	; 0x02
    1820:	81 83       	std	Z+1, r24	; 0x01
    1822:	e9 81       	ldd	r30, Y+1	; 0x01
    1824:	fa 81       	ldd	r31, Y+2	; 0x02
    1826:	01 80       	ldd	r0, Z+1	; 0x01
    1828:	f2 81       	ldd	r31, Z+2	; 0x02
    182a:	e0 2d       	mov	r30, r0
    182c:	86 81       	ldd	r24, Z+6	; 0x06
    182e:	97 81       	ldd	r25, Z+7	; 0x07
    1830:	90 93 b5 00 	sts	0x00B5, r25
    1834:	80 93 b4 00 	sts	0x00B4, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    1838:	e0 91 b4 00 	lds	r30, 0x00B4
    183c:	f0 91 b5 00 	lds	r31, 0x00B5
    1840:	40 81       	ld	r20, Z
    1842:	51 81       	ldd	r21, Z+1	; 0x01
    1844:	80 91 b4 00 	lds	r24, 0x00B4
    1848:	90 91 b5 00 	lds	r25, 0x00B5
    184c:	e0 91 b4 00 	lds	r30, 0x00B4
    1850:	f0 91 b5 00 	lds	r31, 0x00B5
    1854:	27 89       	ldd	r18, Z+23	; 0x17
    1856:	62 2f       	mov	r22, r18
    1858:	fa 01       	movw	r30, r20
    185a:	09 95       	icall

	return;
}
    185c:	0f 90       	pop	r0
    185e:	0f 90       	pop	r0
    1860:	cf 91       	pop	r28
    1862:	df 91       	pop	r29
    1864:	08 95       	ret

00001866 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    1866:	df 93       	push	r29
    1868:	cf 93       	push	r28
    186a:	0f 92       	push	r0
    186c:	cd b7       	in	r28, 0x3d	; 61
    186e:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    1870:	19 82       	std	Y+1, r1	; 0x01
    1872:	13 c0       	rjmp	.+38     	; 0x189a <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    1874:	89 81       	ldd	r24, Y+1	; 0x01
    1876:	28 2f       	mov	r18, r24
    1878:	30 e0       	ldi	r19, 0x00	; 0
    187a:	c9 01       	movw	r24, r18
    187c:	88 0f       	add	r24, r24
    187e:	99 1f       	adc	r25, r25
    1880:	88 0f       	add	r24, r24
    1882:	99 1f       	adc	r25, r25
    1884:	88 0f       	add	r24, r24
    1886:	99 1f       	adc	r25, r25
    1888:	82 0f       	add	r24, r18
    188a:	93 1f       	adc	r25, r19
    188c:	83 54       	subi	r24, 0x43	; 67
    188e:	9f 4f       	sbci	r25, 0xFF	; 255
    1890:	0e 94 10 0d 	call	0x1a20	; 0x1a20 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    1894:	89 81       	ldd	r24, Y+1	; 0x01
    1896:	8f 5f       	subi	r24, 0xFF	; 255
    1898:	89 83       	std	Y+1, r24	; 0x01
    189a:	89 81       	ldd	r24, Y+1	; 0x01
    189c:	82 30       	cpi	r24, 0x02	; 2
    189e:	50 f3       	brcs	.-44     	; 0x1874 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    18a0:	8f ec       	ldi	r24, 0xCF	; 207
    18a2:	90 e0       	ldi	r25, 0x00	; 0
    18a4:	0e 94 10 0d 	call	0x1a20	; 0x1a20 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    18a8:	88 ed       	ldi	r24, 0xD8	; 216
    18aa:	90 e0       	ldi	r25, 0x00	; 0
    18ac:	0e 94 10 0d 	call	0x1a20	; 0x1a20 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    18b0:	85 ee       	ldi	r24, 0xE5	; 229
    18b2:	90 e0       	ldi	r25, 0x00	; 0
    18b4:	0e 94 10 0d 	call	0x1a20	; 0x1a20 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    18b8:	8f ec       	ldi	r24, 0xCF	; 207
    18ba:	90 e0       	ldi	r25, 0x00	; 0
    18bc:	90 93 e2 00 	sts	0x00E2, r25
    18c0:	80 93 e1 00 	sts	0x00E1, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    18c4:	88 ed       	ldi	r24, 0xD8	; 216
    18c6:	90 e0       	ldi	r25, 0x00	; 0
    18c8:	90 93 e4 00 	sts	0x00E4, r25
    18cc:	80 93 e3 00 	sts	0x00E3, r24
}
    18d0:	0f 90       	pop	r0
    18d2:	cf 91       	pop	r28
    18d4:	df 91       	pop	r29
    18d6:	08 95       	ret

000018d8 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    18d8:	df 93       	push	r29
    18da:	cf 93       	push	r28
    18dc:	00 d0       	rcall	.+0      	; 0x18de <xCoRoutineRemoveFromEventList+0x6>
    18de:	00 d0       	rcall	.+0      	; 0x18e0 <xCoRoutineRemoveFromEventList+0x8>
    18e0:	0f 92       	push	r0
    18e2:	cd b7       	in	r28, 0x3d	; 61
    18e4:	de b7       	in	r29, 0x3e	; 62
    18e6:	9d 83       	std	Y+5, r25	; 0x05
    18e8:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    18ea:	ec 81       	ldd	r30, Y+4	; 0x04
    18ec:	fd 81       	ldd	r31, Y+5	; 0x05
    18ee:	05 80       	ldd	r0, Z+5	; 0x05
    18f0:	f6 81       	ldd	r31, Z+6	; 0x06
    18f2:	e0 2d       	mov	r30, r0
    18f4:	86 81       	ldd	r24, Z+6	; 0x06
    18f6:	97 81       	ldd	r25, Z+7	; 0x07
    18f8:	9b 83       	std	Y+3, r25	; 0x03
    18fa:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    18fc:	8a 81       	ldd	r24, Y+2	; 0x02
    18fe:	9b 81       	ldd	r25, Y+3	; 0x03
    1900:	0c 96       	adiw	r24, 0x0c	; 12
    1902:	0e 94 02 0e 	call	0x1c04	; 0x1c04 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    1906:	8a 81       	ldd	r24, Y+2	; 0x02
    1908:	9b 81       	ldd	r25, Y+3	; 0x03
    190a:	9c 01       	movw	r18, r24
    190c:	24 5f       	subi	r18, 0xF4	; 244
    190e:	3f 4f       	sbci	r19, 0xFF	; 255
    1910:	85 ee       	ldi	r24, 0xE5	; 229
    1912:	90 e0       	ldi	r25, 0x00	; 0
    1914:	b9 01       	movw	r22, r18
    1916:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    191a:	ea 81       	ldd	r30, Y+2	; 0x02
    191c:	fb 81       	ldd	r31, Y+3	; 0x03
    191e:	96 89       	ldd	r25, Z+22	; 0x16
    1920:	e0 91 b4 00 	lds	r30, 0x00B4
    1924:	f0 91 b5 00 	lds	r31, 0x00B5
    1928:	86 89       	ldd	r24, Z+22	; 0x16
    192a:	98 17       	cp	r25, r24
    192c:	18 f0       	brcs	.+6      	; 0x1934 <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    192e:	81 e0       	ldi	r24, 0x01	; 1
    1930:	89 83       	std	Y+1, r24	; 0x01
    1932:	01 c0       	rjmp	.+2      	; 0x1936 <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    1934:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    1936:	89 81       	ldd	r24, Y+1	; 0x01
}
    1938:	0f 90       	pop	r0
    193a:	0f 90       	pop	r0
    193c:	0f 90       	pop	r0
    193e:	0f 90       	pop	r0
    1940:	0f 90       	pop	r0
    1942:	cf 91       	pop	r28
    1944:	df 91       	pop	r29
    1946:	08 95       	ret

00001948 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1948:	df 93       	push	r29
    194a:	cf 93       	push	r28
    194c:	00 d0       	rcall	.+0      	; 0x194e <pvPortMalloc+0x6>
    194e:	00 d0       	rcall	.+0      	; 0x1950 <pvPortMalloc+0x8>
    1950:	cd b7       	in	r28, 0x3d	; 61
    1952:	de b7       	in	r29, 0x3e	; 62
    1954:	9c 83       	std	Y+4, r25	; 0x04
    1956:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
    1958:	1a 82       	std	Y+2, r1	; 0x02
    195a:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    195c:	0e 94 da 17 	call	0x2fb4	; 0x2fb4 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    1960:	80 91 ee 00 	lds	r24, 0x00EE
    1964:	90 91 ef 00 	lds	r25, 0x00EF
    1968:	2b 81       	ldd	r18, Y+3	; 0x03
    196a:	3c 81       	ldd	r19, Y+4	; 0x04
    196c:	82 0f       	add	r24, r18
    196e:	93 1f       	adc	r25, r19
    1970:	23 e0       	ldi	r18, 0x03	; 3
    1972:	88 3e       	cpi	r24, 0xE8	; 232
    1974:	92 07       	cpc	r25, r18
    1976:	18 f5       	brcc	.+70     	; 0x19be <pvPortMalloc+0x76>
    1978:	20 91 ee 00 	lds	r18, 0x00EE
    197c:	30 91 ef 00 	lds	r19, 0x00EF
    1980:	8b 81       	ldd	r24, Y+3	; 0x03
    1982:	9c 81       	ldd	r25, Y+4	; 0x04
    1984:	28 0f       	add	r18, r24
    1986:	39 1f       	adc	r19, r25
    1988:	80 91 ee 00 	lds	r24, 0x00EE
    198c:	90 91 ef 00 	lds	r25, 0x00EF
    1990:	82 17       	cp	r24, r18
    1992:	93 07       	cpc	r25, r19
    1994:	a0 f4       	brcc	.+40     	; 0x19be <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    1996:	80 91 ee 00 	lds	r24, 0x00EE
    199a:	90 91 ef 00 	lds	r25, 0x00EF
    199e:	80 51       	subi	r24, 0x10	; 16
    19a0:	9f 4f       	sbci	r25, 0xFF	; 255
    19a2:	9a 83       	std	Y+2, r25	; 0x02
    19a4:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
    19a6:	20 91 ee 00 	lds	r18, 0x00EE
    19aa:	30 91 ef 00 	lds	r19, 0x00EF
    19ae:	8b 81       	ldd	r24, Y+3	; 0x03
    19b0:	9c 81       	ldd	r25, Y+4	; 0x04
    19b2:	82 0f       	add	r24, r18
    19b4:	93 1f       	adc	r25, r19
    19b6:	90 93 ef 00 	sts	0x00EF, r25
    19ba:	80 93 ee 00 	sts	0x00EE, r24
		}	
	}
	xTaskResumeAll();
    19be:	0e 94 e6 17 	call	0x2fcc	; 0x2fcc <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
    19c2:	89 81       	ldd	r24, Y+1	; 0x01
    19c4:	9a 81       	ldd	r25, Y+2	; 0x02
}
    19c6:	0f 90       	pop	r0
    19c8:	0f 90       	pop	r0
    19ca:	0f 90       	pop	r0
    19cc:	0f 90       	pop	r0
    19ce:	cf 91       	pop	r28
    19d0:	df 91       	pop	r29
    19d2:	08 95       	ret

000019d4 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    19d4:	df 93       	push	r29
    19d6:	cf 93       	push	r28
    19d8:	00 d0       	rcall	.+0      	; 0x19da <vPortFree+0x6>
    19da:	cd b7       	in	r28, 0x3d	; 61
    19dc:	de b7       	in	r29, 0x3e	; 62
    19de:	9a 83       	std	Y+2, r25	; 0x02
    19e0:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    19e2:	0f 90       	pop	r0
    19e4:	0f 90       	pop	r0
    19e6:	cf 91       	pop	r28
    19e8:	df 91       	pop	r29
    19ea:	08 95       	ret

000019ec <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    19ec:	df 93       	push	r29
    19ee:	cf 93       	push	r28
    19f0:	cd b7       	in	r28, 0x3d	; 61
    19f2:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    19f4:	10 92 ef 00 	sts	0x00EF, r1
    19f8:	10 92 ee 00 	sts	0x00EE, r1
}
    19fc:	cf 91       	pop	r28
    19fe:	df 91       	pop	r29
    1a00:	08 95       	ret

00001a02 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    1a02:	df 93       	push	r29
    1a04:	cf 93       	push	r28
    1a06:	cd b7       	in	r28, 0x3d	; 61
    1a08:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    1a0a:	20 91 ee 00 	lds	r18, 0x00EE
    1a0e:	30 91 ef 00 	lds	r19, 0x00EF
    1a12:	88 ee       	ldi	r24, 0xE8	; 232
    1a14:	93 e0       	ldi	r25, 0x03	; 3
    1a16:	82 1b       	sub	r24, r18
    1a18:	93 0b       	sbc	r25, r19
}
    1a1a:	cf 91       	pop	r28
    1a1c:	df 91       	pop	r29
    1a1e:	08 95       	ret

00001a20 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    1a20:	df 93       	push	r29
    1a22:	cf 93       	push	r28
    1a24:	00 d0       	rcall	.+0      	; 0x1a26 <vListInitialise+0x6>
    1a26:	cd b7       	in	r28, 0x3d	; 61
    1a28:	de b7       	in	r29, 0x3e	; 62
    1a2a:	9a 83       	std	Y+2, r25	; 0x02
    1a2c:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    1a2e:	89 81       	ldd	r24, Y+1	; 0x01
    1a30:	9a 81       	ldd	r25, Y+2	; 0x02
    1a32:	03 96       	adiw	r24, 0x03	; 3
    1a34:	e9 81       	ldd	r30, Y+1	; 0x01
    1a36:	fa 81       	ldd	r31, Y+2	; 0x02
    1a38:	92 83       	std	Z+2, r25	; 0x02
    1a3a:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1a3c:	e9 81       	ldd	r30, Y+1	; 0x01
    1a3e:	fa 81       	ldd	r31, Y+2	; 0x02
    1a40:	8f ef       	ldi	r24, 0xFF	; 255
    1a42:	9f ef       	ldi	r25, 0xFF	; 255
    1a44:	94 83       	std	Z+4, r25	; 0x04
    1a46:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1a48:	89 81       	ldd	r24, Y+1	; 0x01
    1a4a:	9a 81       	ldd	r25, Y+2	; 0x02
    1a4c:	03 96       	adiw	r24, 0x03	; 3
    1a4e:	e9 81       	ldd	r30, Y+1	; 0x01
    1a50:	fa 81       	ldd	r31, Y+2	; 0x02
    1a52:	96 83       	std	Z+6, r25	; 0x06
    1a54:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1a56:	89 81       	ldd	r24, Y+1	; 0x01
    1a58:	9a 81       	ldd	r25, Y+2	; 0x02
    1a5a:	03 96       	adiw	r24, 0x03	; 3
    1a5c:	e9 81       	ldd	r30, Y+1	; 0x01
    1a5e:	fa 81       	ldd	r31, Y+2	; 0x02
    1a60:	90 87       	std	Z+8, r25	; 0x08
    1a62:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    1a64:	e9 81       	ldd	r30, Y+1	; 0x01
    1a66:	fa 81       	ldd	r31, Y+2	; 0x02
    1a68:	10 82       	st	Z, r1
}
    1a6a:	0f 90       	pop	r0
    1a6c:	0f 90       	pop	r0
    1a6e:	cf 91       	pop	r28
    1a70:	df 91       	pop	r29
    1a72:	08 95       	ret

00001a74 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    1a74:	df 93       	push	r29
    1a76:	cf 93       	push	r28
    1a78:	00 d0       	rcall	.+0      	; 0x1a7a <vListInitialiseItem+0x6>
    1a7a:	cd b7       	in	r28, 0x3d	; 61
    1a7c:	de b7       	in	r29, 0x3e	; 62
    1a7e:	9a 83       	std	Y+2, r25	; 0x02
    1a80:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1a82:	e9 81       	ldd	r30, Y+1	; 0x01
    1a84:	fa 81       	ldd	r31, Y+2	; 0x02
    1a86:	11 86       	std	Z+9, r1	; 0x09
    1a88:	10 86       	std	Z+8, r1	; 0x08
}
    1a8a:	0f 90       	pop	r0
    1a8c:	0f 90       	pop	r0
    1a8e:	cf 91       	pop	r28
    1a90:	df 91       	pop	r29
    1a92:	08 95       	ret

00001a94 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1a94:	df 93       	push	r29
    1a96:	cf 93       	push	r28
    1a98:	00 d0       	rcall	.+0      	; 0x1a9a <vListInsertEnd+0x6>
    1a9a:	00 d0       	rcall	.+0      	; 0x1a9c <vListInsertEnd+0x8>
    1a9c:	00 d0       	rcall	.+0      	; 0x1a9e <vListInsertEnd+0xa>
    1a9e:	cd b7       	in	r28, 0x3d	; 61
    1aa0:	de b7       	in	r29, 0x3e	; 62
    1aa2:	9c 83       	std	Y+4, r25	; 0x04
    1aa4:	8b 83       	std	Y+3, r24	; 0x03
    1aa6:	7e 83       	std	Y+6, r23	; 0x06
    1aa8:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1aaa:	eb 81       	ldd	r30, Y+3	; 0x03
    1aac:	fc 81       	ldd	r31, Y+4	; 0x04
    1aae:	81 81       	ldd	r24, Z+1	; 0x01
    1ab0:	92 81       	ldd	r25, Z+2	; 0x02
    1ab2:	9a 83       	std	Y+2, r25	; 0x02
    1ab4:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
    1ab6:	e9 81       	ldd	r30, Y+1	; 0x01
    1ab8:	fa 81       	ldd	r31, Y+2	; 0x02
    1aba:	82 81       	ldd	r24, Z+2	; 0x02
    1abc:	93 81       	ldd	r25, Z+3	; 0x03
    1abe:	ed 81       	ldd	r30, Y+5	; 0x05
    1ac0:	fe 81       	ldd	r31, Y+6	; 0x06
    1ac2:	93 83       	std	Z+3, r25	; 0x03
    1ac4:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1ac6:	eb 81       	ldd	r30, Y+3	; 0x03
    1ac8:	fc 81       	ldd	r31, Y+4	; 0x04
    1aca:	81 81       	ldd	r24, Z+1	; 0x01
    1acc:	92 81       	ldd	r25, Z+2	; 0x02
    1ace:	ed 81       	ldd	r30, Y+5	; 0x05
    1ad0:	fe 81       	ldd	r31, Y+6	; 0x06
    1ad2:	95 83       	std	Z+5, r25	; 0x05
    1ad4:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1ad6:	e9 81       	ldd	r30, Y+1	; 0x01
    1ad8:	fa 81       	ldd	r31, Y+2	; 0x02
    1ada:	02 80       	ldd	r0, Z+2	; 0x02
    1adc:	f3 81       	ldd	r31, Z+3	; 0x03
    1ade:	e0 2d       	mov	r30, r0
    1ae0:	8d 81       	ldd	r24, Y+5	; 0x05
    1ae2:	9e 81       	ldd	r25, Y+6	; 0x06
    1ae4:	95 83       	std	Z+5, r25	; 0x05
    1ae6:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    1ae8:	8d 81       	ldd	r24, Y+5	; 0x05
    1aea:	9e 81       	ldd	r25, Y+6	; 0x06
    1aec:	e9 81       	ldd	r30, Y+1	; 0x01
    1aee:	fa 81       	ldd	r31, Y+2	; 0x02
    1af0:	93 83       	std	Z+3, r25	; 0x03
    1af2:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    1af4:	8d 81       	ldd	r24, Y+5	; 0x05
    1af6:	9e 81       	ldd	r25, Y+6	; 0x06
    1af8:	eb 81       	ldd	r30, Y+3	; 0x03
    1afa:	fc 81       	ldd	r31, Y+4	; 0x04
    1afc:	92 83       	std	Z+2, r25	; 0x02
    1afe:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1b00:	ed 81       	ldd	r30, Y+5	; 0x05
    1b02:	fe 81       	ldd	r31, Y+6	; 0x06
    1b04:	8b 81       	ldd	r24, Y+3	; 0x03
    1b06:	9c 81       	ldd	r25, Y+4	; 0x04
    1b08:	91 87       	std	Z+9, r25	; 0x09
    1b0a:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1b0c:	eb 81       	ldd	r30, Y+3	; 0x03
    1b0e:	fc 81       	ldd	r31, Y+4	; 0x04
    1b10:	80 81       	ld	r24, Z
    1b12:	8f 5f       	subi	r24, 0xFF	; 255
    1b14:	eb 81       	ldd	r30, Y+3	; 0x03
    1b16:	fc 81       	ldd	r31, Y+4	; 0x04
    1b18:	80 83       	st	Z, r24
}
    1b1a:	26 96       	adiw	r28, 0x06	; 6
    1b1c:	0f b6       	in	r0, 0x3f	; 63
    1b1e:	f8 94       	cli
    1b20:	de bf       	out	0x3e, r29	; 62
    1b22:	0f be       	out	0x3f, r0	; 63
    1b24:	cd bf       	out	0x3d, r28	; 61
    1b26:	cf 91       	pop	r28
    1b28:	df 91       	pop	r29
    1b2a:	08 95       	ret

00001b2c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    1b2c:	df 93       	push	r29
    1b2e:	cf 93       	push	r28
    1b30:	cd b7       	in	r28, 0x3d	; 61
    1b32:	de b7       	in	r29, 0x3e	; 62
    1b34:	28 97       	sbiw	r28, 0x08	; 8
    1b36:	0f b6       	in	r0, 0x3f	; 63
    1b38:	f8 94       	cli
    1b3a:	de bf       	out	0x3e, r29	; 62
    1b3c:	0f be       	out	0x3f, r0	; 63
    1b3e:	cd bf       	out	0x3d, r28	; 61
    1b40:	9e 83       	std	Y+6, r25	; 0x06
    1b42:	8d 83       	std	Y+5, r24	; 0x05
    1b44:	78 87       	std	Y+8, r23	; 0x08
    1b46:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    1b48:	ef 81       	ldd	r30, Y+7	; 0x07
    1b4a:	f8 85       	ldd	r31, Y+8	; 0x08
    1b4c:	80 81       	ld	r24, Z
    1b4e:	91 81       	ldd	r25, Z+1	; 0x01
    1b50:	9a 83       	std	Y+2, r25	; 0x02
    1b52:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1b54:	89 81       	ldd	r24, Y+1	; 0x01
    1b56:	9a 81       	ldd	r25, Y+2	; 0x02
    1b58:	2f ef       	ldi	r18, 0xFF	; 255
    1b5a:	8f 3f       	cpi	r24, 0xFF	; 255
    1b5c:	92 07       	cpc	r25, r18
    1b5e:	39 f4       	brne	.+14     	; 0x1b6e <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1b60:	ed 81       	ldd	r30, Y+5	; 0x05
    1b62:	fe 81       	ldd	r31, Y+6	; 0x06
    1b64:	87 81       	ldd	r24, Z+7	; 0x07
    1b66:	90 85       	ldd	r25, Z+8	; 0x08
    1b68:	9c 83       	std	Y+4, r25	; 0x04
    1b6a:	8b 83       	std	Y+3, r24	; 0x03
    1b6c:	18 c0       	rjmp	.+48     	; 0x1b9e <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    1b6e:	8d 81       	ldd	r24, Y+5	; 0x05
    1b70:	9e 81       	ldd	r25, Y+6	; 0x06
    1b72:	03 96       	adiw	r24, 0x03	; 3
    1b74:	9c 83       	std	Y+4, r25	; 0x04
    1b76:	8b 83       	std	Y+3, r24	; 0x03
    1b78:	06 c0       	rjmp	.+12     	; 0x1b86 <vListInsert+0x5a>
    1b7a:	eb 81       	ldd	r30, Y+3	; 0x03
    1b7c:	fc 81       	ldd	r31, Y+4	; 0x04
    1b7e:	82 81       	ldd	r24, Z+2	; 0x02
    1b80:	93 81       	ldd	r25, Z+3	; 0x03
    1b82:	9c 83       	std	Y+4, r25	; 0x04
    1b84:	8b 83       	std	Y+3, r24	; 0x03
    1b86:	eb 81       	ldd	r30, Y+3	; 0x03
    1b88:	fc 81       	ldd	r31, Y+4	; 0x04
    1b8a:	02 80       	ldd	r0, Z+2	; 0x02
    1b8c:	f3 81       	ldd	r31, Z+3	; 0x03
    1b8e:	e0 2d       	mov	r30, r0
    1b90:	20 81       	ld	r18, Z
    1b92:	31 81       	ldd	r19, Z+1	; 0x01
    1b94:	89 81       	ldd	r24, Y+1	; 0x01
    1b96:	9a 81       	ldd	r25, Y+2	; 0x02
    1b98:	82 17       	cp	r24, r18
    1b9a:	93 07       	cpc	r25, r19
    1b9c:	70 f7       	brcc	.-36     	; 0x1b7a <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1b9e:	eb 81       	ldd	r30, Y+3	; 0x03
    1ba0:	fc 81       	ldd	r31, Y+4	; 0x04
    1ba2:	82 81       	ldd	r24, Z+2	; 0x02
    1ba4:	93 81       	ldd	r25, Z+3	; 0x03
    1ba6:	ef 81       	ldd	r30, Y+7	; 0x07
    1ba8:	f8 85       	ldd	r31, Y+8	; 0x08
    1baa:	93 83       	std	Z+3, r25	; 0x03
    1bac:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1bae:	ef 81       	ldd	r30, Y+7	; 0x07
    1bb0:	f8 85       	ldd	r31, Y+8	; 0x08
    1bb2:	02 80       	ldd	r0, Z+2	; 0x02
    1bb4:	f3 81       	ldd	r31, Z+3	; 0x03
    1bb6:	e0 2d       	mov	r30, r0
    1bb8:	8f 81       	ldd	r24, Y+7	; 0x07
    1bba:	98 85       	ldd	r25, Y+8	; 0x08
    1bbc:	95 83       	std	Z+5, r25	; 0x05
    1bbe:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1bc0:	ef 81       	ldd	r30, Y+7	; 0x07
    1bc2:	f8 85       	ldd	r31, Y+8	; 0x08
    1bc4:	8b 81       	ldd	r24, Y+3	; 0x03
    1bc6:	9c 81       	ldd	r25, Y+4	; 0x04
    1bc8:	95 83       	std	Z+5, r25	; 0x05
    1bca:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    1bcc:	8f 81       	ldd	r24, Y+7	; 0x07
    1bce:	98 85       	ldd	r25, Y+8	; 0x08
    1bd0:	eb 81       	ldd	r30, Y+3	; 0x03
    1bd2:	fc 81       	ldd	r31, Y+4	; 0x04
    1bd4:	93 83       	std	Z+3, r25	; 0x03
    1bd6:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1bd8:	ef 81       	ldd	r30, Y+7	; 0x07
    1bda:	f8 85       	ldd	r31, Y+8	; 0x08
    1bdc:	8d 81       	ldd	r24, Y+5	; 0x05
    1bde:	9e 81       	ldd	r25, Y+6	; 0x06
    1be0:	91 87       	std	Z+9, r25	; 0x09
    1be2:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1be4:	ed 81       	ldd	r30, Y+5	; 0x05
    1be6:	fe 81       	ldd	r31, Y+6	; 0x06
    1be8:	80 81       	ld	r24, Z
    1bea:	8f 5f       	subi	r24, 0xFF	; 255
    1bec:	ed 81       	ldd	r30, Y+5	; 0x05
    1bee:	fe 81       	ldd	r31, Y+6	; 0x06
    1bf0:	80 83       	st	Z, r24
}
    1bf2:	28 96       	adiw	r28, 0x08	; 8
    1bf4:	0f b6       	in	r0, 0x3f	; 63
    1bf6:	f8 94       	cli
    1bf8:	de bf       	out	0x3e, r29	; 62
    1bfa:	0f be       	out	0x3f, r0	; 63
    1bfc:	cd bf       	out	0x3d, r28	; 61
    1bfe:	cf 91       	pop	r28
    1c00:	df 91       	pop	r29
    1c02:	08 95       	ret

00001c04 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    1c04:	df 93       	push	r29
    1c06:	cf 93       	push	r28
    1c08:	00 d0       	rcall	.+0      	; 0x1c0a <vListRemove+0x6>
    1c0a:	00 d0       	rcall	.+0      	; 0x1c0c <vListRemove+0x8>
    1c0c:	cd b7       	in	r28, 0x3d	; 61
    1c0e:	de b7       	in	r29, 0x3e	; 62
    1c10:	9c 83       	std	Y+4, r25	; 0x04
    1c12:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1c14:	eb 81       	ldd	r30, Y+3	; 0x03
    1c16:	fc 81       	ldd	r31, Y+4	; 0x04
    1c18:	a2 81       	ldd	r26, Z+2	; 0x02
    1c1a:	b3 81       	ldd	r27, Z+3	; 0x03
    1c1c:	eb 81       	ldd	r30, Y+3	; 0x03
    1c1e:	fc 81       	ldd	r31, Y+4	; 0x04
    1c20:	84 81       	ldd	r24, Z+4	; 0x04
    1c22:	95 81       	ldd	r25, Z+5	; 0x05
    1c24:	15 96       	adiw	r26, 0x05	; 5
    1c26:	9c 93       	st	X, r25
    1c28:	8e 93       	st	-X, r24
    1c2a:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1c2c:	eb 81       	ldd	r30, Y+3	; 0x03
    1c2e:	fc 81       	ldd	r31, Y+4	; 0x04
    1c30:	a4 81       	ldd	r26, Z+4	; 0x04
    1c32:	b5 81       	ldd	r27, Z+5	; 0x05
    1c34:	eb 81       	ldd	r30, Y+3	; 0x03
    1c36:	fc 81       	ldd	r31, Y+4	; 0x04
    1c38:	82 81       	ldd	r24, Z+2	; 0x02
    1c3a:	93 81       	ldd	r25, Z+3	; 0x03
    1c3c:	13 96       	adiw	r26, 0x03	; 3
    1c3e:	9c 93       	st	X, r25
    1c40:	8e 93       	st	-X, r24
    1c42:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    1c44:	eb 81       	ldd	r30, Y+3	; 0x03
    1c46:	fc 81       	ldd	r31, Y+4	; 0x04
    1c48:	80 85       	ldd	r24, Z+8	; 0x08
    1c4a:	91 85       	ldd	r25, Z+9	; 0x09
    1c4c:	9a 83       	std	Y+2, r25	; 0x02
    1c4e:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1c50:	e9 81       	ldd	r30, Y+1	; 0x01
    1c52:	fa 81       	ldd	r31, Y+2	; 0x02
    1c54:	21 81       	ldd	r18, Z+1	; 0x01
    1c56:	32 81       	ldd	r19, Z+2	; 0x02
    1c58:	8b 81       	ldd	r24, Y+3	; 0x03
    1c5a:	9c 81       	ldd	r25, Y+4	; 0x04
    1c5c:	28 17       	cp	r18, r24
    1c5e:	39 07       	cpc	r19, r25
    1c60:	41 f4       	brne	.+16     	; 0x1c72 <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1c62:	eb 81       	ldd	r30, Y+3	; 0x03
    1c64:	fc 81       	ldd	r31, Y+4	; 0x04
    1c66:	84 81       	ldd	r24, Z+4	; 0x04
    1c68:	95 81       	ldd	r25, Z+5	; 0x05
    1c6a:	e9 81       	ldd	r30, Y+1	; 0x01
    1c6c:	fa 81       	ldd	r31, Y+2	; 0x02
    1c6e:	92 83       	std	Z+2, r25	; 0x02
    1c70:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    1c72:	eb 81       	ldd	r30, Y+3	; 0x03
    1c74:	fc 81       	ldd	r31, Y+4	; 0x04
    1c76:	11 86       	std	Z+9, r1	; 0x09
    1c78:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1c7a:	e9 81       	ldd	r30, Y+1	; 0x01
    1c7c:	fa 81       	ldd	r31, Y+2	; 0x02
    1c7e:	80 81       	ld	r24, Z
    1c80:	81 50       	subi	r24, 0x01	; 1
    1c82:	e9 81       	ldd	r30, Y+1	; 0x01
    1c84:	fa 81       	ldd	r31, Y+2	; 0x02
    1c86:	80 83       	st	Z, r24
}
    1c88:	0f 90       	pop	r0
    1c8a:	0f 90       	pop	r0
    1c8c:	0f 90       	pop	r0
    1c8e:	0f 90       	pop	r0
    1c90:	cf 91       	pop	r28
    1c92:	df 91       	pop	r29
    1c94:	08 95       	ret

00001c96 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    1c96:	df 93       	push	r29
    1c98:	cf 93       	push	r28
    1c9a:	cd b7       	in	r28, 0x3d	; 61
    1c9c:	de b7       	in	r29, 0x3e	; 62
    1c9e:	28 97       	sbiw	r28, 0x08	; 8
    1ca0:	0f b6       	in	r0, 0x3f	; 63
    1ca2:	f8 94       	cli
    1ca4:	de bf       	out	0x3e, r29	; 62
    1ca6:	0f be       	out	0x3f, r0	; 63
    1ca8:	cd bf       	out	0x3d, r28	; 61
    1caa:	9c 83       	std	Y+4, r25	; 0x04
    1cac:	8b 83       	std	Y+3, r24	; 0x03
    1cae:	7e 83       	std	Y+6, r23	; 0x06
    1cb0:	6d 83       	std	Y+5, r22	; 0x05
    1cb2:	58 87       	std	Y+8, r21	; 0x08
    1cb4:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    1cb6:	eb 81       	ldd	r30, Y+3	; 0x03
    1cb8:	fc 81       	ldd	r31, Y+4	; 0x04
    1cba:	81 e1       	ldi	r24, 0x11	; 17
    1cbc:	80 83       	st	Z, r24
	pxTopOfStack--;
    1cbe:	8b 81       	ldd	r24, Y+3	; 0x03
    1cc0:	9c 81       	ldd	r25, Y+4	; 0x04
    1cc2:	01 97       	sbiw	r24, 0x01	; 1
    1cc4:	9c 83       	std	Y+4, r25	; 0x04
    1cc6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    1cc8:	eb 81       	ldd	r30, Y+3	; 0x03
    1cca:	fc 81       	ldd	r31, Y+4	; 0x04
    1ccc:	82 e2       	ldi	r24, 0x22	; 34
    1cce:	80 83       	st	Z, r24
	pxTopOfStack--;
    1cd0:	8b 81       	ldd	r24, Y+3	; 0x03
    1cd2:	9c 81       	ldd	r25, Y+4	; 0x04
    1cd4:	01 97       	sbiw	r24, 0x01	; 1
    1cd6:	9c 83       	std	Y+4, r25	; 0x04
    1cd8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    1cda:	eb 81       	ldd	r30, Y+3	; 0x03
    1cdc:	fc 81       	ldd	r31, Y+4	; 0x04
    1cde:	83 e3       	ldi	r24, 0x33	; 51
    1ce0:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ce2:	8b 81       	ldd	r24, Y+3	; 0x03
    1ce4:	9c 81       	ldd	r25, Y+4	; 0x04
    1ce6:	01 97       	sbiw	r24, 0x01	; 1
    1ce8:	9c 83       	std	Y+4, r25	; 0x04
    1cea:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
    1cec:	8d 81       	ldd	r24, Y+5	; 0x05
    1cee:	9e 81       	ldd	r25, Y+6	; 0x06
    1cf0:	9a 83       	std	Y+2, r25	; 0x02
    1cf2:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1cf4:	89 81       	ldd	r24, Y+1	; 0x01
    1cf6:	eb 81       	ldd	r30, Y+3	; 0x03
    1cf8:	fc 81       	ldd	r31, Y+4	; 0x04
    1cfa:	80 83       	st	Z, r24
	pxTopOfStack--;
    1cfc:	8b 81       	ldd	r24, Y+3	; 0x03
    1cfe:	9c 81       	ldd	r25, Y+4	; 0x04
    1d00:	01 97       	sbiw	r24, 0x01	; 1
    1d02:	9c 83       	std	Y+4, r25	; 0x04
    1d04:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1d06:	89 81       	ldd	r24, Y+1	; 0x01
    1d08:	9a 81       	ldd	r25, Y+2	; 0x02
    1d0a:	89 2f       	mov	r24, r25
    1d0c:	99 27       	eor	r25, r25
    1d0e:	9a 83       	std	Y+2, r25	; 0x02
    1d10:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1d12:	89 81       	ldd	r24, Y+1	; 0x01
    1d14:	eb 81       	ldd	r30, Y+3	; 0x03
    1d16:	fc 81       	ldd	r31, Y+4	; 0x04
    1d18:	80 83       	st	Z, r24
	pxTopOfStack--;
    1d1a:	8b 81       	ldd	r24, Y+3	; 0x03
    1d1c:	9c 81       	ldd	r25, Y+4	; 0x04
    1d1e:	01 97       	sbiw	r24, 0x01	; 1
    1d20:	9c 83       	std	Y+4, r25	; 0x04
    1d22:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    1d24:	eb 81       	ldd	r30, Y+3	; 0x03
    1d26:	fc 81       	ldd	r31, Y+4	; 0x04
    1d28:	10 82       	st	Z, r1
	pxTopOfStack--;
    1d2a:	8b 81       	ldd	r24, Y+3	; 0x03
    1d2c:	9c 81       	ldd	r25, Y+4	; 0x04
    1d2e:	01 97       	sbiw	r24, 0x01	; 1
    1d30:	9c 83       	std	Y+4, r25	; 0x04
    1d32:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    1d34:	eb 81       	ldd	r30, Y+3	; 0x03
    1d36:	fc 81       	ldd	r31, Y+4	; 0x04
    1d38:	80 e8       	ldi	r24, 0x80	; 128
    1d3a:	80 83       	st	Z, r24
	pxTopOfStack--;
    1d3c:	8b 81       	ldd	r24, Y+3	; 0x03
    1d3e:	9c 81       	ldd	r25, Y+4	; 0x04
    1d40:	01 97       	sbiw	r24, 0x01	; 1
    1d42:	9c 83       	std	Y+4, r25	; 0x04
    1d44:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    1d46:	eb 81       	ldd	r30, Y+3	; 0x03
    1d48:	fc 81       	ldd	r31, Y+4	; 0x04
    1d4a:	10 82       	st	Z, r1
	pxTopOfStack--;
    1d4c:	8b 81       	ldd	r24, Y+3	; 0x03
    1d4e:	9c 81       	ldd	r25, Y+4	; 0x04
    1d50:	01 97       	sbiw	r24, 0x01	; 1
    1d52:	9c 83       	std	Y+4, r25	; 0x04
    1d54:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    1d56:	eb 81       	ldd	r30, Y+3	; 0x03
    1d58:	fc 81       	ldd	r31, Y+4	; 0x04
    1d5a:	82 e0       	ldi	r24, 0x02	; 2
    1d5c:	80 83       	st	Z, r24
	pxTopOfStack--;
    1d5e:	8b 81       	ldd	r24, Y+3	; 0x03
    1d60:	9c 81       	ldd	r25, Y+4	; 0x04
    1d62:	01 97       	sbiw	r24, 0x01	; 1
    1d64:	9c 83       	std	Y+4, r25	; 0x04
    1d66:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    1d68:	eb 81       	ldd	r30, Y+3	; 0x03
    1d6a:	fc 81       	ldd	r31, Y+4	; 0x04
    1d6c:	83 e0       	ldi	r24, 0x03	; 3
    1d6e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1d70:	8b 81       	ldd	r24, Y+3	; 0x03
    1d72:	9c 81       	ldd	r25, Y+4	; 0x04
    1d74:	01 97       	sbiw	r24, 0x01	; 1
    1d76:	9c 83       	std	Y+4, r25	; 0x04
    1d78:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    1d7a:	eb 81       	ldd	r30, Y+3	; 0x03
    1d7c:	fc 81       	ldd	r31, Y+4	; 0x04
    1d7e:	84 e0       	ldi	r24, 0x04	; 4
    1d80:	80 83       	st	Z, r24
	pxTopOfStack--;
    1d82:	8b 81       	ldd	r24, Y+3	; 0x03
    1d84:	9c 81       	ldd	r25, Y+4	; 0x04
    1d86:	01 97       	sbiw	r24, 0x01	; 1
    1d88:	9c 83       	std	Y+4, r25	; 0x04
    1d8a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    1d8c:	eb 81       	ldd	r30, Y+3	; 0x03
    1d8e:	fc 81       	ldd	r31, Y+4	; 0x04
    1d90:	85 e0       	ldi	r24, 0x05	; 5
    1d92:	80 83       	st	Z, r24
	pxTopOfStack--;
    1d94:	8b 81       	ldd	r24, Y+3	; 0x03
    1d96:	9c 81       	ldd	r25, Y+4	; 0x04
    1d98:	01 97       	sbiw	r24, 0x01	; 1
    1d9a:	9c 83       	std	Y+4, r25	; 0x04
    1d9c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    1d9e:	eb 81       	ldd	r30, Y+3	; 0x03
    1da0:	fc 81       	ldd	r31, Y+4	; 0x04
    1da2:	86 e0       	ldi	r24, 0x06	; 6
    1da4:	80 83       	st	Z, r24
	pxTopOfStack--;
    1da6:	8b 81       	ldd	r24, Y+3	; 0x03
    1da8:	9c 81       	ldd	r25, Y+4	; 0x04
    1daa:	01 97       	sbiw	r24, 0x01	; 1
    1dac:	9c 83       	std	Y+4, r25	; 0x04
    1dae:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    1db0:	eb 81       	ldd	r30, Y+3	; 0x03
    1db2:	fc 81       	ldd	r31, Y+4	; 0x04
    1db4:	87 e0       	ldi	r24, 0x07	; 7
    1db6:	80 83       	st	Z, r24
	pxTopOfStack--;
    1db8:	8b 81       	ldd	r24, Y+3	; 0x03
    1dba:	9c 81       	ldd	r25, Y+4	; 0x04
    1dbc:	01 97       	sbiw	r24, 0x01	; 1
    1dbe:	9c 83       	std	Y+4, r25	; 0x04
    1dc0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    1dc2:	eb 81       	ldd	r30, Y+3	; 0x03
    1dc4:	fc 81       	ldd	r31, Y+4	; 0x04
    1dc6:	88 e0       	ldi	r24, 0x08	; 8
    1dc8:	80 83       	st	Z, r24
	pxTopOfStack--;
    1dca:	8b 81       	ldd	r24, Y+3	; 0x03
    1dcc:	9c 81       	ldd	r25, Y+4	; 0x04
    1dce:	01 97       	sbiw	r24, 0x01	; 1
    1dd0:	9c 83       	std	Y+4, r25	; 0x04
    1dd2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    1dd4:	eb 81       	ldd	r30, Y+3	; 0x03
    1dd6:	fc 81       	ldd	r31, Y+4	; 0x04
    1dd8:	89 e0       	ldi	r24, 0x09	; 9
    1dda:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ddc:	8b 81       	ldd	r24, Y+3	; 0x03
    1dde:	9c 81       	ldd	r25, Y+4	; 0x04
    1de0:	01 97       	sbiw	r24, 0x01	; 1
    1de2:	9c 83       	std	Y+4, r25	; 0x04
    1de4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    1de6:	eb 81       	ldd	r30, Y+3	; 0x03
    1de8:	fc 81       	ldd	r31, Y+4	; 0x04
    1dea:	80 e1       	ldi	r24, 0x10	; 16
    1dec:	80 83       	st	Z, r24
	pxTopOfStack--;
    1dee:	8b 81       	ldd	r24, Y+3	; 0x03
    1df0:	9c 81       	ldd	r25, Y+4	; 0x04
    1df2:	01 97       	sbiw	r24, 0x01	; 1
    1df4:	9c 83       	std	Y+4, r25	; 0x04
    1df6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    1df8:	eb 81       	ldd	r30, Y+3	; 0x03
    1dfa:	fc 81       	ldd	r31, Y+4	; 0x04
    1dfc:	81 e1       	ldi	r24, 0x11	; 17
    1dfe:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e00:	8b 81       	ldd	r24, Y+3	; 0x03
    1e02:	9c 81       	ldd	r25, Y+4	; 0x04
    1e04:	01 97       	sbiw	r24, 0x01	; 1
    1e06:	9c 83       	std	Y+4, r25	; 0x04
    1e08:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    1e0a:	eb 81       	ldd	r30, Y+3	; 0x03
    1e0c:	fc 81       	ldd	r31, Y+4	; 0x04
    1e0e:	82 e1       	ldi	r24, 0x12	; 18
    1e10:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e12:	8b 81       	ldd	r24, Y+3	; 0x03
    1e14:	9c 81       	ldd	r25, Y+4	; 0x04
    1e16:	01 97       	sbiw	r24, 0x01	; 1
    1e18:	9c 83       	std	Y+4, r25	; 0x04
    1e1a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    1e1c:	eb 81       	ldd	r30, Y+3	; 0x03
    1e1e:	fc 81       	ldd	r31, Y+4	; 0x04
    1e20:	83 e1       	ldi	r24, 0x13	; 19
    1e22:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e24:	8b 81       	ldd	r24, Y+3	; 0x03
    1e26:	9c 81       	ldd	r25, Y+4	; 0x04
    1e28:	01 97       	sbiw	r24, 0x01	; 1
    1e2a:	9c 83       	std	Y+4, r25	; 0x04
    1e2c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    1e2e:	eb 81       	ldd	r30, Y+3	; 0x03
    1e30:	fc 81       	ldd	r31, Y+4	; 0x04
    1e32:	84 e1       	ldi	r24, 0x14	; 20
    1e34:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e36:	8b 81       	ldd	r24, Y+3	; 0x03
    1e38:	9c 81       	ldd	r25, Y+4	; 0x04
    1e3a:	01 97       	sbiw	r24, 0x01	; 1
    1e3c:	9c 83       	std	Y+4, r25	; 0x04
    1e3e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    1e40:	eb 81       	ldd	r30, Y+3	; 0x03
    1e42:	fc 81       	ldd	r31, Y+4	; 0x04
    1e44:	85 e1       	ldi	r24, 0x15	; 21
    1e46:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e48:	8b 81       	ldd	r24, Y+3	; 0x03
    1e4a:	9c 81       	ldd	r25, Y+4	; 0x04
    1e4c:	01 97       	sbiw	r24, 0x01	; 1
    1e4e:	9c 83       	std	Y+4, r25	; 0x04
    1e50:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    1e52:	eb 81       	ldd	r30, Y+3	; 0x03
    1e54:	fc 81       	ldd	r31, Y+4	; 0x04
    1e56:	86 e1       	ldi	r24, 0x16	; 22
    1e58:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e5a:	8b 81       	ldd	r24, Y+3	; 0x03
    1e5c:	9c 81       	ldd	r25, Y+4	; 0x04
    1e5e:	01 97       	sbiw	r24, 0x01	; 1
    1e60:	9c 83       	std	Y+4, r25	; 0x04
    1e62:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    1e64:	eb 81       	ldd	r30, Y+3	; 0x03
    1e66:	fc 81       	ldd	r31, Y+4	; 0x04
    1e68:	87 e1       	ldi	r24, 0x17	; 23
    1e6a:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e6c:	8b 81       	ldd	r24, Y+3	; 0x03
    1e6e:	9c 81       	ldd	r25, Y+4	; 0x04
    1e70:	01 97       	sbiw	r24, 0x01	; 1
    1e72:	9c 83       	std	Y+4, r25	; 0x04
    1e74:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    1e76:	eb 81       	ldd	r30, Y+3	; 0x03
    1e78:	fc 81       	ldd	r31, Y+4	; 0x04
    1e7a:	88 e1       	ldi	r24, 0x18	; 24
    1e7c:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e7e:	8b 81       	ldd	r24, Y+3	; 0x03
    1e80:	9c 81       	ldd	r25, Y+4	; 0x04
    1e82:	01 97       	sbiw	r24, 0x01	; 1
    1e84:	9c 83       	std	Y+4, r25	; 0x04
    1e86:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    1e88:	eb 81       	ldd	r30, Y+3	; 0x03
    1e8a:	fc 81       	ldd	r31, Y+4	; 0x04
    1e8c:	89 e1       	ldi	r24, 0x19	; 25
    1e8e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e90:	8b 81       	ldd	r24, Y+3	; 0x03
    1e92:	9c 81       	ldd	r25, Y+4	; 0x04
    1e94:	01 97       	sbiw	r24, 0x01	; 1
    1e96:	9c 83       	std	Y+4, r25	; 0x04
    1e98:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    1e9a:	eb 81       	ldd	r30, Y+3	; 0x03
    1e9c:	fc 81       	ldd	r31, Y+4	; 0x04
    1e9e:	80 e2       	ldi	r24, 0x20	; 32
    1ea0:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ea2:	8b 81       	ldd	r24, Y+3	; 0x03
    1ea4:	9c 81       	ldd	r25, Y+4	; 0x04
    1ea6:	01 97       	sbiw	r24, 0x01	; 1
    1ea8:	9c 83       	std	Y+4, r25	; 0x04
    1eaa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    1eac:	eb 81       	ldd	r30, Y+3	; 0x03
    1eae:	fc 81       	ldd	r31, Y+4	; 0x04
    1eb0:	81 e2       	ldi	r24, 0x21	; 33
    1eb2:	80 83       	st	Z, r24
	pxTopOfStack--;
    1eb4:	8b 81       	ldd	r24, Y+3	; 0x03
    1eb6:	9c 81       	ldd	r25, Y+4	; 0x04
    1eb8:	01 97       	sbiw	r24, 0x01	; 1
    1eba:	9c 83       	std	Y+4, r25	; 0x04
    1ebc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    1ebe:	eb 81       	ldd	r30, Y+3	; 0x03
    1ec0:	fc 81       	ldd	r31, Y+4	; 0x04
    1ec2:	82 e2       	ldi	r24, 0x22	; 34
    1ec4:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ec6:	8b 81       	ldd	r24, Y+3	; 0x03
    1ec8:	9c 81       	ldd	r25, Y+4	; 0x04
    1eca:	01 97       	sbiw	r24, 0x01	; 1
    1ecc:	9c 83       	std	Y+4, r25	; 0x04
    1ece:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    1ed0:	eb 81       	ldd	r30, Y+3	; 0x03
    1ed2:	fc 81       	ldd	r31, Y+4	; 0x04
    1ed4:	83 e2       	ldi	r24, 0x23	; 35
    1ed6:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ed8:	8b 81       	ldd	r24, Y+3	; 0x03
    1eda:	9c 81       	ldd	r25, Y+4	; 0x04
    1edc:	01 97       	sbiw	r24, 0x01	; 1
    1ede:	9c 83       	std	Y+4, r25	; 0x04
    1ee0:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    1ee2:	8f 81       	ldd	r24, Y+7	; 0x07
    1ee4:	98 85       	ldd	r25, Y+8	; 0x08
    1ee6:	9a 83       	std	Y+2, r25	; 0x02
    1ee8:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1eea:	89 81       	ldd	r24, Y+1	; 0x01
    1eec:	eb 81       	ldd	r30, Y+3	; 0x03
    1eee:	fc 81       	ldd	r31, Y+4	; 0x04
    1ef0:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ef2:	8b 81       	ldd	r24, Y+3	; 0x03
    1ef4:	9c 81       	ldd	r25, Y+4	; 0x04
    1ef6:	01 97       	sbiw	r24, 0x01	; 1
    1ef8:	9c 83       	std	Y+4, r25	; 0x04
    1efa:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1efc:	89 81       	ldd	r24, Y+1	; 0x01
    1efe:	9a 81       	ldd	r25, Y+2	; 0x02
    1f00:	89 2f       	mov	r24, r25
    1f02:	99 27       	eor	r25, r25
    1f04:	9a 83       	std	Y+2, r25	; 0x02
    1f06:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1f08:	89 81       	ldd	r24, Y+1	; 0x01
    1f0a:	eb 81       	ldd	r30, Y+3	; 0x03
    1f0c:	fc 81       	ldd	r31, Y+4	; 0x04
    1f0e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f10:	8b 81       	ldd	r24, Y+3	; 0x03
    1f12:	9c 81       	ldd	r25, Y+4	; 0x04
    1f14:	01 97       	sbiw	r24, 0x01	; 1
    1f16:	9c 83       	std	Y+4, r25	; 0x04
    1f18:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    1f1a:	eb 81       	ldd	r30, Y+3	; 0x03
    1f1c:	fc 81       	ldd	r31, Y+4	; 0x04
    1f1e:	86 e2       	ldi	r24, 0x26	; 38
    1f20:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f22:	8b 81       	ldd	r24, Y+3	; 0x03
    1f24:	9c 81       	ldd	r25, Y+4	; 0x04
    1f26:	01 97       	sbiw	r24, 0x01	; 1
    1f28:	9c 83       	std	Y+4, r25	; 0x04
    1f2a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    1f2c:	eb 81       	ldd	r30, Y+3	; 0x03
    1f2e:	fc 81       	ldd	r31, Y+4	; 0x04
    1f30:	87 e2       	ldi	r24, 0x27	; 39
    1f32:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f34:	8b 81       	ldd	r24, Y+3	; 0x03
    1f36:	9c 81       	ldd	r25, Y+4	; 0x04
    1f38:	01 97       	sbiw	r24, 0x01	; 1
    1f3a:	9c 83       	std	Y+4, r25	; 0x04
    1f3c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    1f3e:	eb 81       	ldd	r30, Y+3	; 0x03
    1f40:	fc 81       	ldd	r31, Y+4	; 0x04
    1f42:	88 e2       	ldi	r24, 0x28	; 40
    1f44:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f46:	8b 81       	ldd	r24, Y+3	; 0x03
    1f48:	9c 81       	ldd	r25, Y+4	; 0x04
    1f4a:	01 97       	sbiw	r24, 0x01	; 1
    1f4c:	9c 83       	std	Y+4, r25	; 0x04
    1f4e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    1f50:	eb 81       	ldd	r30, Y+3	; 0x03
    1f52:	fc 81       	ldd	r31, Y+4	; 0x04
    1f54:	89 e2       	ldi	r24, 0x29	; 41
    1f56:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f58:	8b 81       	ldd	r24, Y+3	; 0x03
    1f5a:	9c 81       	ldd	r25, Y+4	; 0x04
    1f5c:	01 97       	sbiw	r24, 0x01	; 1
    1f5e:	9c 83       	std	Y+4, r25	; 0x04
    1f60:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    1f62:	eb 81       	ldd	r30, Y+3	; 0x03
    1f64:	fc 81       	ldd	r31, Y+4	; 0x04
    1f66:	80 e3       	ldi	r24, 0x30	; 48
    1f68:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f6a:	8b 81       	ldd	r24, Y+3	; 0x03
    1f6c:	9c 81       	ldd	r25, Y+4	; 0x04
    1f6e:	01 97       	sbiw	r24, 0x01	; 1
    1f70:	9c 83       	std	Y+4, r25	; 0x04
    1f72:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    1f74:	eb 81       	ldd	r30, Y+3	; 0x03
    1f76:	fc 81       	ldd	r31, Y+4	; 0x04
    1f78:	81 e3       	ldi	r24, 0x31	; 49
    1f7a:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f7c:	8b 81       	ldd	r24, Y+3	; 0x03
    1f7e:	9c 81       	ldd	r25, Y+4	; 0x04
    1f80:	01 97       	sbiw	r24, 0x01	; 1
    1f82:	9c 83       	std	Y+4, r25	; 0x04
    1f84:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    1f86:	8b 81       	ldd	r24, Y+3	; 0x03
    1f88:	9c 81       	ldd	r25, Y+4	; 0x04
}
    1f8a:	28 96       	adiw	r28, 0x08	; 8
    1f8c:	0f b6       	in	r0, 0x3f	; 63
    1f8e:	f8 94       	cli
    1f90:	de bf       	out	0x3e, r29	; 62
    1f92:	0f be       	out	0x3f, r0	; 63
    1f94:	cd bf       	out	0x3d, r28	; 61
    1f96:	cf 91       	pop	r28
    1f98:	df 91       	pop	r29
    1f9a:	08 95       	ret

00001f9c <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    1f9c:	df 93       	push	r29
    1f9e:	cf 93       	push	r28
    1fa0:	cd b7       	in	r28, 0x3d	; 61
    1fa2:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    1fa4:	0e 94 be 10 	call	0x217c	; 0x217c <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    1fa8:	a0 91 d8 04 	lds	r26, 0x04D8
    1fac:	b0 91 d9 04 	lds	r27, 0x04D9
    1fb0:	cd 91       	ld	r28, X+
    1fb2:	cd bf       	out	0x3d, r28	; 61
    1fb4:	dd 91       	ld	r29, X+
    1fb6:	de bf       	out	0x3e, r29	; 62
    1fb8:	ff 91       	pop	r31
    1fba:	ef 91       	pop	r30
    1fbc:	df 91       	pop	r29
    1fbe:	cf 91       	pop	r28
    1fc0:	bf 91       	pop	r27
    1fc2:	af 91       	pop	r26
    1fc4:	9f 91       	pop	r25
    1fc6:	8f 91       	pop	r24
    1fc8:	7f 91       	pop	r23
    1fca:	6f 91       	pop	r22
    1fcc:	5f 91       	pop	r21
    1fce:	4f 91       	pop	r20
    1fd0:	3f 91       	pop	r19
    1fd2:	2f 91       	pop	r18
    1fd4:	1f 91       	pop	r17
    1fd6:	0f 91       	pop	r16
    1fd8:	ff 90       	pop	r15
    1fda:	ef 90       	pop	r14
    1fdc:	df 90       	pop	r13
    1fde:	cf 90       	pop	r12
    1fe0:	bf 90       	pop	r11
    1fe2:	af 90       	pop	r10
    1fe4:	9f 90       	pop	r9
    1fe6:	8f 90       	pop	r8
    1fe8:	7f 90       	pop	r7
    1fea:	6f 90       	pop	r6
    1fec:	5f 90       	pop	r5
    1fee:	4f 90       	pop	r4
    1ff0:	3f 90       	pop	r3
    1ff2:	2f 90       	pop	r2
    1ff4:	1f 90       	pop	r1
    1ff6:	0f 90       	pop	r0
    1ff8:	0f be       	out	0x3f, r0	; 63
    1ffa:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1ffc:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    1ffe:	81 e0       	ldi	r24, 0x01	; 1
}
    2000:	cf 91       	pop	r28
    2002:	df 91       	pop	r29
    2004:	08 95       	ret

00002006 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    2006:	df 93       	push	r29
    2008:	cf 93       	push	r28
    200a:	cd b7       	in	r28, 0x3d	; 61
    200c:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    200e:	cf 91       	pop	r28
    2010:	df 91       	pop	r29
    2012:	08 95       	ret

00002014 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2014:	0f 92       	push	r0
    2016:	0f b6       	in	r0, 0x3f	; 63
    2018:	f8 94       	cli
    201a:	0f 92       	push	r0
    201c:	1f 92       	push	r1
    201e:	11 24       	eor	r1, r1
    2020:	2f 92       	push	r2
    2022:	3f 92       	push	r3
    2024:	4f 92       	push	r4
    2026:	5f 92       	push	r5
    2028:	6f 92       	push	r6
    202a:	7f 92       	push	r7
    202c:	8f 92       	push	r8
    202e:	9f 92       	push	r9
    2030:	af 92       	push	r10
    2032:	bf 92       	push	r11
    2034:	cf 92       	push	r12
    2036:	df 92       	push	r13
    2038:	ef 92       	push	r14
    203a:	ff 92       	push	r15
    203c:	0f 93       	push	r16
    203e:	1f 93       	push	r17
    2040:	2f 93       	push	r18
    2042:	3f 93       	push	r19
    2044:	4f 93       	push	r20
    2046:	5f 93       	push	r21
    2048:	6f 93       	push	r22
    204a:	7f 93       	push	r23
    204c:	8f 93       	push	r24
    204e:	9f 93       	push	r25
    2050:	af 93       	push	r26
    2052:	bf 93       	push	r27
    2054:	cf 93       	push	r28
    2056:	df 93       	push	r29
    2058:	ef 93       	push	r30
    205a:	ff 93       	push	r31
    205c:	a0 91 d8 04 	lds	r26, 0x04D8
    2060:	b0 91 d9 04 	lds	r27, 0x04D9
    2064:	0d b6       	in	r0, 0x3d	; 61
    2066:	0d 92       	st	X+, r0
    2068:	0e b6       	in	r0, 0x3e	; 62
    206a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    206c:	0e 94 7a 19 	call	0x32f4	; 0x32f4 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2070:	a0 91 d8 04 	lds	r26, 0x04D8
    2074:	b0 91 d9 04 	lds	r27, 0x04D9
    2078:	cd 91       	ld	r28, X+
    207a:	cd bf       	out	0x3d, r28	; 61
    207c:	dd 91       	ld	r29, X+
    207e:	de bf       	out	0x3e, r29	; 62
    2080:	ff 91       	pop	r31
    2082:	ef 91       	pop	r30
    2084:	df 91       	pop	r29
    2086:	cf 91       	pop	r28
    2088:	bf 91       	pop	r27
    208a:	af 91       	pop	r26
    208c:	9f 91       	pop	r25
    208e:	8f 91       	pop	r24
    2090:	7f 91       	pop	r23
    2092:	6f 91       	pop	r22
    2094:	5f 91       	pop	r21
    2096:	4f 91       	pop	r20
    2098:	3f 91       	pop	r19
    209a:	2f 91       	pop	r18
    209c:	1f 91       	pop	r17
    209e:	0f 91       	pop	r16
    20a0:	ff 90       	pop	r15
    20a2:	ef 90       	pop	r14
    20a4:	df 90       	pop	r13
    20a6:	cf 90       	pop	r12
    20a8:	bf 90       	pop	r11
    20aa:	af 90       	pop	r10
    20ac:	9f 90       	pop	r9
    20ae:	8f 90       	pop	r8
    20b0:	7f 90       	pop	r7
    20b2:	6f 90       	pop	r6
    20b4:	5f 90       	pop	r5
    20b6:	4f 90       	pop	r4
    20b8:	3f 90       	pop	r3
    20ba:	2f 90       	pop	r2
    20bc:	1f 90       	pop	r1
    20be:	0f 90       	pop	r0
    20c0:	0f be       	out	0x3f, r0	; 63
    20c2:	0f 90       	pop	r0

	asm volatile ( "ret" );
    20c4:	08 95       	ret

000020c6 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    20c6:	0f 92       	push	r0
    20c8:	0f b6       	in	r0, 0x3f	; 63
    20ca:	f8 94       	cli
    20cc:	0f 92       	push	r0
    20ce:	1f 92       	push	r1
    20d0:	11 24       	eor	r1, r1
    20d2:	2f 92       	push	r2
    20d4:	3f 92       	push	r3
    20d6:	4f 92       	push	r4
    20d8:	5f 92       	push	r5
    20da:	6f 92       	push	r6
    20dc:	7f 92       	push	r7
    20de:	8f 92       	push	r8
    20e0:	9f 92       	push	r9
    20e2:	af 92       	push	r10
    20e4:	bf 92       	push	r11
    20e6:	cf 92       	push	r12
    20e8:	df 92       	push	r13
    20ea:	ef 92       	push	r14
    20ec:	ff 92       	push	r15
    20ee:	0f 93       	push	r16
    20f0:	1f 93       	push	r17
    20f2:	2f 93       	push	r18
    20f4:	3f 93       	push	r19
    20f6:	4f 93       	push	r20
    20f8:	5f 93       	push	r21
    20fa:	6f 93       	push	r22
    20fc:	7f 93       	push	r23
    20fe:	8f 93       	push	r24
    2100:	9f 93       	push	r25
    2102:	af 93       	push	r26
    2104:	bf 93       	push	r27
    2106:	cf 93       	push	r28
    2108:	df 93       	push	r29
    210a:	ef 93       	push	r30
    210c:	ff 93       	push	r31
    210e:	a0 91 d8 04 	lds	r26, 0x04D8
    2112:	b0 91 d9 04 	lds	r27, 0x04D9
    2116:	0d b6       	in	r0, 0x3d	; 61
    2118:	0d 92       	st	X+, r0
    211a:	0e b6       	in	r0, 0x3e	; 62
    211c:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    211e:	0e 94 a5 18 	call	0x314a	; 0x314a <vTaskIncrementTick>
	vTaskSwitchContext();
    2122:	0e 94 7a 19 	call	0x32f4	; 0x32f4 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2126:	a0 91 d8 04 	lds	r26, 0x04D8
    212a:	b0 91 d9 04 	lds	r27, 0x04D9
    212e:	cd 91       	ld	r28, X+
    2130:	cd bf       	out	0x3d, r28	; 61
    2132:	dd 91       	ld	r29, X+
    2134:	de bf       	out	0x3e, r29	; 62
    2136:	ff 91       	pop	r31
    2138:	ef 91       	pop	r30
    213a:	df 91       	pop	r29
    213c:	cf 91       	pop	r28
    213e:	bf 91       	pop	r27
    2140:	af 91       	pop	r26
    2142:	9f 91       	pop	r25
    2144:	8f 91       	pop	r24
    2146:	7f 91       	pop	r23
    2148:	6f 91       	pop	r22
    214a:	5f 91       	pop	r21
    214c:	4f 91       	pop	r20
    214e:	3f 91       	pop	r19
    2150:	2f 91       	pop	r18
    2152:	1f 91       	pop	r17
    2154:	0f 91       	pop	r16
    2156:	ff 90       	pop	r15
    2158:	ef 90       	pop	r14
    215a:	df 90       	pop	r13
    215c:	cf 90       	pop	r12
    215e:	bf 90       	pop	r11
    2160:	af 90       	pop	r10
    2162:	9f 90       	pop	r9
    2164:	8f 90       	pop	r8
    2166:	7f 90       	pop	r7
    2168:	6f 90       	pop	r6
    216a:	5f 90       	pop	r5
    216c:	4f 90       	pop	r4
    216e:	3f 90       	pop	r3
    2170:	2f 90       	pop	r2
    2172:	1f 90       	pop	r1
    2174:	0f 90       	pop	r0
    2176:	0f be       	out	0x3f, r0	; 63
    2178:	0f 90       	pop	r0

	asm volatile ( "ret" );
    217a:	08 95       	ret

0000217c <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    217c:	df 93       	push	r29
    217e:	cf 93       	push	r28
    2180:	00 d0       	rcall	.+0      	; 0x2182 <prvSetupTimerInterrupt+0x6>
    2182:	00 d0       	rcall	.+0      	; 0x2184 <prvSetupTimerInterrupt+0x8>
    2184:	00 d0       	rcall	.+0      	; 0x2186 <prvSetupTimerInterrupt+0xa>
    2186:	cd b7       	in	r28, 0x3d	; 61
    2188:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    218a:	80 e8       	ldi	r24, 0x80	; 128
    218c:	9e e3       	ldi	r25, 0x3E	; 62
    218e:	a0 e0       	ldi	r26, 0x00	; 0
    2190:	b0 e0       	ldi	r27, 0x00	; 0
    2192:	8b 83       	std	Y+3, r24	; 0x03
    2194:	9c 83       	std	Y+4, r25	; 0x04
    2196:	ad 83       	std	Y+5, r26	; 0x05
    2198:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    219a:	8b 81       	ldd	r24, Y+3	; 0x03
    219c:	9c 81       	ldd	r25, Y+4	; 0x04
    219e:	ad 81       	ldd	r26, Y+5	; 0x05
    21a0:	be 81       	ldd	r27, Y+6	; 0x06
    21a2:	68 94       	set
    21a4:	15 f8       	bld	r1, 5
    21a6:	b6 95       	lsr	r27
    21a8:	a7 95       	ror	r26
    21aa:	97 95       	ror	r25
    21ac:	87 95       	ror	r24
    21ae:	16 94       	lsr	r1
    21b0:	d1 f7       	brne	.-12     	; 0x21a6 <prvSetupTimerInterrupt+0x2a>
    21b2:	8b 83       	std	Y+3, r24	; 0x03
    21b4:	9c 83       	std	Y+4, r25	; 0x04
    21b6:	ad 83       	std	Y+5, r26	; 0x05
    21b8:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    21ba:	8b 81       	ldd	r24, Y+3	; 0x03
    21bc:	9c 81       	ldd	r25, Y+4	; 0x04
    21be:	ad 81       	ldd	r26, Y+5	; 0x05
    21c0:	be 81       	ldd	r27, Y+6	; 0x06
    21c2:	01 97       	sbiw	r24, 0x01	; 1
    21c4:	a1 09       	sbc	r26, r1
    21c6:	b1 09       	sbc	r27, r1
    21c8:	8b 83       	std	Y+3, r24	; 0x03
    21ca:	9c 83       	std	Y+4, r25	; 0x04
    21cc:	ad 83       	std	Y+5, r26	; 0x05
    21ce:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    21d0:	8b 81       	ldd	r24, Y+3	; 0x03
    21d2:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    21d4:	8b 81       	ldd	r24, Y+3	; 0x03
    21d6:	9c 81       	ldd	r25, Y+4	; 0x04
    21d8:	ad 81       	ldd	r26, Y+5	; 0x05
    21da:	be 81       	ldd	r27, Y+6	; 0x06
    21dc:	89 2f       	mov	r24, r25
    21de:	9a 2f       	mov	r25, r26
    21e0:	ab 2f       	mov	r26, r27
    21e2:	bb 27       	eor	r27, r27
    21e4:	8b 83       	std	Y+3, r24	; 0x03
    21e6:	9c 83       	std	Y+4, r25	; 0x04
    21e8:	ad 83       	std	Y+5, r26	; 0x05
    21ea:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    21ec:	8b 81       	ldd	r24, Y+3	; 0x03
    21ee:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    21f0:	eb e4       	ldi	r30, 0x4B	; 75
    21f2:	f0 e0       	ldi	r31, 0x00	; 0
    21f4:	8a 81       	ldd	r24, Y+2	; 0x02
    21f6:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    21f8:	ea e4       	ldi	r30, 0x4A	; 74
    21fa:	f0 e0       	ldi	r31, 0x00	; 0
    21fc:	89 81       	ldd	r24, Y+1	; 0x01
    21fe:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    2200:	8b e0       	ldi	r24, 0x0B	; 11
    2202:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    2204:	ee e4       	ldi	r30, 0x4E	; 78
    2206:	f0 e0       	ldi	r31, 0x00	; 0
    2208:	89 81       	ldd	r24, Y+1	; 0x01
    220a:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    220c:	e9 e5       	ldi	r30, 0x59	; 89
    220e:	f0 e0       	ldi	r31, 0x00	; 0
    2210:	80 81       	ld	r24, Z
    2212:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    2214:	89 81       	ldd	r24, Y+1	; 0x01
    2216:	80 61       	ori	r24, 0x10	; 16
    2218:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    221a:	e9 e5       	ldi	r30, 0x59	; 89
    221c:	f0 e0       	ldi	r31, 0x00	; 0
    221e:	89 81       	ldd	r24, Y+1	; 0x01
    2220:	80 83       	st	Z, r24
}
    2222:	26 96       	adiw	r28, 0x06	; 6
    2224:	0f b6       	in	r0, 0x3f	; 63
    2226:	f8 94       	cli
    2228:	de bf       	out	0x3e, r29	; 62
    222a:	0f be       	out	0x3f, r0	; 63
    222c:	cd bf       	out	0x3d, r28	; 61
    222e:	cf 91       	pop	r28
    2230:	df 91       	pop	r29
    2232:	08 95       	ret

00002234 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    2234:	0e 94 63 10 	call	0x20c6	; 0x20c6 <vPortYieldFromTick>
		asm volatile ( "reti" );
    2238:	18 95       	reti

0000223a <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    223a:	df 93       	push	r29
    223c:	cf 93       	push	r28
    223e:	cd b7       	in	r28, 0x3d	; 61
    2240:	de b7       	in	r29, 0x3e	; 62
    2242:	28 97       	sbiw	r28, 0x08	; 8
    2244:	0f b6       	in	r0, 0x3f	; 63
    2246:	f8 94       	cli
    2248:	de bf       	out	0x3e, r29	; 62
    224a:	0f be       	out	0x3f, r0	; 63
    224c:	cd bf       	out	0x3d, r28	; 61
    224e:	8f 83       	std	Y+7, r24	; 0x07
    2250:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    2252:	1a 82       	std	Y+2, r1	; 0x02
    2254:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    2256:	8f 81       	ldd	r24, Y+7	; 0x07
    2258:	88 23       	and	r24, r24
    225a:	09 f4       	brne	.+2      	; 0x225e <xQueueCreate+0x24>
    225c:	8c c0       	rjmp	.+280    	; 0x2376 <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    225e:	8f e1       	ldi	r24, 0x1F	; 31
    2260:	90 e0       	ldi	r25, 0x00	; 0
    2262:	0e 94 a4 0c 	call	0x1948	; 0x1948 <pvPortMalloc>
    2266:	9e 83       	std	Y+6, r25	; 0x06
    2268:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    226a:	8d 81       	ldd	r24, Y+5	; 0x05
    226c:	9e 81       	ldd	r25, Y+6	; 0x06
    226e:	00 97       	sbiw	r24, 0x00	; 0
    2270:	09 f4       	brne	.+2      	; 0x2274 <xQueueCreate+0x3a>
    2272:	81 c0       	rjmp	.+258    	; 0x2376 <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    2274:	8f 81       	ldd	r24, Y+7	; 0x07
    2276:	28 2f       	mov	r18, r24
    2278:	30 e0       	ldi	r19, 0x00	; 0
    227a:	88 85       	ldd	r24, Y+8	; 0x08
    227c:	88 2f       	mov	r24, r24
    227e:	90 e0       	ldi	r25, 0x00	; 0
    2280:	ac 01       	movw	r20, r24
    2282:	24 9f       	mul	r18, r20
    2284:	c0 01       	movw	r24, r0
    2286:	25 9f       	mul	r18, r21
    2288:	90 0d       	add	r25, r0
    228a:	34 9f       	mul	r19, r20
    228c:	90 0d       	add	r25, r0
    228e:	11 24       	eor	r1, r1
    2290:	01 96       	adiw	r24, 0x01	; 1
    2292:	9c 83       	std	Y+4, r25	; 0x04
    2294:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    2296:	8b 81       	ldd	r24, Y+3	; 0x03
    2298:	9c 81       	ldd	r25, Y+4	; 0x04
    229a:	0e 94 a4 0c 	call	0x1948	; 0x1948 <pvPortMalloc>
    229e:	ed 81       	ldd	r30, Y+5	; 0x05
    22a0:	fe 81       	ldd	r31, Y+6	; 0x06
    22a2:	91 83       	std	Z+1, r25	; 0x01
    22a4:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    22a6:	ed 81       	ldd	r30, Y+5	; 0x05
    22a8:	fe 81       	ldd	r31, Y+6	; 0x06
    22aa:	80 81       	ld	r24, Z
    22ac:	91 81       	ldd	r25, Z+1	; 0x01
    22ae:	00 97       	sbiw	r24, 0x00	; 0
    22b0:	09 f4       	brne	.+2      	; 0x22b4 <xQueueCreate+0x7a>
    22b2:	5d c0       	rjmp	.+186    	; 0x236e <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    22b4:	ed 81       	ldd	r30, Y+5	; 0x05
    22b6:	fe 81       	ldd	r31, Y+6	; 0x06
    22b8:	40 81       	ld	r20, Z
    22ba:	51 81       	ldd	r21, Z+1	; 0x01
    22bc:	8f 81       	ldd	r24, Y+7	; 0x07
    22be:	28 2f       	mov	r18, r24
    22c0:	30 e0       	ldi	r19, 0x00	; 0
    22c2:	88 85       	ldd	r24, Y+8	; 0x08
    22c4:	88 2f       	mov	r24, r24
    22c6:	90 e0       	ldi	r25, 0x00	; 0
    22c8:	bc 01       	movw	r22, r24
    22ca:	26 9f       	mul	r18, r22
    22cc:	c0 01       	movw	r24, r0
    22ce:	27 9f       	mul	r18, r23
    22d0:	90 0d       	add	r25, r0
    22d2:	36 9f       	mul	r19, r22
    22d4:	90 0d       	add	r25, r0
    22d6:	11 24       	eor	r1, r1
    22d8:	84 0f       	add	r24, r20
    22da:	95 1f       	adc	r25, r21
    22dc:	ed 81       	ldd	r30, Y+5	; 0x05
    22de:	fe 81       	ldd	r31, Y+6	; 0x06
    22e0:	93 83       	std	Z+3, r25	; 0x03
    22e2:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    22e4:	ed 81       	ldd	r30, Y+5	; 0x05
    22e6:	fe 81       	ldd	r31, Y+6	; 0x06
    22e8:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    22ea:	ed 81       	ldd	r30, Y+5	; 0x05
    22ec:	fe 81       	ldd	r31, Y+6	; 0x06
    22ee:	80 81       	ld	r24, Z
    22f0:	91 81       	ldd	r25, Z+1	; 0x01
    22f2:	ed 81       	ldd	r30, Y+5	; 0x05
    22f4:	fe 81       	ldd	r31, Y+6	; 0x06
    22f6:	95 83       	std	Z+5, r25	; 0x05
    22f8:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    22fa:	ed 81       	ldd	r30, Y+5	; 0x05
    22fc:	fe 81       	ldd	r31, Y+6	; 0x06
    22fe:	40 81       	ld	r20, Z
    2300:	51 81       	ldd	r21, Z+1	; 0x01
    2302:	8f 81       	ldd	r24, Y+7	; 0x07
    2304:	88 2f       	mov	r24, r24
    2306:	90 e0       	ldi	r25, 0x00	; 0
    2308:	9c 01       	movw	r18, r24
    230a:	21 50       	subi	r18, 0x01	; 1
    230c:	30 40       	sbci	r19, 0x00	; 0
    230e:	88 85       	ldd	r24, Y+8	; 0x08
    2310:	88 2f       	mov	r24, r24
    2312:	90 e0       	ldi	r25, 0x00	; 0
    2314:	bc 01       	movw	r22, r24
    2316:	26 9f       	mul	r18, r22
    2318:	c0 01       	movw	r24, r0
    231a:	27 9f       	mul	r18, r23
    231c:	90 0d       	add	r25, r0
    231e:	36 9f       	mul	r19, r22
    2320:	90 0d       	add	r25, r0
    2322:	11 24       	eor	r1, r1
    2324:	84 0f       	add	r24, r20
    2326:	95 1f       	adc	r25, r21
    2328:	ed 81       	ldd	r30, Y+5	; 0x05
    232a:	fe 81       	ldd	r31, Y+6	; 0x06
    232c:	97 83       	std	Z+7, r25	; 0x07
    232e:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    2330:	ed 81       	ldd	r30, Y+5	; 0x05
    2332:	fe 81       	ldd	r31, Y+6	; 0x06
    2334:	8f 81       	ldd	r24, Y+7	; 0x07
    2336:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    2338:	ed 81       	ldd	r30, Y+5	; 0x05
    233a:	fe 81       	ldd	r31, Y+6	; 0x06
    233c:	88 85       	ldd	r24, Y+8	; 0x08
    233e:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    2340:	ed 81       	ldd	r30, Y+5	; 0x05
    2342:	fe 81       	ldd	r31, Y+6	; 0x06
    2344:	8f ef       	ldi	r24, 0xFF	; 255
    2346:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    2348:	ed 81       	ldd	r30, Y+5	; 0x05
    234a:	fe 81       	ldd	r31, Y+6	; 0x06
    234c:	8f ef       	ldi	r24, 0xFF	; 255
    234e:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    2350:	8d 81       	ldd	r24, Y+5	; 0x05
    2352:	9e 81       	ldd	r25, Y+6	; 0x06
    2354:	08 96       	adiw	r24, 0x08	; 8
    2356:	0e 94 10 0d 	call	0x1a20	; 0x1a20 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    235a:	8d 81       	ldd	r24, Y+5	; 0x05
    235c:	9e 81       	ldd	r25, Y+6	; 0x06
    235e:	41 96       	adiw	r24, 0x11	; 17
    2360:	0e 94 10 0d 	call	0x1a20	; 0x1a20 <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    2364:	8d 81       	ldd	r24, Y+5	; 0x05
    2366:	9e 81       	ldd	r25, Y+6	; 0x06
    2368:	9a 83       	std	Y+2, r25	; 0x02
    236a:	89 83       	std	Y+1, r24	; 0x01
    236c:	04 c0       	rjmp	.+8      	; 0x2376 <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    236e:	8d 81       	ldd	r24, Y+5	; 0x05
    2370:	9e 81       	ldd	r25, Y+6	; 0x06
    2372:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    2376:	89 81       	ldd	r24, Y+1	; 0x01
    2378:	9a 81       	ldd	r25, Y+2	; 0x02
}
    237a:	28 96       	adiw	r28, 0x08	; 8
    237c:	0f b6       	in	r0, 0x3f	; 63
    237e:	f8 94       	cli
    2380:	de bf       	out	0x3e, r29	; 62
    2382:	0f be       	out	0x3f, r0	; 63
    2384:	cd bf       	out	0x3d, r28	; 61
    2386:	cf 91       	pop	r28
    2388:	df 91       	pop	r29
    238a:	08 95       	ret

0000238c <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    238c:	df 93       	push	r29
    238e:	cf 93       	push	r28
    2390:	cd b7       	in	r28, 0x3d	; 61
    2392:	de b7       	in	r29, 0x3e	; 62
    2394:	2c 97       	sbiw	r28, 0x0c	; 12
    2396:	0f b6       	in	r0, 0x3f	; 63
    2398:	f8 94       	cli
    239a:	de bf       	out	0x3e, r29	; 62
    239c:	0f be       	out	0x3f, r0	; 63
    239e:	cd bf       	out	0x3d, r28	; 61
    23a0:	9e 83       	std	Y+6, r25	; 0x06
    23a2:	8d 83       	std	Y+5, r24	; 0x05
    23a4:	78 87       	std	Y+8, r23	; 0x08
    23a6:	6f 83       	std	Y+7, r22	; 0x07
    23a8:	5a 87       	std	Y+10, r21	; 0x0a
    23aa:	49 87       	std	Y+9, r20	; 0x09
    23ac:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    23ae:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    23b0:	0f b6       	in	r0, 0x3f	; 63
    23b2:	f8 94       	cli
    23b4:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    23b6:	ed 81       	ldd	r30, Y+5	; 0x05
    23b8:	fe 81       	ldd	r31, Y+6	; 0x06
    23ba:	92 8d       	ldd	r25, Z+26	; 0x1a
    23bc:	ed 81       	ldd	r30, Y+5	; 0x05
    23be:	fe 81       	ldd	r31, Y+6	; 0x06
    23c0:	83 8d       	ldd	r24, Z+27	; 0x1b
    23c2:	98 17       	cp	r25, r24
    23c4:	d8 f4       	brcc	.+54     	; 0x23fc <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    23c6:	8d 81       	ldd	r24, Y+5	; 0x05
    23c8:	9e 81       	ldd	r25, Y+6	; 0x06
    23ca:	2f 81       	ldd	r18, Y+7	; 0x07
    23cc:	38 85       	ldd	r19, Y+8	; 0x08
    23ce:	b9 01       	movw	r22, r18
    23d0:	4b 85       	ldd	r20, Y+11	; 0x0b
    23d2:	0e 94 01 14 	call	0x2802	; 0x2802 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    23d6:	ed 81       	ldd	r30, Y+5	; 0x05
    23d8:	fe 81       	ldd	r31, Y+6	; 0x06
    23da:	81 89       	ldd	r24, Z+17	; 0x11
    23dc:	88 23       	and	r24, r24
    23de:	49 f0       	breq	.+18     	; 0x23f2 <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    23e0:	8d 81       	ldd	r24, Y+5	; 0x05
    23e2:	9e 81       	ldd	r25, Y+6	; 0x06
    23e4:	41 96       	adiw	r24, 0x11	; 17
    23e6:	0e 94 16 1a 	call	0x342c	; 0x342c <xTaskRemoveFromEventList>
    23ea:	81 30       	cpi	r24, 0x01	; 1
    23ec:	11 f4       	brne	.+4      	; 0x23f2 <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    23ee:	0e 94 0a 10 	call	0x2014	; 0x2014 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    23f2:	0f 90       	pop	r0
    23f4:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    23f6:	81 e0       	ldi	r24, 0x01	; 1
    23f8:	8c 87       	std	Y+12, r24	; 0x0c
    23fa:	5c c0       	rjmp	.+184    	; 0x24b4 <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    23fc:	89 85       	ldd	r24, Y+9	; 0x09
    23fe:	9a 85       	ldd	r25, Y+10	; 0x0a
    2400:	00 97       	sbiw	r24, 0x00	; 0
    2402:	21 f4       	brne	.+8      	; 0x240c <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2404:	0f 90       	pop	r0
    2406:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    2408:	1c 86       	std	Y+12, r1	; 0x0c
    240a:	54 c0       	rjmp	.+168    	; 0x24b4 <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    240c:	89 81       	ldd	r24, Y+1	; 0x01
    240e:	88 23       	and	r24, r24
    2410:	31 f4       	brne	.+12     	; 0x241e <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2412:	ce 01       	movw	r24, r28
    2414:	02 96       	adiw	r24, 0x02	; 2
    2416:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    241a:	81 e0       	ldi	r24, 0x01	; 1
    241c:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    241e:	0f 90       	pop	r0
    2420:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2422:	0e 94 da 17 	call	0x2fb4	; 0x2fb4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2426:	0f b6       	in	r0, 0x3f	; 63
    2428:	f8 94       	cli
    242a:	0f 92       	push	r0
    242c:	ed 81       	ldd	r30, Y+5	; 0x05
    242e:	fe 81       	ldd	r31, Y+6	; 0x06
    2430:	85 8d       	ldd	r24, Z+29	; 0x1d
    2432:	8f 3f       	cpi	r24, 0xFF	; 255
    2434:	19 f4       	brne	.+6      	; 0x243c <xQueueGenericSend+0xb0>
    2436:	ed 81       	ldd	r30, Y+5	; 0x05
    2438:	fe 81       	ldd	r31, Y+6	; 0x06
    243a:	15 8e       	std	Z+29, r1	; 0x1d
    243c:	ed 81       	ldd	r30, Y+5	; 0x05
    243e:	fe 81       	ldd	r31, Y+6	; 0x06
    2440:	86 8d       	ldd	r24, Z+30	; 0x1e
    2442:	8f 3f       	cpi	r24, 0xFF	; 255
    2444:	19 f4       	brne	.+6      	; 0x244c <xQueueGenericSend+0xc0>
    2446:	ed 81       	ldd	r30, Y+5	; 0x05
    2448:	fe 81       	ldd	r31, Y+6	; 0x06
    244a:	16 8e       	std	Z+30, r1	; 0x1e
    244c:	0f 90       	pop	r0
    244e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2450:	ce 01       	movw	r24, r28
    2452:	02 96       	adiw	r24, 0x02	; 2
    2454:	9e 01       	movw	r18, r28
    2456:	27 5f       	subi	r18, 0xF7	; 247
    2458:	3f 4f       	sbci	r19, 0xFF	; 255
    245a:	b9 01       	movw	r22, r18
    245c:	0e 94 97 1a 	call	0x352e	; 0x352e <xTaskCheckForTimeOut>
    2460:	88 23       	and	r24, r24
    2462:	09 f5       	brne	.+66     	; 0x24a6 <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    2464:	8d 81       	ldd	r24, Y+5	; 0x05
    2466:	9e 81       	ldd	r25, Y+6	; 0x06
    2468:	0e 94 65 15 	call	0x2aca	; 0x2aca <prvIsQueueFull>
    246c:	88 23       	and	r24, r24
    246e:	a1 f0       	breq	.+40     	; 0x2498 <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2470:	8d 81       	ldd	r24, Y+5	; 0x05
    2472:	9e 81       	ldd	r25, Y+6	; 0x06
    2474:	08 96       	adiw	r24, 0x08	; 8
    2476:	29 85       	ldd	r18, Y+9	; 0x09
    2478:	3a 85       	ldd	r19, Y+10	; 0x0a
    247a:	b9 01       	movw	r22, r18
    247c:	0e 94 e0 19 	call	0x33c0	; 0x33c0 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    2480:	8d 81       	ldd	r24, Y+5	; 0x05
    2482:	9e 81       	ldd	r25, Y+6	; 0x06
    2484:	0e 94 de 14 	call	0x29bc	; 0x29bc <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    2488:	0e 94 e6 17 	call	0x2fcc	; 0x2fcc <xTaskResumeAll>
    248c:	88 23       	and	r24, r24
    248e:	09 f0       	breq	.+2      	; 0x2492 <xQueueGenericSend+0x106>
    2490:	8f cf       	rjmp	.-226    	; 0x23b0 <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    2492:	0e 94 0a 10 	call	0x2014	; 0x2014 <vPortYield>
    2496:	8c cf       	rjmp	.-232    	; 0x23b0 <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2498:	8d 81       	ldd	r24, Y+5	; 0x05
    249a:	9e 81       	ldd	r25, Y+6	; 0x06
    249c:	0e 94 de 14 	call	0x29bc	; 0x29bc <prvUnlockQueue>
				( void ) xTaskResumeAll();
    24a0:	0e 94 e6 17 	call	0x2fcc	; 0x2fcc <xTaskResumeAll>
    24a4:	85 cf       	rjmp	.-246    	; 0x23b0 <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    24a6:	8d 81       	ldd	r24, Y+5	; 0x05
    24a8:	9e 81       	ldd	r25, Y+6	; 0x06
    24aa:	0e 94 de 14 	call	0x29bc	; 0x29bc <prvUnlockQueue>
			( void ) xTaskResumeAll();
    24ae:	0e 94 e6 17 	call	0x2fcc	; 0x2fcc <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    24b2:	1c 86       	std	Y+12, r1	; 0x0c
    24b4:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    24b6:	2c 96       	adiw	r28, 0x0c	; 12
    24b8:	0f b6       	in	r0, 0x3f	; 63
    24ba:	f8 94       	cli
    24bc:	de bf       	out	0x3e, r29	; 62
    24be:	0f be       	out	0x3f, r0	; 63
    24c0:	cd bf       	out	0x3d, r28	; 61
    24c2:	cf 91       	pop	r28
    24c4:	df 91       	pop	r29
    24c6:	08 95       	ret

000024c8 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    24c8:	df 93       	push	r29
    24ca:	cf 93       	push	r28
    24cc:	cd b7       	in	r28, 0x3d	; 61
    24ce:	de b7       	in	r29, 0x3e	; 62
    24d0:	29 97       	sbiw	r28, 0x09	; 9
    24d2:	0f b6       	in	r0, 0x3f	; 63
    24d4:	f8 94       	cli
    24d6:	de bf       	out	0x3e, r29	; 62
    24d8:	0f be       	out	0x3f, r0	; 63
    24da:	cd bf       	out	0x3d, r28	; 61
    24dc:	9c 83       	std	Y+4, r25	; 0x04
    24de:	8b 83       	std	Y+3, r24	; 0x03
    24e0:	7e 83       	std	Y+6, r23	; 0x06
    24e2:	6d 83       	std	Y+5, r22	; 0x05
    24e4:	58 87       	std	Y+8, r21	; 0x08
    24e6:	4f 83       	std	Y+7, r20	; 0x07
    24e8:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    24ea:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    24ec:	eb 81       	ldd	r30, Y+3	; 0x03
    24ee:	fc 81       	ldd	r31, Y+4	; 0x04
    24f0:	92 8d       	ldd	r25, Z+26	; 0x1a
    24f2:	eb 81       	ldd	r30, Y+3	; 0x03
    24f4:	fc 81       	ldd	r31, Y+4	; 0x04
    24f6:	83 8d       	ldd	r24, Z+27	; 0x1b
    24f8:	98 17       	cp	r25, r24
    24fa:	40 f5       	brcc	.+80     	; 0x254c <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    24fc:	8b 81       	ldd	r24, Y+3	; 0x03
    24fe:	9c 81       	ldd	r25, Y+4	; 0x04
    2500:	2d 81       	ldd	r18, Y+5	; 0x05
    2502:	3e 81       	ldd	r19, Y+6	; 0x06
    2504:	b9 01       	movw	r22, r18
    2506:	49 85       	ldd	r20, Y+9	; 0x09
    2508:	0e 94 01 14 	call	0x2802	; 0x2802 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    250c:	eb 81       	ldd	r30, Y+3	; 0x03
    250e:	fc 81       	ldd	r31, Y+4	; 0x04
    2510:	86 8d       	ldd	r24, Z+30	; 0x1e
    2512:	8f 3f       	cpi	r24, 0xFF	; 255
    2514:	89 f4       	brne	.+34     	; 0x2538 <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2516:	eb 81       	ldd	r30, Y+3	; 0x03
    2518:	fc 81       	ldd	r31, Y+4	; 0x04
    251a:	81 89       	ldd	r24, Z+17	; 0x11
    251c:	88 23       	and	r24, r24
    251e:	99 f0       	breq	.+38     	; 0x2546 <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2520:	8b 81       	ldd	r24, Y+3	; 0x03
    2522:	9c 81       	ldd	r25, Y+4	; 0x04
    2524:	41 96       	adiw	r24, 0x11	; 17
    2526:	0e 94 16 1a 	call	0x342c	; 0x342c <xTaskRemoveFromEventList>
    252a:	88 23       	and	r24, r24
    252c:	61 f0       	breq	.+24     	; 0x2546 <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    252e:	ef 81       	ldd	r30, Y+7	; 0x07
    2530:	f8 85       	ldd	r31, Y+8	; 0x08
    2532:	81 e0       	ldi	r24, 0x01	; 1
    2534:	80 83       	st	Z, r24
    2536:	07 c0       	rjmp	.+14     	; 0x2546 <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    2538:	eb 81       	ldd	r30, Y+3	; 0x03
    253a:	fc 81       	ldd	r31, Y+4	; 0x04
    253c:	86 8d       	ldd	r24, Z+30	; 0x1e
    253e:	8f 5f       	subi	r24, 0xFF	; 255
    2540:	eb 81       	ldd	r30, Y+3	; 0x03
    2542:	fc 81       	ldd	r31, Y+4	; 0x04
    2544:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    2546:	81 e0       	ldi	r24, 0x01	; 1
    2548:	8a 83       	std	Y+2, r24	; 0x02
    254a:	01 c0       	rjmp	.+2      	; 0x254e <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    254c:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    254e:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2550:	29 96       	adiw	r28, 0x09	; 9
    2552:	0f b6       	in	r0, 0x3f	; 63
    2554:	f8 94       	cli
    2556:	de bf       	out	0x3e, r29	; 62
    2558:	0f be       	out	0x3f, r0	; 63
    255a:	cd bf       	out	0x3d, r28	; 61
    255c:	cf 91       	pop	r28
    255e:	df 91       	pop	r29
    2560:	08 95       	ret

00002562 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    2562:	df 93       	push	r29
    2564:	cf 93       	push	r28
    2566:	cd b7       	in	r28, 0x3d	; 61
    2568:	de b7       	in	r29, 0x3e	; 62
    256a:	2e 97       	sbiw	r28, 0x0e	; 14
    256c:	0f b6       	in	r0, 0x3f	; 63
    256e:	f8 94       	cli
    2570:	de bf       	out	0x3e, r29	; 62
    2572:	0f be       	out	0x3f, r0	; 63
    2574:	cd bf       	out	0x3d, r28	; 61
    2576:	98 87       	std	Y+8, r25	; 0x08
    2578:	8f 83       	std	Y+7, r24	; 0x07
    257a:	7a 87       	std	Y+10, r23	; 0x0a
    257c:	69 87       	std	Y+9, r22	; 0x09
    257e:	5c 87       	std	Y+12, r21	; 0x0c
    2580:	4b 87       	std	Y+11, r20	; 0x0b
    2582:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    2584:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    2586:	0f b6       	in	r0, 0x3f	; 63
    2588:	f8 94       	cli
    258a:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    258c:	ef 81       	ldd	r30, Y+7	; 0x07
    258e:	f8 85       	ldd	r31, Y+8	; 0x08
    2590:	82 8d       	ldd	r24, Z+26	; 0x1a
    2592:	88 23       	and	r24, r24
    2594:	09 f4       	brne	.+2      	; 0x2598 <xQueueGenericReceive+0x36>
    2596:	3f c0       	rjmp	.+126    	; 0x2616 <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    2598:	ef 81       	ldd	r30, Y+7	; 0x07
    259a:	f8 85       	ldd	r31, Y+8	; 0x08
    259c:	86 81       	ldd	r24, Z+6	; 0x06
    259e:	97 81       	ldd	r25, Z+7	; 0x07
    25a0:	9a 83       	std	Y+2, r25	; 0x02
    25a2:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    25a4:	8f 81       	ldd	r24, Y+7	; 0x07
    25a6:	98 85       	ldd	r25, Y+8	; 0x08
    25a8:	29 85       	ldd	r18, Y+9	; 0x09
    25aa:	3a 85       	ldd	r19, Y+10	; 0x0a
    25ac:	b9 01       	movw	r22, r18
    25ae:	0e 94 96 14 	call	0x292c	; 0x292c <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    25b2:	8d 85       	ldd	r24, Y+13	; 0x0d
    25b4:	88 23       	and	r24, r24
    25b6:	b1 f4       	brne	.+44     	; 0x25e4 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    25b8:	ef 81       	ldd	r30, Y+7	; 0x07
    25ba:	f8 85       	ldd	r31, Y+8	; 0x08
    25bc:	82 8d       	ldd	r24, Z+26	; 0x1a
    25be:	81 50       	subi	r24, 0x01	; 1
    25c0:	ef 81       	ldd	r30, Y+7	; 0x07
    25c2:	f8 85       	ldd	r31, Y+8	; 0x08
    25c4:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    25c6:	ef 81       	ldd	r30, Y+7	; 0x07
    25c8:	f8 85       	ldd	r31, Y+8	; 0x08
    25ca:	80 85       	ldd	r24, Z+8	; 0x08
    25cc:	88 23       	and	r24, r24
    25ce:	f1 f0       	breq	.+60     	; 0x260c <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    25d0:	8f 81       	ldd	r24, Y+7	; 0x07
    25d2:	98 85       	ldd	r25, Y+8	; 0x08
    25d4:	08 96       	adiw	r24, 0x08	; 8
    25d6:	0e 94 16 1a 	call	0x342c	; 0x342c <xTaskRemoveFromEventList>
    25da:	81 30       	cpi	r24, 0x01	; 1
    25dc:	b9 f4       	brne	.+46     	; 0x260c <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    25de:	0e 94 0a 10 	call	0x2014	; 0x2014 <vPortYield>
    25e2:	14 c0       	rjmp	.+40     	; 0x260c <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    25e4:	ef 81       	ldd	r30, Y+7	; 0x07
    25e6:	f8 85       	ldd	r31, Y+8	; 0x08
    25e8:	89 81       	ldd	r24, Y+1	; 0x01
    25ea:	9a 81       	ldd	r25, Y+2	; 0x02
    25ec:	97 83       	std	Z+7, r25	; 0x07
    25ee:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    25f0:	ef 81       	ldd	r30, Y+7	; 0x07
    25f2:	f8 85       	ldd	r31, Y+8	; 0x08
    25f4:	81 89       	ldd	r24, Z+17	; 0x11
    25f6:	88 23       	and	r24, r24
    25f8:	49 f0       	breq	.+18     	; 0x260c <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    25fa:	8f 81       	ldd	r24, Y+7	; 0x07
    25fc:	98 85       	ldd	r25, Y+8	; 0x08
    25fe:	41 96       	adiw	r24, 0x11	; 17
    2600:	0e 94 16 1a 	call	0x342c	; 0x342c <xTaskRemoveFromEventList>
    2604:	88 23       	and	r24, r24
    2606:	11 f0       	breq	.+4      	; 0x260c <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    2608:	0e 94 0a 10 	call	0x2014	; 0x2014 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    260c:	0f 90       	pop	r0
    260e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2610:	81 e0       	ldi	r24, 0x01	; 1
    2612:	8e 87       	std	Y+14, r24	; 0x0e
    2614:	5c c0       	rjmp	.+184    	; 0x26ce <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    2616:	8b 85       	ldd	r24, Y+11	; 0x0b
    2618:	9c 85       	ldd	r25, Y+12	; 0x0c
    261a:	00 97       	sbiw	r24, 0x00	; 0
    261c:	21 f4       	brne	.+8      	; 0x2626 <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    261e:	0f 90       	pop	r0
    2620:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2622:	1e 86       	std	Y+14, r1	; 0x0e
    2624:	54 c0       	rjmp	.+168    	; 0x26ce <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    2626:	8b 81       	ldd	r24, Y+3	; 0x03
    2628:	88 23       	and	r24, r24
    262a:	31 f4       	brne	.+12     	; 0x2638 <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    262c:	ce 01       	movw	r24, r28
    262e:	04 96       	adiw	r24, 0x04	; 4
    2630:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2634:	81 e0       	ldi	r24, 0x01	; 1
    2636:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    2638:	0f 90       	pop	r0
    263a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    263c:	0e 94 da 17 	call	0x2fb4	; 0x2fb4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2640:	0f b6       	in	r0, 0x3f	; 63
    2642:	f8 94       	cli
    2644:	0f 92       	push	r0
    2646:	ef 81       	ldd	r30, Y+7	; 0x07
    2648:	f8 85       	ldd	r31, Y+8	; 0x08
    264a:	85 8d       	ldd	r24, Z+29	; 0x1d
    264c:	8f 3f       	cpi	r24, 0xFF	; 255
    264e:	19 f4       	brne	.+6      	; 0x2656 <xQueueGenericReceive+0xf4>
    2650:	ef 81       	ldd	r30, Y+7	; 0x07
    2652:	f8 85       	ldd	r31, Y+8	; 0x08
    2654:	15 8e       	std	Z+29, r1	; 0x1d
    2656:	ef 81       	ldd	r30, Y+7	; 0x07
    2658:	f8 85       	ldd	r31, Y+8	; 0x08
    265a:	86 8d       	ldd	r24, Z+30	; 0x1e
    265c:	8f 3f       	cpi	r24, 0xFF	; 255
    265e:	19 f4       	brne	.+6      	; 0x2666 <xQueueGenericReceive+0x104>
    2660:	ef 81       	ldd	r30, Y+7	; 0x07
    2662:	f8 85       	ldd	r31, Y+8	; 0x08
    2664:	16 8e       	std	Z+30, r1	; 0x1e
    2666:	0f 90       	pop	r0
    2668:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    266a:	ce 01       	movw	r24, r28
    266c:	04 96       	adiw	r24, 0x04	; 4
    266e:	9e 01       	movw	r18, r28
    2670:	25 5f       	subi	r18, 0xF5	; 245
    2672:	3f 4f       	sbci	r19, 0xFF	; 255
    2674:	b9 01       	movw	r22, r18
    2676:	0e 94 97 1a 	call	0x352e	; 0x352e <xTaskCheckForTimeOut>
    267a:	88 23       	and	r24, r24
    267c:	09 f5       	brne	.+66     	; 0x26c0 <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    267e:	8f 81       	ldd	r24, Y+7	; 0x07
    2680:	98 85       	ldd	r25, Y+8	; 0x08
    2682:	0e 94 32 15 	call	0x2a64	; 0x2a64 <prvIsQueueEmpty>
    2686:	88 23       	and	r24, r24
    2688:	a1 f0       	breq	.+40     	; 0x26b2 <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    268a:	8f 81       	ldd	r24, Y+7	; 0x07
    268c:	98 85       	ldd	r25, Y+8	; 0x08
    268e:	41 96       	adiw	r24, 0x11	; 17
    2690:	2b 85       	ldd	r18, Y+11	; 0x0b
    2692:	3c 85       	ldd	r19, Y+12	; 0x0c
    2694:	b9 01       	movw	r22, r18
    2696:	0e 94 e0 19 	call	0x33c0	; 0x33c0 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    269a:	8f 81       	ldd	r24, Y+7	; 0x07
    269c:	98 85       	ldd	r25, Y+8	; 0x08
    269e:	0e 94 de 14 	call	0x29bc	; 0x29bc <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    26a2:	0e 94 e6 17 	call	0x2fcc	; 0x2fcc <xTaskResumeAll>
    26a6:	88 23       	and	r24, r24
    26a8:	09 f0       	breq	.+2      	; 0x26ac <xQueueGenericReceive+0x14a>
    26aa:	6d cf       	rjmp	.-294    	; 0x2586 <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    26ac:	0e 94 0a 10 	call	0x2014	; 0x2014 <vPortYield>
    26b0:	6a cf       	rjmp	.-300    	; 0x2586 <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    26b2:	8f 81       	ldd	r24, Y+7	; 0x07
    26b4:	98 85       	ldd	r25, Y+8	; 0x08
    26b6:	0e 94 de 14 	call	0x29bc	; 0x29bc <prvUnlockQueue>
				( void ) xTaskResumeAll();
    26ba:	0e 94 e6 17 	call	0x2fcc	; 0x2fcc <xTaskResumeAll>
    26be:	63 cf       	rjmp	.-314    	; 0x2586 <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    26c0:	8f 81       	ldd	r24, Y+7	; 0x07
    26c2:	98 85       	ldd	r25, Y+8	; 0x08
    26c4:	0e 94 de 14 	call	0x29bc	; 0x29bc <prvUnlockQueue>
			( void ) xTaskResumeAll();
    26c8:	0e 94 e6 17 	call	0x2fcc	; 0x2fcc <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    26cc:	1e 86       	std	Y+14, r1	; 0x0e
    26ce:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    26d0:	2e 96       	adiw	r28, 0x0e	; 14
    26d2:	0f b6       	in	r0, 0x3f	; 63
    26d4:	f8 94       	cli
    26d6:	de bf       	out	0x3e, r29	; 62
    26d8:	0f be       	out	0x3f, r0	; 63
    26da:	cd bf       	out	0x3d, r28	; 61
    26dc:	cf 91       	pop	r28
    26de:	df 91       	pop	r29
    26e0:	08 95       	ret

000026e2 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    26e2:	df 93       	push	r29
    26e4:	cf 93       	push	r28
    26e6:	cd b7       	in	r28, 0x3d	; 61
    26e8:	de b7       	in	r29, 0x3e	; 62
    26ea:	28 97       	sbiw	r28, 0x08	; 8
    26ec:	0f b6       	in	r0, 0x3f	; 63
    26ee:	f8 94       	cli
    26f0:	de bf       	out	0x3e, r29	; 62
    26f2:	0f be       	out	0x3f, r0	; 63
    26f4:	cd bf       	out	0x3d, r28	; 61
    26f6:	9c 83       	std	Y+4, r25	; 0x04
    26f8:	8b 83       	std	Y+3, r24	; 0x03
    26fa:	7e 83       	std	Y+6, r23	; 0x06
    26fc:	6d 83       	std	Y+5, r22	; 0x05
    26fe:	58 87       	std	Y+8, r21	; 0x08
    2700:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2702:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    2704:	eb 81       	ldd	r30, Y+3	; 0x03
    2706:	fc 81       	ldd	r31, Y+4	; 0x04
    2708:	82 8d       	ldd	r24, Z+26	; 0x1a
    270a:	88 23       	and	r24, r24
    270c:	71 f1       	breq	.+92     	; 0x276a <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    270e:	8b 81       	ldd	r24, Y+3	; 0x03
    2710:	9c 81       	ldd	r25, Y+4	; 0x04
    2712:	2d 81       	ldd	r18, Y+5	; 0x05
    2714:	3e 81       	ldd	r19, Y+6	; 0x06
    2716:	b9 01       	movw	r22, r18
    2718:	0e 94 96 14 	call	0x292c	; 0x292c <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    271c:	eb 81       	ldd	r30, Y+3	; 0x03
    271e:	fc 81       	ldd	r31, Y+4	; 0x04
    2720:	82 8d       	ldd	r24, Z+26	; 0x1a
    2722:	81 50       	subi	r24, 0x01	; 1
    2724:	eb 81       	ldd	r30, Y+3	; 0x03
    2726:	fc 81       	ldd	r31, Y+4	; 0x04
    2728:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    272a:	eb 81       	ldd	r30, Y+3	; 0x03
    272c:	fc 81       	ldd	r31, Y+4	; 0x04
    272e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2730:	8f 3f       	cpi	r24, 0xFF	; 255
    2732:	89 f4       	brne	.+34     	; 0x2756 <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2734:	eb 81       	ldd	r30, Y+3	; 0x03
    2736:	fc 81       	ldd	r31, Y+4	; 0x04
    2738:	80 85       	ldd	r24, Z+8	; 0x08
    273a:	88 23       	and	r24, r24
    273c:	99 f0       	breq	.+38     	; 0x2764 <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    273e:	8b 81       	ldd	r24, Y+3	; 0x03
    2740:	9c 81       	ldd	r25, Y+4	; 0x04
    2742:	08 96       	adiw	r24, 0x08	; 8
    2744:	0e 94 16 1a 	call	0x342c	; 0x342c <xTaskRemoveFromEventList>
    2748:	88 23       	and	r24, r24
    274a:	61 f0       	breq	.+24     	; 0x2764 <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    274c:	ef 81       	ldd	r30, Y+7	; 0x07
    274e:	f8 85       	ldd	r31, Y+8	; 0x08
    2750:	81 e0       	ldi	r24, 0x01	; 1
    2752:	80 83       	st	Z, r24
    2754:	07 c0       	rjmp	.+14     	; 0x2764 <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    2756:	eb 81       	ldd	r30, Y+3	; 0x03
    2758:	fc 81       	ldd	r31, Y+4	; 0x04
    275a:	85 8d       	ldd	r24, Z+29	; 0x1d
    275c:	8f 5f       	subi	r24, 0xFF	; 255
    275e:	eb 81       	ldd	r30, Y+3	; 0x03
    2760:	fc 81       	ldd	r31, Y+4	; 0x04
    2762:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    2764:	81 e0       	ldi	r24, 0x01	; 1
    2766:	8a 83       	std	Y+2, r24	; 0x02
    2768:	01 c0       	rjmp	.+2      	; 0x276c <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    276a:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    276c:	8a 81       	ldd	r24, Y+2	; 0x02
}
    276e:	28 96       	adiw	r28, 0x08	; 8
    2770:	0f b6       	in	r0, 0x3f	; 63
    2772:	f8 94       	cli
    2774:	de bf       	out	0x3e, r29	; 62
    2776:	0f be       	out	0x3f, r0	; 63
    2778:	cd bf       	out	0x3d, r28	; 61
    277a:	cf 91       	pop	r28
    277c:	df 91       	pop	r29
    277e:	08 95       	ret

00002780 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    2780:	df 93       	push	r29
    2782:	cf 93       	push	r28
    2784:	00 d0       	rcall	.+0      	; 0x2786 <uxQueueMessagesWaiting+0x6>
    2786:	0f 92       	push	r0
    2788:	cd b7       	in	r28, 0x3d	; 61
    278a:	de b7       	in	r29, 0x3e	; 62
    278c:	9b 83       	std	Y+3, r25	; 0x03
    278e:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    2790:	0f b6       	in	r0, 0x3f	; 63
    2792:	f8 94       	cli
    2794:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    2796:	ea 81       	ldd	r30, Y+2	; 0x02
    2798:	fb 81       	ldd	r31, Y+3	; 0x03
    279a:	82 8d       	ldd	r24, Z+26	; 0x1a
    279c:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    279e:	0f 90       	pop	r0
    27a0:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    27a2:	89 81       	ldd	r24, Y+1	; 0x01
}
    27a4:	0f 90       	pop	r0
    27a6:	0f 90       	pop	r0
    27a8:	0f 90       	pop	r0
    27aa:	cf 91       	pop	r28
    27ac:	df 91       	pop	r29
    27ae:	08 95       	ret

000027b0 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    27b0:	df 93       	push	r29
    27b2:	cf 93       	push	r28
    27b4:	00 d0       	rcall	.+0      	; 0x27b6 <uxQueueMessagesWaitingFromISR+0x6>
    27b6:	0f 92       	push	r0
    27b8:	cd b7       	in	r28, 0x3d	; 61
    27ba:	de b7       	in	r29, 0x3e	; 62
    27bc:	9b 83       	std	Y+3, r25	; 0x03
    27be:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    27c0:	ea 81       	ldd	r30, Y+2	; 0x02
    27c2:	fb 81       	ldd	r31, Y+3	; 0x03
    27c4:	82 8d       	ldd	r24, Z+26	; 0x1a
    27c6:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    27c8:	89 81       	ldd	r24, Y+1	; 0x01
}
    27ca:	0f 90       	pop	r0
    27cc:	0f 90       	pop	r0
    27ce:	0f 90       	pop	r0
    27d0:	cf 91       	pop	r28
    27d2:	df 91       	pop	r29
    27d4:	08 95       	ret

000027d6 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    27d6:	df 93       	push	r29
    27d8:	cf 93       	push	r28
    27da:	00 d0       	rcall	.+0      	; 0x27dc <vQueueDelete+0x6>
    27dc:	cd b7       	in	r28, 0x3d	; 61
    27de:	de b7       	in	r29, 0x3e	; 62
    27e0:	9a 83       	std	Y+2, r25	; 0x02
    27e2:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    27e4:	e9 81       	ldd	r30, Y+1	; 0x01
    27e6:	fa 81       	ldd	r31, Y+2	; 0x02
    27e8:	80 81       	ld	r24, Z
    27ea:	91 81       	ldd	r25, Z+1	; 0x01
    27ec:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <vPortFree>
	vPortFree( pxQueue );
    27f0:	89 81       	ldd	r24, Y+1	; 0x01
    27f2:	9a 81       	ldd	r25, Y+2	; 0x02
    27f4:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <vPortFree>
}
    27f8:	0f 90       	pop	r0
    27fa:	0f 90       	pop	r0
    27fc:	cf 91       	pop	r28
    27fe:	df 91       	pop	r29
    2800:	08 95       	ret

00002802 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    2802:	df 93       	push	r29
    2804:	cf 93       	push	r28
    2806:	00 d0       	rcall	.+0      	; 0x2808 <prvCopyDataToQueue+0x6>
    2808:	00 d0       	rcall	.+0      	; 0x280a <prvCopyDataToQueue+0x8>
    280a:	0f 92       	push	r0
    280c:	cd b7       	in	r28, 0x3d	; 61
    280e:	de b7       	in	r29, 0x3e	; 62
    2810:	9a 83       	std	Y+2, r25	; 0x02
    2812:	89 83       	std	Y+1, r24	; 0x01
    2814:	7c 83       	std	Y+4, r23	; 0x04
    2816:	6b 83       	std	Y+3, r22	; 0x03
    2818:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    281a:	e9 81       	ldd	r30, Y+1	; 0x01
    281c:	fa 81       	ldd	r31, Y+2	; 0x02
    281e:	84 8d       	ldd	r24, Z+28	; 0x1c
    2820:	88 23       	and	r24, r24
    2822:	09 f4       	brne	.+2      	; 0x2826 <prvCopyDataToQueue+0x24>
    2824:	74 c0       	rjmp	.+232    	; 0x290e <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    2826:	8d 81       	ldd	r24, Y+5	; 0x05
    2828:	88 23       	and	r24, r24
    282a:	99 f5       	brne	.+102    	; 0x2892 <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    282c:	e9 81       	ldd	r30, Y+1	; 0x01
    282e:	fa 81       	ldd	r31, Y+2	; 0x02
    2830:	64 81       	ldd	r22, Z+4	; 0x04
    2832:	75 81       	ldd	r23, Z+5	; 0x05
    2834:	e9 81       	ldd	r30, Y+1	; 0x01
    2836:	fa 81       	ldd	r31, Y+2	; 0x02
    2838:	84 8d       	ldd	r24, Z+28	; 0x1c
    283a:	48 2f       	mov	r20, r24
    283c:	50 e0       	ldi	r21, 0x00	; 0
    283e:	2b 81       	ldd	r18, Y+3	; 0x03
    2840:	3c 81       	ldd	r19, Y+4	; 0x04
    2842:	cb 01       	movw	r24, r22
    2844:	b9 01       	movw	r22, r18
    2846:	0e 94 0f 1e 	call	0x3c1e	; 0x3c1e <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    284a:	e9 81       	ldd	r30, Y+1	; 0x01
    284c:	fa 81       	ldd	r31, Y+2	; 0x02
    284e:	24 81       	ldd	r18, Z+4	; 0x04
    2850:	35 81       	ldd	r19, Z+5	; 0x05
    2852:	e9 81       	ldd	r30, Y+1	; 0x01
    2854:	fa 81       	ldd	r31, Y+2	; 0x02
    2856:	84 8d       	ldd	r24, Z+28	; 0x1c
    2858:	88 2f       	mov	r24, r24
    285a:	90 e0       	ldi	r25, 0x00	; 0
    285c:	82 0f       	add	r24, r18
    285e:	93 1f       	adc	r25, r19
    2860:	e9 81       	ldd	r30, Y+1	; 0x01
    2862:	fa 81       	ldd	r31, Y+2	; 0x02
    2864:	95 83       	std	Z+5, r25	; 0x05
    2866:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    2868:	e9 81       	ldd	r30, Y+1	; 0x01
    286a:	fa 81       	ldd	r31, Y+2	; 0x02
    286c:	24 81       	ldd	r18, Z+4	; 0x04
    286e:	35 81       	ldd	r19, Z+5	; 0x05
    2870:	e9 81       	ldd	r30, Y+1	; 0x01
    2872:	fa 81       	ldd	r31, Y+2	; 0x02
    2874:	82 81       	ldd	r24, Z+2	; 0x02
    2876:	93 81       	ldd	r25, Z+3	; 0x03
    2878:	28 17       	cp	r18, r24
    287a:	39 07       	cpc	r19, r25
    287c:	08 f4       	brcc	.+2      	; 0x2880 <prvCopyDataToQueue+0x7e>
    287e:	47 c0       	rjmp	.+142    	; 0x290e <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    2880:	e9 81       	ldd	r30, Y+1	; 0x01
    2882:	fa 81       	ldd	r31, Y+2	; 0x02
    2884:	80 81       	ld	r24, Z
    2886:	91 81       	ldd	r25, Z+1	; 0x01
    2888:	e9 81       	ldd	r30, Y+1	; 0x01
    288a:	fa 81       	ldd	r31, Y+2	; 0x02
    288c:	95 83       	std	Z+5, r25	; 0x05
    288e:	84 83       	std	Z+4, r24	; 0x04
    2890:	3e c0       	rjmp	.+124    	; 0x290e <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    2892:	e9 81       	ldd	r30, Y+1	; 0x01
    2894:	fa 81       	ldd	r31, Y+2	; 0x02
    2896:	66 81       	ldd	r22, Z+6	; 0x06
    2898:	77 81       	ldd	r23, Z+7	; 0x07
    289a:	e9 81       	ldd	r30, Y+1	; 0x01
    289c:	fa 81       	ldd	r31, Y+2	; 0x02
    289e:	84 8d       	ldd	r24, Z+28	; 0x1c
    28a0:	48 2f       	mov	r20, r24
    28a2:	50 e0       	ldi	r21, 0x00	; 0
    28a4:	2b 81       	ldd	r18, Y+3	; 0x03
    28a6:	3c 81       	ldd	r19, Y+4	; 0x04
    28a8:	cb 01       	movw	r24, r22
    28aa:	b9 01       	movw	r22, r18
    28ac:	0e 94 0f 1e 	call	0x3c1e	; 0x3c1e <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    28b0:	e9 81       	ldd	r30, Y+1	; 0x01
    28b2:	fa 81       	ldd	r31, Y+2	; 0x02
    28b4:	26 81       	ldd	r18, Z+6	; 0x06
    28b6:	37 81       	ldd	r19, Z+7	; 0x07
    28b8:	e9 81       	ldd	r30, Y+1	; 0x01
    28ba:	fa 81       	ldd	r31, Y+2	; 0x02
    28bc:	84 8d       	ldd	r24, Z+28	; 0x1c
    28be:	88 2f       	mov	r24, r24
    28c0:	90 e0       	ldi	r25, 0x00	; 0
    28c2:	90 95       	com	r25
    28c4:	81 95       	neg	r24
    28c6:	9f 4f       	sbci	r25, 0xFF	; 255
    28c8:	82 0f       	add	r24, r18
    28ca:	93 1f       	adc	r25, r19
    28cc:	e9 81       	ldd	r30, Y+1	; 0x01
    28ce:	fa 81       	ldd	r31, Y+2	; 0x02
    28d0:	97 83       	std	Z+7, r25	; 0x07
    28d2:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    28d4:	e9 81       	ldd	r30, Y+1	; 0x01
    28d6:	fa 81       	ldd	r31, Y+2	; 0x02
    28d8:	26 81       	ldd	r18, Z+6	; 0x06
    28da:	37 81       	ldd	r19, Z+7	; 0x07
    28dc:	e9 81       	ldd	r30, Y+1	; 0x01
    28de:	fa 81       	ldd	r31, Y+2	; 0x02
    28e0:	80 81       	ld	r24, Z
    28e2:	91 81       	ldd	r25, Z+1	; 0x01
    28e4:	28 17       	cp	r18, r24
    28e6:	39 07       	cpc	r19, r25
    28e8:	90 f4       	brcc	.+36     	; 0x290e <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    28ea:	e9 81       	ldd	r30, Y+1	; 0x01
    28ec:	fa 81       	ldd	r31, Y+2	; 0x02
    28ee:	22 81       	ldd	r18, Z+2	; 0x02
    28f0:	33 81       	ldd	r19, Z+3	; 0x03
    28f2:	e9 81       	ldd	r30, Y+1	; 0x01
    28f4:	fa 81       	ldd	r31, Y+2	; 0x02
    28f6:	84 8d       	ldd	r24, Z+28	; 0x1c
    28f8:	88 2f       	mov	r24, r24
    28fa:	90 e0       	ldi	r25, 0x00	; 0
    28fc:	90 95       	com	r25
    28fe:	81 95       	neg	r24
    2900:	9f 4f       	sbci	r25, 0xFF	; 255
    2902:	82 0f       	add	r24, r18
    2904:	93 1f       	adc	r25, r19
    2906:	e9 81       	ldd	r30, Y+1	; 0x01
    2908:	fa 81       	ldd	r31, Y+2	; 0x02
    290a:	97 83       	std	Z+7, r25	; 0x07
    290c:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    290e:	e9 81       	ldd	r30, Y+1	; 0x01
    2910:	fa 81       	ldd	r31, Y+2	; 0x02
    2912:	82 8d       	ldd	r24, Z+26	; 0x1a
    2914:	8f 5f       	subi	r24, 0xFF	; 255
    2916:	e9 81       	ldd	r30, Y+1	; 0x01
    2918:	fa 81       	ldd	r31, Y+2	; 0x02
    291a:	82 8f       	std	Z+26, r24	; 0x1a
}
    291c:	0f 90       	pop	r0
    291e:	0f 90       	pop	r0
    2920:	0f 90       	pop	r0
    2922:	0f 90       	pop	r0
    2924:	0f 90       	pop	r0
    2926:	cf 91       	pop	r28
    2928:	df 91       	pop	r29
    292a:	08 95       	ret

0000292c <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    292c:	df 93       	push	r29
    292e:	cf 93       	push	r28
    2930:	00 d0       	rcall	.+0      	; 0x2932 <prvCopyDataFromQueue+0x6>
    2932:	00 d0       	rcall	.+0      	; 0x2934 <prvCopyDataFromQueue+0x8>
    2934:	cd b7       	in	r28, 0x3d	; 61
    2936:	de b7       	in	r29, 0x3e	; 62
    2938:	9a 83       	std	Y+2, r25	; 0x02
    293a:	89 83       	std	Y+1, r24	; 0x01
    293c:	7c 83       	std	Y+4, r23	; 0x04
    293e:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    2940:	e9 81       	ldd	r30, Y+1	; 0x01
    2942:	fa 81       	ldd	r31, Y+2	; 0x02
    2944:	80 81       	ld	r24, Z
    2946:	91 81       	ldd	r25, Z+1	; 0x01
    2948:	00 97       	sbiw	r24, 0x00	; 0
    294a:	89 f1       	breq	.+98     	; 0x29ae <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    294c:	e9 81       	ldd	r30, Y+1	; 0x01
    294e:	fa 81       	ldd	r31, Y+2	; 0x02
    2950:	26 81       	ldd	r18, Z+6	; 0x06
    2952:	37 81       	ldd	r19, Z+7	; 0x07
    2954:	e9 81       	ldd	r30, Y+1	; 0x01
    2956:	fa 81       	ldd	r31, Y+2	; 0x02
    2958:	84 8d       	ldd	r24, Z+28	; 0x1c
    295a:	88 2f       	mov	r24, r24
    295c:	90 e0       	ldi	r25, 0x00	; 0
    295e:	82 0f       	add	r24, r18
    2960:	93 1f       	adc	r25, r19
    2962:	e9 81       	ldd	r30, Y+1	; 0x01
    2964:	fa 81       	ldd	r31, Y+2	; 0x02
    2966:	97 83       	std	Z+7, r25	; 0x07
    2968:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    296a:	e9 81       	ldd	r30, Y+1	; 0x01
    296c:	fa 81       	ldd	r31, Y+2	; 0x02
    296e:	26 81       	ldd	r18, Z+6	; 0x06
    2970:	37 81       	ldd	r19, Z+7	; 0x07
    2972:	e9 81       	ldd	r30, Y+1	; 0x01
    2974:	fa 81       	ldd	r31, Y+2	; 0x02
    2976:	82 81       	ldd	r24, Z+2	; 0x02
    2978:	93 81       	ldd	r25, Z+3	; 0x03
    297a:	28 17       	cp	r18, r24
    297c:	39 07       	cpc	r19, r25
    297e:	40 f0       	brcs	.+16     	; 0x2990 <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    2980:	e9 81       	ldd	r30, Y+1	; 0x01
    2982:	fa 81       	ldd	r31, Y+2	; 0x02
    2984:	80 81       	ld	r24, Z
    2986:	91 81       	ldd	r25, Z+1	; 0x01
    2988:	e9 81       	ldd	r30, Y+1	; 0x01
    298a:	fa 81       	ldd	r31, Y+2	; 0x02
    298c:	97 83       	std	Z+7, r25	; 0x07
    298e:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    2990:	e9 81       	ldd	r30, Y+1	; 0x01
    2992:	fa 81       	ldd	r31, Y+2	; 0x02
    2994:	46 81       	ldd	r20, Z+6	; 0x06
    2996:	57 81       	ldd	r21, Z+7	; 0x07
    2998:	e9 81       	ldd	r30, Y+1	; 0x01
    299a:	fa 81       	ldd	r31, Y+2	; 0x02
    299c:	84 8d       	ldd	r24, Z+28	; 0x1c
    299e:	28 2f       	mov	r18, r24
    29a0:	30 e0       	ldi	r19, 0x00	; 0
    29a2:	8b 81       	ldd	r24, Y+3	; 0x03
    29a4:	9c 81       	ldd	r25, Y+4	; 0x04
    29a6:	ba 01       	movw	r22, r20
    29a8:	a9 01       	movw	r20, r18
    29aa:	0e 94 0f 1e 	call	0x3c1e	; 0x3c1e <memcpy>
	}
}
    29ae:	0f 90       	pop	r0
    29b0:	0f 90       	pop	r0
    29b2:	0f 90       	pop	r0
    29b4:	0f 90       	pop	r0
    29b6:	cf 91       	pop	r28
    29b8:	df 91       	pop	r29
    29ba:	08 95       	ret

000029bc <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    29bc:	df 93       	push	r29
    29be:	cf 93       	push	r28
    29c0:	00 d0       	rcall	.+0      	; 0x29c2 <prvUnlockQueue+0x6>
    29c2:	cd b7       	in	r28, 0x3d	; 61
    29c4:	de b7       	in	r29, 0x3e	; 62
    29c6:	9a 83       	std	Y+2, r25	; 0x02
    29c8:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    29ca:	0f b6       	in	r0, 0x3f	; 63
    29cc:	f8 94       	cli
    29ce:	0f 92       	push	r0
    29d0:	15 c0       	rjmp	.+42     	; 0x29fc <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    29d2:	e9 81       	ldd	r30, Y+1	; 0x01
    29d4:	fa 81       	ldd	r31, Y+2	; 0x02
    29d6:	81 89       	ldd	r24, Z+17	; 0x11
    29d8:	88 23       	and	r24, r24
    29da:	a9 f0       	breq	.+42     	; 0x2a06 <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    29dc:	89 81       	ldd	r24, Y+1	; 0x01
    29de:	9a 81       	ldd	r25, Y+2	; 0x02
    29e0:	41 96       	adiw	r24, 0x11	; 17
    29e2:	0e 94 16 1a 	call	0x342c	; 0x342c <xTaskRemoveFromEventList>
    29e6:	88 23       	and	r24, r24
    29e8:	11 f0       	breq	.+4      	; 0x29ee <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    29ea:	0e 94 f4 1a 	call	0x35e8	; 0x35e8 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    29ee:	e9 81       	ldd	r30, Y+1	; 0x01
    29f0:	fa 81       	ldd	r31, Y+2	; 0x02
    29f2:	86 8d       	ldd	r24, Z+30	; 0x1e
    29f4:	81 50       	subi	r24, 0x01	; 1
    29f6:	e9 81       	ldd	r30, Y+1	; 0x01
    29f8:	fa 81       	ldd	r31, Y+2	; 0x02
    29fa:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    29fc:	e9 81       	ldd	r30, Y+1	; 0x01
    29fe:	fa 81       	ldd	r31, Y+2	; 0x02
    2a00:	86 8d       	ldd	r24, Z+30	; 0x1e
    2a02:	18 16       	cp	r1, r24
    2a04:	34 f3       	brlt	.-52     	; 0x29d2 <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    2a06:	e9 81       	ldd	r30, Y+1	; 0x01
    2a08:	fa 81       	ldd	r31, Y+2	; 0x02
    2a0a:	8f ef       	ldi	r24, 0xFF	; 255
    2a0c:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    2a0e:	0f 90       	pop	r0
    2a10:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    2a12:	0f b6       	in	r0, 0x3f	; 63
    2a14:	f8 94       	cli
    2a16:	0f 92       	push	r0
    2a18:	15 c0       	rjmp	.+42     	; 0x2a44 <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2a1a:	e9 81       	ldd	r30, Y+1	; 0x01
    2a1c:	fa 81       	ldd	r31, Y+2	; 0x02
    2a1e:	80 85       	ldd	r24, Z+8	; 0x08
    2a20:	88 23       	and	r24, r24
    2a22:	a9 f0       	breq	.+42     	; 0x2a4e <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2a24:	89 81       	ldd	r24, Y+1	; 0x01
    2a26:	9a 81       	ldd	r25, Y+2	; 0x02
    2a28:	08 96       	adiw	r24, 0x08	; 8
    2a2a:	0e 94 16 1a 	call	0x342c	; 0x342c <xTaskRemoveFromEventList>
    2a2e:	88 23       	and	r24, r24
    2a30:	11 f0       	breq	.+4      	; 0x2a36 <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    2a32:	0e 94 f4 1a 	call	0x35e8	; 0x35e8 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    2a36:	e9 81       	ldd	r30, Y+1	; 0x01
    2a38:	fa 81       	ldd	r31, Y+2	; 0x02
    2a3a:	85 8d       	ldd	r24, Z+29	; 0x1d
    2a3c:	81 50       	subi	r24, 0x01	; 1
    2a3e:	e9 81       	ldd	r30, Y+1	; 0x01
    2a40:	fa 81       	ldd	r31, Y+2	; 0x02
    2a42:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2a44:	e9 81       	ldd	r30, Y+1	; 0x01
    2a46:	fa 81       	ldd	r31, Y+2	; 0x02
    2a48:	85 8d       	ldd	r24, Z+29	; 0x1d
    2a4a:	18 16       	cp	r1, r24
    2a4c:	34 f3       	brlt	.-52     	; 0x2a1a <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    2a4e:	e9 81       	ldd	r30, Y+1	; 0x01
    2a50:	fa 81       	ldd	r31, Y+2	; 0x02
    2a52:	8f ef       	ldi	r24, 0xFF	; 255
    2a54:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    2a56:	0f 90       	pop	r0
    2a58:	0f be       	out	0x3f, r0	; 63
}
    2a5a:	0f 90       	pop	r0
    2a5c:	0f 90       	pop	r0
    2a5e:	cf 91       	pop	r28
    2a60:	df 91       	pop	r29
    2a62:	08 95       	ret

00002a64 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    2a64:	df 93       	push	r29
    2a66:	cf 93       	push	r28
    2a68:	00 d0       	rcall	.+0      	; 0x2a6a <prvIsQueueEmpty+0x6>
    2a6a:	0f 92       	push	r0
    2a6c:	cd b7       	in	r28, 0x3d	; 61
    2a6e:	de b7       	in	r29, 0x3e	; 62
    2a70:	9b 83       	std	Y+3, r25	; 0x03
    2a72:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    2a74:	0f b6       	in	r0, 0x3f	; 63
    2a76:	f8 94       	cli
    2a78:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    2a7a:	ea 81       	ldd	r30, Y+2	; 0x02
    2a7c:	fb 81       	ldd	r31, Y+3	; 0x03
    2a7e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2a80:	19 82       	std	Y+1, r1	; 0x01
    2a82:	88 23       	and	r24, r24
    2a84:	11 f4       	brne	.+4      	; 0x2a8a <prvIsQueueEmpty+0x26>
    2a86:	81 e0       	ldi	r24, 0x01	; 1
    2a88:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    2a8a:	0f 90       	pop	r0
    2a8c:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2a8e:	89 81       	ldd	r24, Y+1	; 0x01
}
    2a90:	0f 90       	pop	r0
    2a92:	0f 90       	pop	r0
    2a94:	0f 90       	pop	r0
    2a96:	cf 91       	pop	r28
    2a98:	df 91       	pop	r29
    2a9a:	08 95       	ret

00002a9c <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    2a9c:	df 93       	push	r29
    2a9e:	cf 93       	push	r28
    2aa0:	00 d0       	rcall	.+0      	; 0x2aa2 <xQueueIsQueueEmptyFromISR+0x6>
    2aa2:	0f 92       	push	r0
    2aa4:	cd b7       	in	r28, 0x3d	; 61
    2aa6:	de b7       	in	r29, 0x3e	; 62
    2aa8:	9b 83       	std	Y+3, r25	; 0x03
    2aaa:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    2aac:	ea 81       	ldd	r30, Y+2	; 0x02
    2aae:	fb 81       	ldd	r31, Y+3	; 0x03
    2ab0:	82 8d       	ldd	r24, Z+26	; 0x1a
    2ab2:	19 82       	std	Y+1, r1	; 0x01
    2ab4:	88 23       	and	r24, r24
    2ab6:	11 f4       	brne	.+4      	; 0x2abc <xQueueIsQueueEmptyFromISR+0x20>
    2ab8:	81 e0       	ldi	r24, 0x01	; 1
    2aba:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    2abc:	89 81       	ldd	r24, Y+1	; 0x01
}
    2abe:	0f 90       	pop	r0
    2ac0:	0f 90       	pop	r0
    2ac2:	0f 90       	pop	r0
    2ac4:	cf 91       	pop	r28
    2ac6:	df 91       	pop	r29
    2ac8:	08 95       	ret

00002aca <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    2aca:	df 93       	push	r29
    2acc:	cf 93       	push	r28
    2ace:	00 d0       	rcall	.+0      	; 0x2ad0 <prvIsQueueFull+0x6>
    2ad0:	0f 92       	push	r0
    2ad2:	cd b7       	in	r28, 0x3d	; 61
    2ad4:	de b7       	in	r29, 0x3e	; 62
    2ad6:	9b 83       	std	Y+3, r25	; 0x03
    2ad8:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    2ada:	0f b6       	in	r0, 0x3f	; 63
    2adc:	f8 94       	cli
    2ade:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    2ae0:	ea 81       	ldd	r30, Y+2	; 0x02
    2ae2:	fb 81       	ldd	r31, Y+3	; 0x03
    2ae4:	92 8d       	ldd	r25, Z+26	; 0x1a
    2ae6:	ea 81       	ldd	r30, Y+2	; 0x02
    2ae8:	fb 81       	ldd	r31, Y+3	; 0x03
    2aea:	83 8d       	ldd	r24, Z+27	; 0x1b
    2aec:	19 82       	std	Y+1, r1	; 0x01
    2aee:	98 17       	cp	r25, r24
    2af0:	11 f4       	brne	.+4      	; 0x2af6 <prvIsQueueFull+0x2c>
    2af2:	81 e0       	ldi	r24, 0x01	; 1
    2af4:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    2af6:	0f 90       	pop	r0
    2af8:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2afa:	89 81       	ldd	r24, Y+1	; 0x01
}
    2afc:	0f 90       	pop	r0
    2afe:	0f 90       	pop	r0
    2b00:	0f 90       	pop	r0
    2b02:	cf 91       	pop	r28
    2b04:	df 91       	pop	r29
    2b06:	08 95       	ret

00002b08 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    2b08:	df 93       	push	r29
    2b0a:	cf 93       	push	r28
    2b0c:	00 d0       	rcall	.+0      	; 0x2b0e <xQueueIsQueueFullFromISR+0x6>
    2b0e:	0f 92       	push	r0
    2b10:	cd b7       	in	r28, 0x3d	; 61
    2b12:	de b7       	in	r29, 0x3e	; 62
    2b14:	9b 83       	std	Y+3, r25	; 0x03
    2b16:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    2b18:	ea 81       	ldd	r30, Y+2	; 0x02
    2b1a:	fb 81       	ldd	r31, Y+3	; 0x03
    2b1c:	92 8d       	ldd	r25, Z+26	; 0x1a
    2b1e:	ea 81       	ldd	r30, Y+2	; 0x02
    2b20:	fb 81       	ldd	r31, Y+3	; 0x03
    2b22:	83 8d       	ldd	r24, Z+27	; 0x1b
    2b24:	19 82       	std	Y+1, r1	; 0x01
    2b26:	98 17       	cp	r25, r24
    2b28:	11 f4       	brne	.+4      	; 0x2b2e <xQueueIsQueueFullFromISR+0x26>
    2b2a:	81 e0       	ldi	r24, 0x01	; 1
    2b2c:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    2b2e:	89 81       	ldd	r24, Y+1	; 0x01
}
    2b30:	0f 90       	pop	r0
    2b32:	0f 90       	pop	r0
    2b34:	0f 90       	pop	r0
    2b36:	cf 91       	pop	r28
    2b38:	df 91       	pop	r29
    2b3a:	08 95       	ret

00002b3c <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    2b3c:	af 92       	push	r10
    2b3e:	bf 92       	push	r11
    2b40:	cf 92       	push	r12
    2b42:	df 92       	push	r13
    2b44:	ef 92       	push	r14
    2b46:	ff 92       	push	r15
    2b48:	0f 93       	push	r16
    2b4a:	1f 93       	push	r17
    2b4c:	df 93       	push	r29
    2b4e:	cf 93       	push	r28
    2b50:	cd b7       	in	r28, 0x3d	; 61
    2b52:	de b7       	in	r29, 0x3e	; 62
    2b54:	64 97       	sbiw	r28, 0x14	; 20
    2b56:	0f b6       	in	r0, 0x3f	; 63
    2b58:	f8 94       	cli
    2b5a:	de bf       	out	0x3e, r29	; 62
    2b5c:	0f be       	out	0x3f, r0	; 63
    2b5e:	cd bf       	out	0x3d, r28	; 61
    2b60:	9f 83       	std	Y+7, r25	; 0x07
    2b62:	8e 83       	std	Y+6, r24	; 0x06
    2b64:	79 87       	std	Y+9, r23	; 0x09
    2b66:	68 87       	std	Y+8, r22	; 0x08
    2b68:	5b 87       	std	Y+11, r21	; 0x0b
    2b6a:	4a 87       	std	Y+10, r20	; 0x0a
    2b6c:	3d 87       	std	Y+13, r19	; 0x0d
    2b6e:	2c 87       	std	Y+12, r18	; 0x0c
    2b70:	0e 87       	std	Y+14, r16	; 0x0e
    2b72:	f8 8a       	std	Y+16, r15	; 0x10
    2b74:	ef 86       	std	Y+15, r14	; 0x0f
    2b76:	da 8a       	std	Y+18, r13	; 0x12
    2b78:	c9 8a       	std	Y+17, r12	; 0x11
    2b7a:	bc 8a       	std	Y+20, r11	; 0x14
    2b7c:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    2b7e:	8a 85       	ldd	r24, Y+10	; 0x0a
    2b80:	9b 85       	ldd	r25, Y+11	; 0x0b
    2b82:	29 89       	ldd	r18, Y+17	; 0x11
    2b84:	3a 89       	ldd	r19, Y+18	; 0x12
    2b86:	b9 01       	movw	r22, r18
    2b88:	0e 94 23 1c 	call	0x3846	; 0x3846 <prvAllocateTCBAndStack>
    2b8c:	9c 83       	std	Y+4, r25	; 0x04
    2b8e:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    2b90:	8b 81       	ldd	r24, Y+3	; 0x03
    2b92:	9c 81       	ldd	r25, Y+4	; 0x04
    2b94:	00 97       	sbiw	r24, 0x00	; 0
    2b96:	09 f4       	brne	.+2      	; 0x2b9a <xTaskGenericCreate+0x5e>
    2b98:	99 c0       	rjmp	.+306    	; 0x2ccc <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    2b9a:	eb 81       	ldd	r30, Y+3	; 0x03
    2b9c:	fc 81       	ldd	r31, Y+4	; 0x04
    2b9e:	27 89       	ldd	r18, Z+23	; 0x17
    2ba0:	30 8d       	ldd	r19, Z+24	; 0x18
    2ba2:	8a 85       	ldd	r24, Y+10	; 0x0a
    2ba4:	9b 85       	ldd	r25, Y+11	; 0x0b
    2ba6:	01 97       	sbiw	r24, 0x01	; 1
    2ba8:	82 0f       	add	r24, r18
    2baa:	93 1f       	adc	r25, r19
    2bac:	9a 83       	std	Y+2, r25	; 0x02
    2bae:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    2bb0:	8b 81       	ldd	r24, Y+3	; 0x03
    2bb2:	9c 81       	ldd	r25, Y+4	; 0x04
    2bb4:	28 85       	ldd	r18, Y+8	; 0x08
    2bb6:	39 85       	ldd	r19, Y+9	; 0x09
    2bb8:	eb 89       	ldd	r30, Y+19	; 0x13
    2bba:	fc 89       	ldd	r31, Y+20	; 0x14
    2bbc:	aa 85       	ldd	r26, Y+10	; 0x0a
    2bbe:	bb 85       	ldd	r27, Y+11	; 0x0b
    2bc0:	b9 01       	movw	r22, r18
    2bc2:	4e 85       	ldd	r20, Y+14	; 0x0e
    2bc4:	9f 01       	movw	r18, r30
    2bc6:	8d 01       	movw	r16, r26
    2bc8:	0e 94 08 1b 	call	0x3610	; 0x3610 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    2bcc:	89 81       	ldd	r24, Y+1	; 0x01
    2bce:	9a 81       	ldd	r25, Y+2	; 0x02
    2bd0:	2e 81       	ldd	r18, Y+6	; 0x06
    2bd2:	3f 81       	ldd	r19, Y+7	; 0x07
    2bd4:	4c 85       	ldd	r20, Y+12	; 0x0c
    2bd6:	5d 85       	ldd	r21, Y+13	; 0x0d
    2bd8:	b9 01       	movw	r22, r18
    2bda:	0e 94 4b 0e 	call	0x1c96	; 0x1c96 <pxPortInitialiseStack>
    2bde:	eb 81       	ldd	r30, Y+3	; 0x03
    2be0:	fc 81       	ldd	r31, Y+4	; 0x04
    2be2:	91 83       	std	Z+1, r25	; 0x01
    2be4:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    2be6:	8f 85       	ldd	r24, Y+15	; 0x0f
    2be8:	98 89       	ldd	r25, Y+16	; 0x10
    2bea:	00 97       	sbiw	r24, 0x00	; 0
    2bec:	31 f0       	breq	.+12     	; 0x2bfa <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    2bee:	ef 85       	ldd	r30, Y+15	; 0x0f
    2bf0:	f8 89       	ldd	r31, Y+16	; 0x10
    2bf2:	8b 81       	ldd	r24, Y+3	; 0x03
    2bf4:	9c 81       	ldd	r25, Y+4	; 0x04
    2bf6:	91 83       	std	Z+1, r25	; 0x01
    2bf8:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    2bfa:	0f b6       	in	r0, 0x3f	; 63
    2bfc:	f8 94       	cli
    2bfe:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    2c00:	80 91 db 04 	lds	r24, 0x04DB
    2c04:	8f 5f       	subi	r24, 0xFF	; 255
    2c06:	80 93 db 04 	sts	0x04DB, r24
			if( pxCurrentTCB == NULL )
    2c0a:	80 91 d8 04 	lds	r24, 0x04D8
    2c0e:	90 91 d9 04 	lds	r25, 0x04D9
    2c12:	00 97       	sbiw	r24, 0x00	; 0
    2c14:	69 f4       	brne	.+26     	; 0x2c30 <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    2c16:	8b 81       	ldd	r24, Y+3	; 0x03
    2c18:	9c 81       	ldd	r25, Y+4	; 0x04
    2c1a:	90 93 d9 04 	sts	0x04D9, r25
    2c1e:	80 93 d8 04 	sts	0x04D8, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    2c22:	80 91 db 04 	lds	r24, 0x04DB
    2c26:	81 30       	cpi	r24, 0x01	; 1
    2c28:	a9 f4       	brne	.+42     	; 0x2c54 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    2c2a:	0e 94 5f 1b 	call	0x36be	; 0x36be <prvInitialiseTaskLists>
    2c2e:	12 c0       	rjmp	.+36     	; 0x2c54 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    2c30:	80 91 e0 04 	lds	r24, 0x04E0
    2c34:	88 23       	and	r24, r24
    2c36:	71 f4       	brne	.+28     	; 0x2c54 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    2c38:	e0 91 d8 04 	lds	r30, 0x04D8
    2c3c:	f0 91 d9 04 	lds	r31, 0x04D9
    2c40:	96 89       	ldd	r25, Z+22	; 0x16
    2c42:	8e 85       	ldd	r24, Y+14	; 0x0e
    2c44:	89 17       	cp	r24, r25
    2c46:	30 f0       	brcs	.+12     	; 0x2c54 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    2c48:	8b 81       	ldd	r24, Y+3	; 0x03
    2c4a:	9c 81       	ldd	r25, Y+4	; 0x04
    2c4c:	90 93 d9 04 	sts	0x04D9, r25
    2c50:	80 93 d8 04 	sts	0x04D8, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    2c54:	eb 81       	ldd	r30, Y+3	; 0x03
    2c56:	fc 81       	ldd	r31, Y+4	; 0x04
    2c58:	96 89       	ldd	r25, Z+22	; 0x16
    2c5a:	80 91 de 04 	lds	r24, 0x04DE
    2c5e:	89 17       	cp	r24, r25
    2c60:	28 f4       	brcc	.+10     	; 0x2c6c <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    2c62:	eb 81       	ldd	r30, Y+3	; 0x03
    2c64:	fc 81       	ldd	r31, Y+4	; 0x04
    2c66:	86 89       	ldd	r24, Z+22	; 0x16
    2c68:	80 93 de 04 	sts	0x04DE, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    2c6c:	80 91 e5 04 	lds	r24, 0x04E5
    2c70:	8f 5f       	subi	r24, 0xFF	; 255
    2c72:	80 93 e5 04 	sts	0x04E5, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    2c76:	eb 81       	ldd	r30, Y+3	; 0x03
    2c78:	fc 81       	ldd	r31, Y+4	; 0x04
    2c7a:	96 89       	ldd	r25, Z+22	; 0x16
    2c7c:	80 91 df 04 	lds	r24, 0x04DF
    2c80:	89 17       	cp	r24, r25
    2c82:	28 f4       	brcc	.+10     	; 0x2c8e <xTaskGenericCreate+0x152>
    2c84:	eb 81       	ldd	r30, Y+3	; 0x03
    2c86:	fc 81       	ldd	r31, Y+4	; 0x04
    2c88:	86 89       	ldd	r24, Z+22	; 0x16
    2c8a:	80 93 df 04 	sts	0x04DF, r24
    2c8e:	eb 81       	ldd	r30, Y+3	; 0x03
    2c90:	fc 81       	ldd	r31, Y+4	; 0x04
    2c92:	86 89       	ldd	r24, Z+22	; 0x16
    2c94:	28 2f       	mov	r18, r24
    2c96:	30 e0       	ldi	r19, 0x00	; 0
    2c98:	c9 01       	movw	r24, r18
    2c9a:	88 0f       	add	r24, r24
    2c9c:	99 1f       	adc	r25, r25
    2c9e:	88 0f       	add	r24, r24
    2ca0:	99 1f       	adc	r25, r25
    2ca2:	88 0f       	add	r24, r24
    2ca4:	99 1f       	adc	r25, r25
    2ca6:	82 0f       	add	r24, r18
    2ca8:	93 1f       	adc	r25, r19
    2caa:	ac 01       	movw	r20, r24
    2cac:	4a 51       	subi	r20, 0x1A	; 26
    2cae:	5b 4f       	sbci	r21, 0xFB	; 251
    2cb0:	8b 81       	ldd	r24, Y+3	; 0x03
    2cb2:	9c 81       	ldd	r25, Y+4	; 0x04
    2cb4:	9c 01       	movw	r18, r24
    2cb6:	2e 5f       	subi	r18, 0xFE	; 254
    2cb8:	3f 4f       	sbci	r19, 0xFF	; 255
    2cba:	ca 01       	movw	r24, r20
    2cbc:	b9 01       	movw	r22, r18
    2cbe:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <vListInsertEnd>

			xReturn = pdPASS;
    2cc2:	81 e0       	ldi	r24, 0x01	; 1
    2cc4:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    2cc6:	0f 90       	pop	r0
    2cc8:	0f be       	out	0x3f, r0	; 63
    2cca:	02 c0       	rjmp	.+4      	; 0x2cd0 <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2ccc:	8f ef       	ldi	r24, 0xFF	; 255
    2cce:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    2cd0:	8d 81       	ldd	r24, Y+5	; 0x05
    2cd2:	81 30       	cpi	r24, 0x01	; 1
    2cd4:	71 f4       	brne	.+28     	; 0x2cf2 <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    2cd6:	80 91 e0 04 	lds	r24, 0x04E0
    2cda:	88 23       	and	r24, r24
    2cdc:	51 f0       	breq	.+20     	; 0x2cf2 <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    2cde:	e0 91 d8 04 	lds	r30, 0x04D8
    2ce2:	f0 91 d9 04 	lds	r31, 0x04D9
    2ce6:	96 89       	ldd	r25, Z+22	; 0x16
    2ce8:	8e 85       	ldd	r24, Y+14	; 0x0e
    2cea:	98 17       	cp	r25, r24
    2cec:	10 f4       	brcc	.+4      	; 0x2cf2 <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    2cee:	0e 94 0a 10 	call	0x2014	; 0x2014 <vPortYield>
			}
		}
	}

	return xReturn;
    2cf2:	8d 81       	ldd	r24, Y+5	; 0x05
}
    2cf4:	64 96       	adiw	r28, 0x14	; 20
    2cf6:	0f b6       	in	r0, 0x3f	; 63
    2cf8:	f8 94       	cli
    2cfa:	de bf       	out	0x3e, r29	; 62
    2cfc:	0f be       	out	0x3f, r0	; 63
    2cfe:	cd bf       	out	0x3d, r28	; 61
    2d00:	cf 91       	pop	r28
    2d02:	df 91       	pop	r29
    2d04:	1f 91       	pop	r17
    2d06:	0f 91       	pop	r16
    2d08:	ff 90       	pop	r15
    2d0a:	ef 90       	pop	r14
    2d0c:	df 90       	pop	r13
    2d0e:	cf 90       	pop	r12
    2d10:	bf 90       	pop	r11
    2d12:	af 90       	pop	r10
    2d14:	08 95       	ret

00002d16 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    2d16:	df 93       	push	r29
    2d18:	cf 93       	push	r28
    2d1a:	00 d0       	rcall	.+0      	; 0x2d1c <vTaskDelete+0x6>
    2d1c:	00 d0       	rcall	.+0      	; 0x2d1e <vTaskDelete+0x8>
    2d1e:	00 d0       	rcall	.+0      	; 0x2d20 <vTaskDelete+0xa>
    2d20:	cd b7       	in	r28, 0x3d	; 61
    2d22:	de b7       	in	r29, 0x3e	; 62
    2d24:	9c 83       	std	Y+4, r25	; 0x04
    2d26:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    2d28:	0f b6       	in	r0, 0x3f	; 63
    2d2a:	f8 94       	cli
    2d2c:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    2d2e:	20 91 d8 04 	lds	r18, 0x04D8
    2d32:	30 91 d9 04 	lds	r19, 0x04D9
    2d36:	8b 81       	ldd	r24, Y+3	; 0x03
    2d38:	9c 81       	ldd	r25, Y+4	; 0x04
    2d3a:	82 17       	cp	r24, r18
    2d3c:	93 07       	cpc	r25, r19
    2d3e:	11 f4       	brne	.+4      	; 0x2d44 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    2d40:	1c 82       	std	Y+4, r1	; 0x04
    2d42:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    2d44:	8b 81       	ldd	r24, Y+3	; 0x03
    2d46:	9c 81       	ldd	r25, Y+4	; 0x04
    2d48:	00 97       	sbiw	r24, 0x00	; 0
    2d4a:	39 f4       	brne	.+14     	; 0x2d5a <vTaskDelete+0x44>
    2d4c:	80 91 d8 04 	lds	r24, 0x04D8
    2d50:	90 91 d9 04 	lds	r25, 0x04D9
    2d54:	9e 83       	std	Y+6, r25	; 0x06
    2d56:	8d 83       	std	Y+5, r24	; 0x05
    2d58:	04 c0       	rjmp	.+8      	; 0x2d62 <vTaskDelete+0x4c>
    2d5a:	8b 81       	ldd	r24, Y+3	; 0x03
    2d5c:	9c 81       	ldd	r25, Y+4	; 0x04
    2d5e:	9e 83       	std	Y+6, r25	; 0x06
    2d60:	8d 83       	std	Y+5, r24	; 0x05
    2d62:	8d 81       	ldd	r24, Y+5	; 0x05
    2d64:	9e 81       	ldd	r25, Y+6	; 0x06
    2d66:	9a 83       	std	Y+2, r25	; 0x02
    2d68:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    2d6a:	89 81       	ldd	r24, Y+1	; 0x01
    2d6c:	9a 81       	ldd	r25, Y+2	; 0x02
    2d6e:	02 96       	adiw	r24, 0x02	; 2
    2d70:	0e 94 02 0e 	call	0x1c04	; 0x1c04 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    2d74:	e9 81       	ldd	r30, Y+1	; 0x01
    2d76:	fa 81       	ldd	r31, Y+2	; 0x02
    2d78:	84 89       	ldd	r24, Z+20	; 0x14
    2d7a:	95 89       	ldd	r25, Z+21	; 0x15
    2d7c:	00 97       	sbiw	r24, 0x00	; 0
    2d7e:	29 f0       	breq	.+10     	; 0x2d8a <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    2d80:	89 81       	ldd	r24, Y+1	; 0x01
    2d82:	9a 81       	ldd	r25, Y+2	; 0x02
    2d84:	0c 96       	adiw	r24, 0x0c	; 12
    2d86:	0e 94 02 0e 	call	0x1c04	; 0x1c04 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    2d8a:	89 81       	ldd	r24, Y+1	; 0x01
    2d8c:	9a 81       	ldd	r25, Y+2	; 0x02
    2d8e:	9c 01       	movw	r18, r24
    2d90:	2e 5f       	subi	r18, 0xFE	; 254
    2d92:	3f 4f       	sbci	r19, 0xFF	; 255
    2d94:	8f e5       	ldi	r24, 0x5F	; 95
    2d96:	95 e0       	ldi	r25, 0x05	; 5
    2d98:	b9 01       	movw	r22, r18
    2d9a:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    2d9e:	80 91 da 04 	lds	r24, 0x04DA
    2da2:	8f 5f       	subi	r24, 0xFF	; 255
    2da4:	80 93 da 04 	sts	0x04DA, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    2da8:	80 91 e5 04 	lds	r24, 0x04E5
    2dac:	8f 5f       	subi	r24, 0xFF	; 255
    2dae:	80 93 e5 04 	sts	0x04E5, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    2db2:	0f 90       	pop	r0
    2db4:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    2db6:	80 91 e0 04 	lds	r24, 0x04E0
    2dba:	88 23       	and	r24, r24
    2dbc:	31 f0       	breq	.+12     	; 0x2dca <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    2dbe:	8b 81       	ldd	r24, Y+3	; 0x03
    2dc0:	9c 81       	ldd	r25, Y+4	; 0x04
    2dc2:	00 97       	sbiw	r24, 0x00	; 0
    2dc4:	11 f4       	brne	.+4      	; 0x2dca <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    2dc6:	0e 94 0a 10 	call	0x2014	; 0x2014 <vPortYield>
			}
		}
	}
    2dca:	26 96       	adiw	r28, 0x06	; 6
    2dcc:	0f b6       	in	r0, 0x3f	; 63
    2dce:	f8 94       	cli
    2dd0:	de bf       	out	0x3e, r29	; 62
    2dd2:	0f be       	out	0x3f, r0	; 63
    2dd4:	cd bf       	out	0x3d, r28	; 61
    2dd6:	cf 91       	pop	r28
    2dd8:	df 91       	pop	r29
    2dda:	08 95       	ret

00002ddc <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    2ddc:	df 93       	push	r29
    2dde:	cf 93       	push	r28
    2de0:	cd b7       	in	r28, 0x3d	; 61
    2de2:	de b7       	in	r29, 0x3e	; 62
    2de4:	28 97       	sbiw	r28, 0x08	; 8
    2de6:	0f b6       	in	r0, 0x3f	; 63
    2de8:	f8 94       	cli
    2dea:	de bf       	out	0x3e, r29	; 62
    2dec:	0f be       	out	0x3f, r0	; 63
    2dee:	cd bf       	out	0x3d, r28	; 61
    2df0:	9e 83       	std	Y+6, r25	; 0x06
    2df2:	8d 83       	std	Y+5, r24	; 0x05
    2df4:	78 87       	std	Y+8, r23	; 0x08
    2df6:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    2df8:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    2dfa:	0e 94 da 17 	call	0x2fb4	; 0x2fb4 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2dfe:	ed 81       	ldd	r30, Y+5	; 0x05
    2e00:	fe 81       	ldd	r31, Y+6	; 0x06
    2e02:	20 81       	ld	r18, Z
    2e04:	31 81       	ldd	r19, Z+1	; 0x01
    2e06:	8f 81       	ldd	r24, Y+7	; 0x07
    2e08:	98 85       	ldd	r25, Y+8	; 0x08
    2e0a:	82 0f       	add	r24, r18
    2e0c:	93 1f       	adc	r25, r19
    2e0e:	9c 83       	std	Y+4, r25	; 0x04
    2e10:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    2e12:	ed 81       	ldd	r30, Y+5	; 0x05
    2e14:	fe 81       	ldd	r31, Y+6	; 0x06
    2e16:	20 81       	ld	r18, Z
    2e18:	31 81       	ldd	r19, Z+1	; 0x01
    2e1a:	80 91 dc 04 	lds	r24, 0x04DC
    2e1e:	90 91 dd 04 	lds	r25, 0x04DD
    2e22:	82 17       	cp	r24, r18
    2e24:	93 07       	cpc	r25, r19
    2e26:	a8 f4       	brcc	.+42     	; 0x2e52 <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    2e28:	ed 81       	ldd	r30, Y+5	; 0x05
    2e2a:	fe 81       	ldd	r31, Y+6	; 0x06
    2e2c:	20 81       	ld	r18, Z
    2e2e:	31 81       	ldd	r19, Z+1	; 0x01
    2e30:	8b 81       	ldd	r24, Y+3	; 0x03
    2e32:	9c 81       	ldd	r25, Y+4	; 0x04
    2e34:	82 17       	cp	r24, r18
    2e36:	93 07       	cpc	r25, r19
    2e38:	00 f5       	brcc	.+64     	; 0x2e7a <vTaskDelayUntil+0x9e>
    2e3a:	20 91 dc 04 	lds	r18, 0x04DC
    2e3e:	30 91 dd 04 	lds	r19, 0x04DD
    2e42:	8b 81       	ldd	r24, Y+3	; 0x03
    2e44:	9c 81       	ldd	r25, Y+4	; 0x04
    2e46:	28 17       	cp	r18, r24
    2e48:	39 07       	cpc	r19, r25
    2e4a:	b8 f4       	brcc	.+46     	; 0x2e7a <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    2e4c:	81 e0       	ldi	r24, 0x01	; 1
    2e4e:	89 83       	std	Y+1, r24	; 0x01
    2e50:	14 c0       	rjmp	.+40     	; 0x2e7a <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    2e52:	ed 81       	ldd	r30, Y+5	; 0x05
    2e54:	fe 81       	ldd	r31, Y+6	; 0x06
    2e56:	20 81       	ld	r18, Z
    2e58:	31 81       	ldd	r19, Z+1	; 0x01
    2e5a:	8b 81       	ldd	r24, Y+3	; 0x03
    2e5c:	9c 81       	ldd	r25, Y+4	; 0x04
    2e5e:	82 17       	cp	r24, r18
    2e60:	93 07       	cpc	r25, r19
    2e62:	48 f0       	brcs	.+18     	; 0x2e76 <vTaskDelayUntil+0x9a>
    2e64:	20 91 dc 04 	lds	r18, 0x04DC
    2e68:	30 91 dd 04 	lds	r19, 0x04DD
    2e6c:	8b 81       	ldd	r24, Y+3	; 0x03
    2e6e:	9c 81       	ldd	r25, Y+4	; 0x04
    2e70:	28 17       	cp	r18, r24
    2e72:	39 07       	cpc	r19, r25
    2e74:	10 f4       	brcc	.+4      	; 0x2e7a <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    2e76:	81 e0       	ldi	r24, 0x01	; 1
    2e78:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2e7a:	ed 81       	ldd	r30, Y+5	; 0x05
    2e7c:	fe 81       	ldd	r31, Y+6	; 0x06
    2e7e:	8b 81       	ldd	r24, Y+3	; 0x03
    2e80:	9c 81       	ldd	r25, Y+4	; 0x04
    2e82:	91 83       	std	Z+1, r25	; 0x01
    2e84:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    2e86:	89 81       	ldd	r24, Y+1	; 0x01
    2e88:	88 23       	and	r24, r24
    2e8a:	59 f0       	breq	.+22     	; 0x2ea2 <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2e8c:	80 91 d8 04 	lds	r24, 0x04D8
    2e90:	90 91 d9 04 	lds	r25, 0x04D9
    2e94:	02 96       	adiw	r24, 0x02	; 2
    2e96:	0e 94 02 0e 	call	0x1c04	; 0x1c04 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2e9a:	8b 81       	ldd	r24, Y+3	; 0x03
    2e9c:	9c 81       	ldd	r25, Y+4	; 0x04
    2e9e:	0e 94 da 1b 	call	0x37b4	; 0x37b4 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    2ea2:	0e 94 e6 17 	call	0x2fcc	; 0x2fcc <xTaskResumeAll>
    2ea6:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2ea8:	8a 81       	ldd	r24, Y+2	; 0x02
    2eaa:	88 23       	and	r24, r24
    2eac:	11 f4       	brne	.+4      	; 0x2eb2 <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    2eae:	0e 94 0a 10 	call	0x2014	; 0x2014 <vPortYield>
		}
	}
    2eb2:	28 96       	adiw	r28, 0x08	; 8
    2eb4:	0f b6       	in	r0, 0x3f	; 63
    2eb6:	f8 94       	cli
    2eb8:	de bf       	out	0x3e, r29	; 62
    2eba:	0f be       	out	0x3f, r0	; 63
    2ebc:	cd bf       	out	0x3d, r28	; 61
    2ebe:	cf 91       	pop	r28
    2ec0:	df 91       	pop	r29
    2ec2:	08 95       	ret

00002ec4 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    2ec4:	df 93       	push	r29
    2ec6:	cf 93       	push	r28
    2ec8:	00 d0       	rcall	.+0      	; 0x2eca <vTaskDelay+0x6>
    2eca:	00 d0       	rcall	.+0      	; 0x2ecc <vTaskDelay+0x8>
    2ecc:	0f 92       	push	r0
    2ece:	cd b7       	in	r28, 0x3d	; 61
    2ed0:	de b7       	in	r29, 0x3e	; 62
    2ed2:	9d 83       	std	Y+5, r25	; 0x05
    2ed4:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    2ed6:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    2ed8:	8c 81       	ldd	r24, Y+4	; 0x04
    2eda:	9d 81       	ldd	r25, Y+5	; 0x05
    2edc:	00 97       	sbiw	r24, 0x00	; 0
    2ede:	d1 f0       	breq	.+52     	; 0x2f14 <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    2ee0:	0e 94 da 17 	call	0x2fb4	; 0x2fb4 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2ee4:	20 91 dc 04 	lds	r18, 0x04DC
    2ee8:	30 91 dd 04 	lds	r19, 0x04DD
    2eec:	8c 81       	ldd	r24, Y+4	; 0x04
    2eee:	9d 81       	ldd	r25, Y+5	; 0x05
    2ef0:	82 0f       	add	r24, r18
    2ef2:	93 1f       	adc	r25, r19
    2ef4:	9b 83       	std	Y+3, r25	; 0x03
    2ef6:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2ef8:	80 91 d8 04 	lds	r24, 0x04D8
    2efc:	90 91 d9 04 	lds	r25, 0x04D9
    2f00:	02 96       	adiw	r24, 0x02	; 2
    2f02:	0e 94 02 0e 	call	0x1c04	; 0x1c04 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2f06:	8a 81       	ldd	r24, Y+2	; 0x02
    2f08:	9b 81       	ldd	r25, Y+3	; 0x03
    2f0a:	0e 94 da 1b 	call	0x37b4	; 0x37b4 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2f0e:	0e 94 e6 17 	call	0x2fcc	; 0x2fcc <xTaskResumeAll>
    2f12:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2f14:	89 81       	ldd	r24, Y+1	; 0x01
    2f16:	88 23       	and	r24, r24
    2f18:	11 f4       	brne	.+4      	; 0x2f1e <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    2f1a:	0e 94 0a 10 	call	0x2014	; 0x2014 <vPortYield>
		}
	}
    2f1e:	0f 90       	pop	r0
    2f20:	0f 90       	pop	r0
    2f22:	0f 90       	pop	r0
    2f24:	0f 90       	pop	r0
    2f26:	0f 90       	pop	r0
    2f28:	cf 91       	pop	r28
    2f2a:	df 91       	pop	r29
    2f2c:	08 95       	ret

00002f2e <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    2f2e:	af 92       	push	r10
    2f30:	bf 92       	push	r11
    2f32:	cf 92       	push	r12
    2f34:	df 92       	push	r13
    2f36:	ef 92       	push	r14
    2f38:	ff 92       	push	r15
    2f3a:	0f 93       	push	r16
    2f3c:	df 93       	push	r29
    2f3e:	cf 93       	push	r28
    2f40:	0f 92       	push	r0
    2f42:	cd b7       	in	r28, 0x3d	; 61
    2f44:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    2f46:	20 e6       	ldi	r18, 0x60	; 96
    2f48:	30 e0       	ldi	r19, 0x00	; 0
    2f4a:	8e ef       	ldi	r24, 0xFE	; 254
    2f4c:	9a e1       	ldi	r25, 0x1A	; 26
    2f4e:	b9 01       	movw	r22, r18
    2f50:	40 e5       	ldi	r20, 0x50	; 80
    2f52:	50 e0       	ldi	r21, 0x00	; 0
    2f54:	20 e0       	ldi	r18, 0x00	; 0
    2f56:	30 e0       	ldi	r19, 0x00	; 0
    2f58:	00 e0       	ldi	r16, 0x00	; 0
    2f5a:	ee 24       	eor	r14, r14
    2f5c:	ff 24       	eor	r15, r15
    2f5e:	cc 24       	eor	r12, r12
    2f60:	dd 24       	eor	r13, r13
    2f62:	aa 24       	eor	r10, r10
    2f64:	bb 24       	eor	r11, r11
    2f66:	0e 94 9e 15 	call	0x2b3c	; 0x2b3c <xTaskGenericCreate>
    2f6a:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    2f6c:	89 81       	ldd	r24, Y+1	; 0x01
    2f6e:	81 30       	cpi	r24, 0x01	; 1
    2f70:	51 f4       	brne	.+20     	; 0x2f86 <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    2f72:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    2f74:	81 e0       	ldi	r24, 0x01	; 1
    2f76:	80 93 e0 04 	sts	0x04E0, r24
		xTickCount = ( portTickType ) 0U;
    2f7a:	10 92 dd 04 	sts	0x04DD, r1
    2f7e:	10 92 dc 04 	sts	0x04DC, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    2f82:	0e 94 ce 0f 	call	0x1f9c	; 0x1f9c <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    2f86:	0f 90       	pop	r0
    2f88:	cf 91       	pop	r28
    2f8a:	df 91       	pop	r29
    2f8c:	0f 91       	pop	r16
    2f8e:	ff 90       	pop	r15
    2f90:	ef 90       	pop	r14
    2f92:	df 90       	pop	r13
    2f94:	cf 90       	pop	r12
    2f96:	bf 90       	pop	r11
    2f98:	af 90       	pop	r10
    2f9a:	08 95       	ret

00002f9c <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    2f9c:	df 93       	push	r29
    2f9e:	cf 93       	push	r28
    2fa0:	cd b7       	in	r28, 0x3d	; 61
    2fa2:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    2fa4:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    2fa6:	10 92 e0 04 	sts	0x04E0, r1
	vPortEndScheduler();
    2faa:	0e 94 03 10 	call	0x2006	; 0x2006 <vPortEndScheduler>
}
    2fae:	cf 91       	pop	r28
    2fb0:	df 91       	pop	r29
    2fb2:	08 95       	ret

00002fb4 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    2fb4:	df 93       	push	r29
    2fb6:	cf 93       	push	r28
    2fb8:	cd b7       	in	r28, 0x3d	; 61
    2fba:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    2fbc:	80 91 e1 04 	lds	r24, 0x04E1
    2fc0:	8f 5f       	subi	r24, 0xFF	; 255
    2fc2:	80 93 e1 04 	sts	0x04E1, r24
}
    2fc6:	cf 91       	pop	r28
    2fc8:	df 91       	pop	r29
    2fca:	08 95       	ret

00002fcc <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    2fcc:	df 93       	push	r29
    2fce:	cf 93       	push	r28
    2fd0:	00 d0       	rcall	.+0      	; 0x2fd2 <xTaskResumeAll+0x6>
    2fd2:	00 d0       	rcall	.+0      	; 0x2fd4 <xTaskResumeAll+0x8>
    2fd4:	cd b7       	in	r28, 0x3d	; 61
    2fd6:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    2fd8:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    2fda:	0f b6       	in	r0, 0x3f	; 63
    2fdc:	f8 94       	cli
    2fde:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2fe0:	80 91 e1 04 	lds	r24, 0x04E1
    2fe4:	81 50       	subi	r24, 0x01	; 1
    2fe6:	80 93 e1 04 	sts	0x04E1, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2fea:	80 91 e1 04 	lds	r24, 0x04E1
    2fee:	88 23       	and	r24, r24
    2ff0:	09 f0       	breq	.+2      	; 0x2ff4 <xTaskResumeAll+0x28>
    2ff2:	6c c0       	rjmp	.+216    	; 0x30cc <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    2ff4:	80 91 db 04 	lds	r24, 0x04DB
    2ff8:	88 23       	and	r24, r24
    2ffa:	09 f4       	brne	.+2      	; 0x2ffe <xTaskResumeAll+0x32>
    2ffc:	67 c0       	rjmp	.+206    	; 0x30cc <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    2ffe:	19 82       	std	Y+1, r1	; 0x01
    3000:	41 c0       	rjmp	.+130    	; 0x3084 <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    3002:	e0 91 5b 05 	lds	r30, 0x055B
    3006:	f0 91 5c 05 	lds	r31, 0x055C
    300a:	86 81       	ldd	r24, Z+6	; 0x06
    300c:	97 81       	ldd	r25, Z+7	; 0x07
    300e:	9c 83       	std	Y+4, r25	; 0x04
    3010:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    3012:	8b 81       	ldd	r24, Y+3	; 0x03
    3014:	9c 81       	ldd	r25, Y+4	; 0x04
    3016:	0c 96       	adiw	r24, 0x0c	; 12
    3018:	0e 94 02 0e 	call	0x1c04	; 0x1c04 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    301c:	8b 81       	ldd	r24, Y+3	; 0x03
    301e:	9c 81       	ldd	r25, Y+4	; 0x04
    3020:	02 96       	adiw	r24, 0x02	; 2
    3022:	0e 94 02 0e 	call	0x1c04	; 0x1c04 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    3026:	eb 81       	ldd	r30, Y+3	; 0x03
    3028:	fc 81       	ldd	r31, Y+4	; 0x04
    302a:	96 89       	ldd	r25, Z+22	; 0x16
    302c:	80 91 df 04 	lds	r24, 0x04DF
    3030:	89 17       	cp	r24, r25
    3032:	28 f4       	brcc	.+10     	; 0x303e <xTaskResumeAll+0x72>
    3034:	eb 81       	ldd	r30, Y+3	; 0x03
    3036:	fc 81       	ldd	r31, Y+4	; 0x04
    3038:	86 89       	ldd	r24, Z+22	; 0x16
    303a:	80 93 df 04 	sts	0x04DF, r24
    303e:	eb 81       	ldd	r30, Y+3	; 0x03
    3040:	fc 81       	ldd	r31, Y+4	; 0x04
    3042:	86 89       	ldd	r24, Z+22	; 0x16
    3044:	28 2f       	mov	r18, r24
    3046:	30 e0       	ldi	r19, 0x00	; 0
    3048:	c9 01       	movw	r24, r18
    304a:	88 0f       	add	r24, r24
    304c:	99 1f       	adc	r25, r25
    304e:	88 0f       	add	r24, r24
    3050:	99 1f       	adc	r25, r25
    3052:	88 0f       	add	r24, r24
    3054:	99 1f       	adc	r25, r25
    3056:	82 0f       	add	r24, r18
    3058:	93 1f       	adc	r25, r19
    305a:	8a 51       	subi	r24, 0x1A	; 26
    305c:	9b 4f       	sbci	r25, 0xFB	; 251
    305e:	2b 81       	ldd	r18, Y+3	; 0x03
    3060:	3c 81       	ldd	r19, Y+4	; 0x04
    3062:	2e 5f       	subi	r18, 0xFE	; 254
    3064:	3f 4f       	sbci	r19, 0xFF	; 255
    3066:	b9 01       	movw	r22, r18
    3068:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    306c:	eb 81       	ldd	r30, Y+3	; 0x03
    306e:	fc 81       	ldd	r31, Y+4	; 0x04
    3070:	96 89       	ldd	r25, Z+22	; 0x16
    3072:	e0 91 d8 04 	lds	r30, 0x04D8
    3076:	f0 91 d9 04 	lds	r31, 0x04D9
    307a:	86 89       	ldd	r24, Z+22	; 0x16
    307c:	98 17       	cp	r25, r24
    307e:	10 f0       	brcs	.+4      	; 0x3084 <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    3080:	81 e0       	ldi	r24, 0x01	; 1
    3082:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    3084:	80 91 56 05 	lds	r24, 0x0556
    3088:	88 23       	and	r24, r24
    308a:	09 f0       	breq	.+2      	; 0x308e <xTaskResumeAll+0xc2>
    308c:	ba cf       	rjmp	.-140    	; 0x3002 <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    308e:	80 91 e2 04 	lds	r24, 0x04E2
    3092:	88 23       	and	r24, r24
    3094:	71 f0       	breq	.+28     	; 0x30b2 <xTaskResumeAll+0xe6>
    3096:	07 c0       	rjmp	.+14     	; 0x30a6 <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    3098:	0e 94 a5 18 	call	0x314a	; 0x314a <vTaskIncrementTick>
						--uxMissedTicks;
    309c:	80 91 e2 04 	lds	r24, 0x04E2
    30a0:	81 50       	subi	r24, 0x01	; 1
    30a2:	80 93 e2 04 	sts	0x04E2, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    30a6:	80 91 e2 04 	lds	r24, 0x04E2
    30aa:	88 23       	and	r24, r24
    30ac:	a9 f7       	brne	.-22     	; 0x3098 <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    30ae:	81 e0       	ldi	r24, 0x01	; 1
    30b0:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    30b2:	89 81       	ldd	r24, Y+1	; 0x01
    30b4:	81 30       	cpi	r24, 0x01	; 1
    30b6:	21 f0       	breq	.+8      	; 0x30c0 <xTaskResumeAll+0xf4>
    30b8:	80 91 e3 04 	lds	r24, 0x04E3
    30bc:	81 30       	cpi	r24, 0x01	; 1
    30be:	31 f4       	brne	.+12     	; 0x30cc <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    30c0:	81 e0       	ldi	r24, 0x01	; 1
    30c2:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    30c4:	10 92 e3 04 	sts	0x04E3, r1
					portYIELD_WITHIN_API();
    30c8:	0e 94 0a 10 	call	0x2014	; 0x2014 <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    30cc:	0f 90       	pop	r0
    30ce:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    30d0:	8a 81       	ldd	r24, Y+2	; 0x02
}
    30d2:	0f 90       	pop	r0
    30d4:	0f 90       	pop	r0
    30d6:	0f 90       	pop	r0
    30d8:	0f 90       	pop	r0
    30da:	cf 91       	pop	r28
    30dc:	df 91       	pop	r29
    30de:	08 95       	ret

000030e0 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    30e0:	df 93       	push	r29
    30e2:	cf 93       	push	r28
    30e4:	00 d0       	rcall	.+0      	; 0x30e6 <xTaskGetTickCount+0x6>
    30e6:	cd b7       	in	r28, 0x3d	; 61
    30e8:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    30ea:	0f b6       	in	r0, 0x3f	; 63
    30ec:	f8 94       	cli
    30ee:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    30f0:	80 91 dc 04 	lds	r24, 0x04DC
    30f4:	90 91 dd 04 	lds	r25, 0x04DD
    30f8:	9a 83       	std	Y+2, r25	; 0x02
    30fa:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    30fc:	0f 90       	pop	r0
    30fe:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    3100:	89 81       	ldd	r24, Y+1	; 0x01
    3102:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3104:	0f 90       	pop	r0
    3106:	0f 90       	pop	r0
    3108:	cf 91       	pop	r28
    310a:	df 91       	pop	r29
    310c:	08 95       	ret

0000310e <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    310e:	df 93       	push	r29
    3110:	cf 93       	push	r28
    3112:	00 d0       	rcall	.+0      	; 0x3114 <xTaskGetTickCountFromISR+0x6>
    3114:	0f 92       	push	r0
    3116:	cd b7       	in	r28, 0x3d	; 61
    3118:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    311a:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    311c:	80 91 dc 04 	lds	r24, 0x04DC
    3120:	90 91 dd 04 	lds	r25, 0x04DD
    3124:	9b 83       	std	Y+3, r25	; 0x03
    3126:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3128:	8a 81       	ldd	r24, Y+2	; 0x02
    312a:	9b 81       	ldd	r25, Y+3	; 0x03
}
    312c:	0f 90       	pop	r0
    312e:	0f 90       	pop	r0
    3130:	0f 90       	pop	r0
    3132:	cf 91       	pop	r28
    3134:	df 91       	pop	r29
    3136:	08 95       	ret

00003138 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    3138:	df 93       	push	r29
    313a:	cf 93       	push	r28
    313c:	cd b7       	in	r28, 0x3d	; 61
    313e:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    3140:	80 91 db 04 	lds	r24, 0x04DB
}
    3144:	cf 91       	pop	r28
    3146:	df 91       	pop	r29
    3148:	08 95       	ret

0000314a <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    314a:	df 93       	push	r29
    314c:	cf 93       	push	r28
    314e:	00 d0       	rcall	.+0      	; 0x3150 <vTaskIncrementTick+0x6>
    3150:	00 d0       	rcall	.+0      	; 0x3152 <vTaskIncrementTick+0x8>
    3152:	00 d0       	rcall	.+0      	; 0x3154 <vTaskIncrementTick+0xa>
    3154:	cd b7       	in	r28, 0x3d	; 61
    3156:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    3158:	80 91 e1 04 	lds	r24, 0x04E1
    315c:	88 23       	and	r24, r24
    315e:	09 f0       	breq	.+2      	; 0x3162 <vTaskIncrementTick+0x18>
    3160:	bb c0       	rjmp	.+374    	; 0x32d8 <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    3162:	80 91 dc 04 	lds	r24, 0x04DC
    3166:	90 91 dd 04 	lds	r25, 0x04DD
    316a:	01 96       	adiw	r24, 0x01	; 1
    316c:	90 93 dd 04 	sts	0x04DD, r25
    3170:	80 93 dc 04 	sts	0x04DC, r24
		if( xTickCount == ( portTickType ) 0U )
    3174:	80 91 dc 04 	lds	r24, 0x04DC
    3178:	90 91 dd 04 	lds	r25, 0x04DD
    317c:	00 97       	sbiw	r24, 0x00	; 0
    317e:	d1 f5       	brne	.+116    	; 0x31f4 <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    3180:	80 91 52 05 	lds	r24, 0x0552
    3184:	90 91 53 05 	lds	r25, 0x0553
    3188:	9c 83       	std	Y+4, r25	; 0x04
    318a:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    318c:	80 91 54 05 	lds	r24, 0x0554
    3190:	90 91 55 05 	lds	r25, 0x0555
    3194:	90 93 53 05 	sts	0x0553, r25
    3198:	80 93 52 05 	sts	0x0552, r24
			pxOverflowDelayedTaskList = pxTemp;
    319c:	8b 81       	ldd	r24, Y+3	; 0x03
    319e:	9c 81       	ldd	r25, Y+4	; 0x04
    31a0:	90 93 55 05 	sts	0x0555, r25
    31a4:	80 93 54 05 	sts	0x0554, r24
			xNumOfOverflows++;
    31a8:	80 91 e4 04 	lds	r24, 0x04E4
    31ac:	8f 5f       	subi	r24, 0xFF	; 255
    31ae:	80 93 e4 04 	sts	0x04E4, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    31b2:	e0 91 52 05 	lds	r30, 0x0552
    31b6:	f0 91 53 05 	lds	r31, 0x0553
    31ba:	80 81       	ld	r24, Z
    31bc:	88 23       	and	r24, r24
    31be:	39 f4       	brne	.+14     	; 0x31ce <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    31c0:	8f ef       	ldi	r24, 0xFF	; 255
    31c2:	9f ef       	ldi	r25, 0xFF	; 255
    31c4:	90 93 a2 00 	sts	0x00A2, r25
    31c8:	80 93 a1 00 	sts	0x00A1, r24
    31cc:	13 c0       	rjmp	.+38     	; 0x31f4 <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    31ce:	e0 91 52 05 	lds	r30, 0x0552
    31d2:	f0 91 53 05 	lds	r31, 0x0553
    31d6:	05 80       	ldd	r0, Z+5	; 0x05
    31d8:	f6 81       	ldd	r31, Z+6	; 0x06
    31da:	e0 2d       	mov	r30, r0
    31dc:	86 81       	ldd	r24, Z+6	; 0x06
    31de:	97 81       	ldd	r25, Z+7	; 0x07
    31e0:	9e 83       	std	Y+6, r25	; 0x06
    31e2:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    31e4:	ed 81       	ldd	r30, Y+5	; 0x05
    31e6:	fe 81       	ldd	r31, Y+6	; 0x06
    31e8:	82 81       	ldd	r24, Z+2	; 0x02
    31ea:	93 81       	ldd	r25, Z+3	; 0x03
    31ec:	90 93 a2 00 	sts	0x00A2, r25
    31f0:	80 93 a1 00 	sts	0x00A1, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    31f4:	20 91 dc 04 	lds	r18, 0x04DC
    31f8:	30 91 dd 04 	lds	r19, 0x04DD
    31fc:	80 91 a1 00 	lds	r24, 0x00A1
    3200:	90 91 a2 00 	lds	r25, 0x00A2
    3204:	28 17       	cp	r18, r24
    3206:	39 07       	cpc	r19, r25
    3208:	08 f4       	brcc	.+2      	; 0x320c <vTaskIncrementTick+0xc2>
    320a:	6b c0       	rjmp	.+214    	; 0x32e2 <vTaskIncrementTick+0x198>
    320c:	e0 91 52 05 	lds	r30, 0x0552
    3210:	f0 91 53 05 	lds	r31, 0x0553
    3214:	80 81       	ld	r24, Z
    3216:	88 23       	and	r24, r24
    3218:	39 f4       	brne	.+14     	; 0x3228 <vTaskIncrementTick+0xde>
    321a:	8f ef       	ldi	r24, 0xFF	; 255
    321c:	9f ef       	ldi	r25, 0xFF	; 255
    321e:	90 93 a2 00 	sts	0x00A2, r25
    3222:	80 93 a1 00 	sts	0x00A1, r24
    3226:	5d c0       	rjmp	.+186    	; 0x32e2 <vTaskIncrementTick+0x198>
    3228:	e0 91 52 05 	lds	r30, 0x0552
    322c:	f0 91 53 05 	lds	r31, 0x0553
    3230:	05 80       	ldd	r0, Z+5	; 0x05
    3232:	f6 81       	ldd	r31, Z+6	; 0x06
    3234:	e0 2d       	mov	r30, r0
    3236:	86 81       	ldd	r24, Z+6	; 0x06
    3238:	97 81       	ldd	r25, Z+7	; 0x07
    323a:	9e 83       	std	Y+6, r25	; 0x06
    323c:	8d 83       	std	Y+5, r24	; 0x05
    323e:	ed 81       	ldd	r30, Y+5	; 0x05
    3240:	fe 81       	ldd	r31, Y+6	; 0x06
    3242:	82 81       	ldd	r24, Z+2	; 0x02
    3244:	93 81       	ldd	r25, Z+3	; 0x03
    3246:	9a 83       	std	Y+2, r25	; 0x02
    3248:	89 83       	std	Y+1, r24	; 0x01
    324a:	20 91 dc 04 	lds	r18, 0x04DC
    324e:	30 91 dd 04 	lds	r19, 0x04DD
    3252:	89 81       	ldd	r24, Y+1	; 0x01
    3254:	9a 81       	ldd	r25, Y+2	; 0x02
    3256:	28 17       	cp	r18, r24
    3258:	39 07       	cpc	r19, r25
    325a:	38 f4       	brcc	.+14     	; 0x326a <vTaskIncrementTick+0x120>
    325c:	89 81       	ldd	r24, Y+1	; 0x01
    325e:	9a 81       	ldd	r25, Y+2	; 0x02
    3260:	90 93 a2 00 	sts	0x00A2, r25
    3264:	80 93 a1 00 	sts	0x00A1, r24
    3268:	3c c0       	rjmp	.+120    	; 0x32e2 <vTaskIncrementTick+0x198>
    326a:	8d 81       	ldd	r24, Y+5	; 0x05
    326c:	9e 81       	ldd	r25, Y+6	; 0x06
    326e:	02 96       	adiw	r24, 0x02	; 2
    3270:	0e 94 02 0e 	call	0x1c04	; 0x1c04 <vListRemove>
    3274:	ed 81       	ldd	r30, Y+5	; 0x05
    3276:	fe 81       	ldd	r31, Y+6	; 0x06
    3278:	84 89       	ldd	r24, Z+20	; 0x14
    327a:	95 89       	ldd	r25, Z+21	; 0x15
    327c:	00 97       	sbiw	r24, 0x00	; 0
    327e:	29 f0       	breq	.+10     	; 0x328a <vTaskIncrementTick+0x140>
    3280:	8d 81       	ldd	r24, Y+5	; 0x05
    3282:	9e 81       	ldd	r25, Y+6	; 0x06
    3284:	0c 96       	adiw	r24, 0x0c	; 12
    3286:	0e 94 02 0e 	call	0x1c04	; 0x1c04 <vListRemove>
    328a:	ed 81       	ldd	r30, Y+5	; 0x05
    328c:	fe 81       	ldd	r31, Y+6	; 0x06
    328e:	96 89       	ldd	r25, Z+22	; 0x16
    3290:	80 91 df 04 	lds	r24, 0x04DF
    3294:	89 17       	cp	r24, r25
    3296:	28 f4       	brcc	.+10     	; 0x32a2 <vTaskIncrementTick+0x158>
    3298:	ed 81       	ldd	r30, Y+5	; 0x05
    329a:	fe 81       	ldd	r31, Y+6	; 0x06
    329c:	86 89       	ldd	r24, Z+22	; 0x16
    329e:	80 93 df 04 	sts	0x04DF, r24
    32a2:	ed 81       	ldd	r30, Y+5	; 0x05
    32a4:	fe 81       	ldd	r31, Y+6	; 0x06
    32a6:	86 89       	ldd	r24, Z+22	; 0x16
    32a8:	28 2f       	mov	r18, r24
    32aa:	30 e0       	ldi	r19, 0x00	; 0
    32ac:	c9 01       	movw	r24, r18
    32ae:	88 0f       	add	r24, r24
    32b0:	99 1f       	adc	r25, r25
    32b2:	88 0f       	add	r24, r24
    32b4:	99 1f       	adc	r25, r25
    32b6:	88 0f       	add	r24, r24
    32b8:	99 1f       	adc	r25, r25
    32ba:	82 0f       	add	r24, r18
    32bc:	93 1f       	adc	r25, r19
    32be:	ac 01       	movw	r20, r24
    32c0:	4a 51       	subi	r20, 0x1A	; 26
    32c2:	5b 4f       	sbci	r21, 0xFB	; 251
    32c4:	8d 81       	ldd	r24, Y+5	; 0x05
    32c6:	9e 81       	ldd	r25, Y+6	; 0x06
    32c8:	9c 01       	movw	r18, r24
    32ca:	2e 5f       	subi	r18, 0xFE	; 254
    32cc:	3f 4f       	sbci	r19, 0xFF	; 255
    32ce:	ca 01       	movw	r24, r20
    32d0:	b9 01       	movw	r22, r18
    32d2:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <vListInsertEnd>
    32d6:	9a cf       	rjmp	.-204    	; 0x320c <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    32d8:	80 91 e2 04 	lds	r24, 0x04E2
    32dc:	8f 5f       	subi	r24, 0xFF	; 255
    32de:	80 93 e2 04 	sts	0x04E2, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    32e2:	26 96       	adiw	r28, 0x06	; 6
    32e4:	0f b6       	in	r0, 0x3f	; 63
    32e6:	f8 94       	cli
    32e8:	de bf       	out	0x3e, r29	; 62
    32ea:	0f be       	out	0x3f, r0	; 63
    32ec:	cd bf       	out	0x3d, r28	; 61
    32ee:	cf 91       	pop	r28
    32f0:	df 91       	pop	r29
    32f2:	08 95       	ret

000032f4 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    32f4:	df 93       	push	r29
    32f6:	cf 93       	push	r28
    32f8:	00 d0       	rcall	.+0      	; 0x32fa <vTaskSwitchContext+0x6>
    32fa:	cd b7       	in	r28, 0x3d	; 61
    32fc:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    32fe:	80 91 e1 04 	lds	r24, 0x04E1
    3302:	88 23       	and	r24, r24
    3304:	49 f0       	breq	.+18     	; 0x3318 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    3306:	81 e0       	ldi	r24, 0x01	; 1
    3308:	80 93 e3 04 	sts	0x04E3, r24
    330c:	54 c0       	rjmp	.+168    	; 0x33b6 <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    330e:	80 91 df 04 	lds	r24, 0x04DF
    3312:	81 50       	subi	r24, 0x01	; 1
    3314:	80 93 df 04 	sts	0x04DF, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    3318:	80 91 df 04 	lds	r24, 0x04DF
    331c:	28 2f       	mov	r18, r24
    331e:	30 e0       	ldi	r19, 0x00	; 0
    3320:	c9 01       	movw	r24, r18
    3322:	88 0f       	add	r24, r24
    3324:	99 1f       	adc	r25, r25
    3326:	88 0f       	add	r24, r24
    3328:	99 1f       	adc	r25, r25
    332a:	88 0f       	add	r24, r24
    332c:	99 1f       	adc	r25, r25
    332e:	82 0f       	add	r24, r18
    3330:	93 1f       	adc	r25, r19
    3332:	fc 01       	movw	r30, r24
    3334:	ea 51       	subi	r30, 0x1A	; 26
    3336:	fb 4f       	sbci	r31, 0xFB	; 251
    3338:	80 81       	ld	r24, Z
    333a:	88 23       	and	r24, r24
    333c:	41 f3       	breq	.-48     	; 0x330e <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    333e:	80 91 df 04 	lds	r24, 0x04DF
    3342:	28 2f       	mov	r18, r24
    3344:	30 e0       	ldi	r19, 0x00	; 0
    3346:	c9 01       	movw	r24, r18
    3348:	88 0f       	add	r24, r24
    334a:	99 1f       	adc	r25, r25
    334c:	88 0f       	add	r24, r24
    334e:	99 1f       	adc	r25, r25
    3350:	88 0f       	add	r24, r24
    3352:	99 1f       	adc	r25, r25
    3354:	82 0f       	add	r24, r18
    3356:	93 1f       	adc	r25, r19
    3358:	8a 51       	subi	r24, 0x1A	; 26
    335a:	9b 4f       	sbci	r25, 0xFB	; 251
    335c:	9a 83       	std	Y+2, r25	; 0x02
    335e:	89 83       	std	Y+1, r24	; 0x01
    3360:	e9 81       	ldd	r30, Y+1	; 0x01
    3362:	fa 81       	ldd	r31, Y+2	; 0x02
    3364:	01 80       	ldd	r0, Z+1	; 0x01
    3366:	f2 81       	ldd	r31, Z+2	; 0x02
    3368:	e0 2d       	mov	r30, r0
    336a:	82 81       	ldd	r24, Z+2	; 0x02
    336c:	93 81       	ldd	r25, Z+3	; 0x03
    336e:	e9 81       	ldd	r30, Y+1	; 0x01
    3370:	fa 81       	ldd	r31, Y+2	; 0x02
    3372:	92 83       	std	Z+2, r25	; 0x02
    3374:	81 83       	std	Z+1, r24	; 0x01
    3376:	e9 81       	ldd	r30, Y+1	; 0x01
    3378:	fa 81       	ldd	r31, Y+2	; 0x02
    337a:	21 81       	ldd	r18, Z+1	; 0x01
    337c:	32 81       	ldd	r19, Z+2	; 0x02
    337e:	89 81       	ldd	r24, Y+1	; 0x01
    3380:	9a 81       	ldd	r25, Y+2	; 0x02
    3382:	03 96       	adiw	r24, 0x03	; 3
    3384:	28 17       	cp	r18, r24
    3386:	39 07       	cpc	r19, r25
    3388:	59 f4       	brne	.+22     	; 0x33a0 <vTaskSwitchContext+0xac>
    338a:	e9 81       	ldd	r30, Y+1	; 0x01
    338c:	fa 81       	ldd	r31, Y+2	; 0x02
    338e:	01 80       	ldd	r0, Z+1	; 0x01
    3390:	f2 81       	ldd	r31, Z+2	; 0x02
    3392:	e0 2d       	mov	r30, r0
    3394:	82 81       	ldd	r24, Z+2	; 0x02
    3396:	93 81       	ldd	r25, Z+3	; 0x03
    3398:	e9 81       	ldd	r30, Y+1	; 0x01
    339a:	fa 81       	ldd	r31, Y+2	; 0x02
    339c:	92 83       	std	Z+2, r25	; 0x02
    339e:	81 83       	std	Z+1, r24	; 0x01
    33a0:	e9 81       	ldd	r30, Y+1	; 0x01
    33a2:	fa 81       	ldd	r31, Y+2	; 0x02
    33a4:	01 80       	ldd	r0, Z+1	; 0x01
    33a6:	f2 81       	ldd	r31, Z+2	; 0x02
    33a8:	e0 2d       	mov	r30, r0
    33aa:	86 81       	ldd	r24, Z+6	; 0x06
    33ac:	97 81       	ldd	r25, Z+7	; 0x07
    33ae:	90 93 d9 04 	sts	0x04D9, r25
    33b2:	80 93 d8 04 	sts	0x04D8, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    33b6:	0f 90       	pop	r0
    33b8:	0f 90       	pop	r0
    33ba:	cf 91       	pop	r28
    33bc:	df 91       	pop	r29
    33be:	08 95       	ret

000033c0 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    33c0:	df 93       	push	r29
    33c2:	cf 93       	push	r28
    33c4:	00 d0       	rcall	.+0      	; 0x33c6 <vTaskPlaceOnEventList+0x6>
    33c6:	00 d0       	rcall	.+0      	; 0x33c8 <vTaskPlaceOnEventList+0x8>
    33c8:	00 d0       	rcall	.+0      	; 0x33ca <vTaskPlaceOnEventList+0xa>
    33ca:	cd b7       	in	r28, 0x3d	; 61
    33cc:	de b7       	in	r29, 0x3e	; 62
    33ce:	9c 83       	std	Y+4, r25	; 0x04
    33d0:	8b 83       	std	Y+3, r24	; 0x03
    33d2:	7e 83       	std	Y+6, r23	; 0x06
    33d4:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    33d6:	4b 81       	ldd	r20, Y+3	; 0x03
    33d8:	5c 81       	ldd	r21, Y+4	; 0x04
    33da:	80 91 d8 04 	lds	r24, 0x04D8
    33de:	90 91 d9 04 	lds	r25, 0x04D9
    33e2:	9c 01       	movw	r18, r24
    33e4:	24 5f       	subi	r18, 0xF4	; 244
    33e6:	3f 4f       	sbci	r19, 0xFF	; 255
    33e8:	ca 01       	movw	r24, r20
    33ea:	b9 01       	movw	r22, r18
    33ec:	0e 94 96 0d 	call	0x1b2c	; 0x1b2c <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    33f0:	80 91 d8 04 	lds	r24, 0x04D8
    33f4:	90 91 d9 04 	lds	r25, 0x04D9
    33f8:	02 96       	adiw	r24, 0x02	; 2
    33fa:	0e 94 02 0e 	call	0x1c04	; 0x1c04 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    33fe:	20 91 dc 04 	lds	r18, 0x04DC
    3402:	30 91 dd 04 	lds	r19, 0x04DD
    3406:	8d 81       	ldd	r24, Y+5	; 0x05
    3408:	9e 81       	ldd	r25, Y+6	; 0x06
    340a:	82 0f       	add	r24, r18
    340c:	93 1f       	adc	r25, r19
    340e:	9a 83       	std	Y+2, r25	; 0x02
    3410:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    3412:	89 81       	ldd	r24, Y+1	; 0x01
    3414:	9a 81       	ldd	r25, Y+2	; 0x02
    3416:	0e 94 da 1b 	call	0x37b4	; 0x37b4 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    341a:	26 96       	adiw	r28, 0x06	; 6
    341c:	0f b6       	in	r0, 0x3f	; 63
    341e:	f8 94       	cli
    3420:	de bf       	out	0x3e, r29	; 62
    3422:	0f be       	out	0x3f, r0	; 63
    3424:	cd bf       	out	0x3d, r28	; 61
    3426:	cf 91       	pop	r28
    3428:	df 91       	pop	r29
    342a:	08 95       	ret

0000342c <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    342c:	df 93       	push	r29
    342e:	cf 93       	push	r28
    3430:	00 d0       	rcall	.+0      	; 0x3432 <xTaskRemoveFromEventList+0x6>
    3432:	00 d0       	rcall	.+0      	; 0x3434 <xTaskRemoveFromEventList+0x8>
    3434:	0f 92       	push	r0
    3436:	cd b7       	in	r28, 0x3d	; 61
    3438:	de b7       	in	r29, 0x3e	; 62
    343a:	9d 83       	std	Y+5, r25	; 0x05
    343c:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    343e:	ec 81       	ldd	r30, Y+4	; 0x04
    3440:	fd 81       	ldd	r31, Y+5	; 0x05
    3442:	05 80       	ldd	r0, Z+5	; 0x05
    3444:	f6 81       	ldd	r31, Z+6	; 0x06
    3446:	e0 2d       	mov	r30, r0
    3448:	86 81       	ldd	r24, Z+6	; 0x06
    344a:	97 81       	ldd	r25, Z+7	; 0x07
    344c:	9b 83       	std	Y+3, r25	; 0x03
    344e:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    3450:	8a 81       	ldd	r24, Y+2	; 0x02
    3452:	9b 81       	ldd	r25, Y+3	; 0x03
    3454:	0c 96       	adiw	r24, 0x0c	; 12
    3456:	0e 94 02 0e 	call	0x1c04	; 0x1c04 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    345a:	80 91 e1 04 	lds	r24, 0x04E1
    345e:	88 23       	and	r24, r24
    3460:	61 f5       	brne	.+88     	; 0x34ba <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    3462:	8a 81       	ldd	r24, Y+2	; 0x02
    3464:	9b 81       	ldd	r25, Y+3	; 0x03
    3466:	02 96       	adiw	r24, 0x02	; 2
    3468:	0e 94 02 0e 	call	0x1c04	; 0x1c04 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    346c:	ea 81       	ldd	r30, Y+2	; 0x02
    346e:	fb 81       	ldd	r31, Y+3	; 0x03
    3470:	96 89       	ldd	r25, Z+22	; 0x16
    3472:	80 91 df 04 	lds	r24, 0x04DF
    3476:	89 17       	cp	r24, r25
    3478:	28 f4       	brcc	.+10     	; 0x3484 <xTaskRemoveFromEventList+0x58>
    347a:	ea 81       	ldd	r30, Y+2	; 0x02
    347c:	fb 81       	ldd	r31, Y+3	; 0x03
    347e:	86 89       	ldd	r24, Z+22	; 0x16
    3480:	80 93 df 04 	sts	0x04DF, r24
    3484:	ea 81       	ldd	r30, Y+2	; 0x02
    3486:	fb 81       	ldd	r31, Y+3	; 0x03
    3488:	86 89       	ldd	r24, Z+22	; 0x16
    348a:	28 2f       	mov	r18, r24
    348c:	30 e0       	ldi	r19, 0x00	; 0
    348e:	c9 01       	movw	r24, r18
    3490:	88 0f       	add	r24, r24
    3492:	99 1f       	adc	r25, r25
    3494:	88 0f       	add	r24, r24
    3496:	99 1f       	adc	r25, r25
    3498:	88 0f       	add	r24, r24
    349a:	99 1f       	adc	r25, r25
    349c:	82 0f       	add	r24, r18
    349e:	93 1f       	adc	r25, r19
    34a0:	ac 01       	movw	r20, r24
    34a2:	4a 51       	subi	r20, 0x1A	; 26
    34a4:	5b 4f       	sbci	r21, 0xFB	; 251
    34a6:	8a 81       	ldd	r24, Y+2	; 0x02
    34a8:	9b 81       	ldd	r25, Y+3	; 0x03
    34aa:	9c 01       	movw	r18, r24
    34ac:	2e 5f       	subi	r18, 0xFE	; 254
    34ae:	3f 4f       	sbci	r19, 0xFF	; 255
    34b0:	ca 01       	movw	r24, r20
    34b2:	b9 01       	movw	r22, r18
    34b4:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <vListInsertEnd>
    34b8:	0a c0       	rjmp	.+20     	; 0x34ce <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    34ba:	8a 81       	ldd	r24, Y+2	; 0x02
    34bc:	9b 81       	ldd	r25, Y+3	; 0x03
    34be:	9c 01       	movw	r18, r24
    34c0:	24 5f       	subi	r18, 0xF4	; 244
    34c2:	3f 4f       	sbci	r19, 0xFF	; 255
    34c4:	86 e5       	ldi	r24, 0x56	; 86
    34c6:	95 e0       	ldi	r25, 0x05	; 5
    34c8:	b9 01       	movw	r22, r18
    34ca:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    34ce:	ea 81       	ldd	r30, Y+2	; 0x02
    34d0:	fb 81       	ldd	r31, Y+3	; 0x03
    34d2:	96 89       	ldd	r25, Z+22	; 0x16
    34d4:	e0 91 d8 04 	lds	r30, 0x04D8
    34d8:	f0 91 d9 04 	lds	r31, 0x04D9
    34dc:	86 89       	ldd	r24, Z+22	; 0x16
    34de:	98 17       	cp	r25, r24
    34e0:	18 f0       	brcs	.+6      	; 0x34e8 <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    34e2:	81 e0       	ldi	r24, 0x01	; 1
    34e4:	89 83       	std	Y+1, r24	; 0x01
    34e6:	01 c0       	rjmp	.+2      	; 0x34ea <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    34e8:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    34ea:	89 81       	ldd	r24, Y+1	; 0x01
}
    34ec:	0f 90       	pop	r0
    34ee:	0f 90       	pop	r0
    34f0:	0f 90       	pop	r0
    34f2:	0f 90       	pop	r0
    34f4:	0f 90       	pop	r0
    34f6:	cf 91       	pop	r28
    34f8:	df 91       	pop	r29
    34fa:	08 95       	ret

000034fc <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    34fc:	df 93       	push	r29
    34fe:	cf 93       	push	r28
    3500:	00 d0       	rcall	.+0      	; 0x3502 <vTaskSetTimeOutState+0x6>
    3502:	cd b7       	in	r28, 0x3d	; 61
    3504:	de b7       	in	r29, 0x3e	; 62
    3506:	9a 83       	std	Y+2, r25	; 0x02
    3508:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    350a:	80 91 e4 04 	lds	r24, 0x04E4
    350e:	e9 81       	ldd	r30, Y+1	; 0x01
    3510:	fa 81       	ldd	r31, Y+2	; 0x02
    3512:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    3514:	80 91 dc 04 	lds	r24, 0x04DC
    3518:	90 91 dd 04 	lds	r25, 0x04DD
    351c:	e9 81       	ldd	r30, Y+1	; 0x01
    351e:	fa 81       	ldd	r31, Y+2	; 0x02
    3520:	92 83       	std	Z+2, r25	; 0x02
    3522:	81 83       	std	Z+1, r24	; 0x01
}
    3524:	0f 90       	pop	r0
    3526:	0f 90       	pop	r0
    3528:	cf 91       	pop	r28
    352a:	df 91       	pop	r29
    352c:	08 95       	ret

0000352e <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    352e:	df 93       	push	r29
    3530:	cf 93       	push	r28
    3532:	00 d0       	rcall	.+0      	; 0x3534 <xTaskCheckForTimeOut+0x6>
    3534:	00 d0       	rcall	.+0      	; 0x3536 <xTaskCheckForTimeOut+0x8>
    3536:	0f 92       	push	r0
    3538:	cd b7       	in	r28, 0x3d	; 61
    353a:	de b7       	in	r29, 0x3e	; 62
    353c:	9b 83       	std	Y+3, r25	; 0x03
    353e:	8a 83       	std	Y+2, r24	; 0x02
    3540:	7d 83       	std	Y+5, r23	; 0x05
    3542:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    3544:	0f b6       	in	r0, 0x3f	; 63
    3546:	f8 94       	cli
    3548:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    354a:	ea 81       	ldd	r30, Y+2	; 0x02
    354c:	fb 81       	ldd	r31, Y+3	; 0x03
    354e:	90 81       	ld	r25, Z
    3550:	80 91 e4 04 	lds	r24, 0x04E4
    3554:	98 17       	cp	r25, r24
    3556:	71 f0       	breq	.+28     	; 0x3574 <xTaskCheckForTimeOut+0x46>
    3558:	ea 81       	ldd	r30, Y+2	; 0x02
    355a:	fb 81       	ldd	r31, Y+3	; 0x03
    355c:	21 81       	ldd	r18, Z+1	; 0x01
    355e:	32 81       	ldd	r19, Z+2	; 0x02
    3560:	80 91 dc 04 	lds	r24, 0x04DC
    3564:	90 91 dd 04 	lds	r25, 0x04DD
    3568:	82 17       	cp	r24, r18
    356a:	93 07       	cpc	r25, r19
    356c:	18 f0       	brcs	.+6      	; 0x3574 <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    356e:	81 e0       	ldi	r24, 0x01	; 1
    3570:	89 83       	std	Y+1, r24	; 0x01
    3572:	2f c0       	rjmp	.+94     	; 0x35d2 <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    3574:	20 91 dc 04 	lds	r18, 0x04DC
    3578:	30 91 dd 04 	lds	r19, 0x04DD
    357c:	ea 81       	ldd	r30, Y+2	; 0x02
    357e:	fb 81       	ldd	r31, Y+3	; 0x03
    3580:	81 81       	ldd	r24, Z+1	; 0x01
    3582:	92 81       	ldd	r25, Z+2	; 0x02
    3584:	28 1b       	sub	r18, r24
    3586:	39 0b       	sbc	r19, r25
    3588:	ec 81       	ldd	r30, Y+4	; 0x04
    358a:	fd 81       	ldd	r31, Y+5	; 0x05
    358c:	80 81       	ld	r24, Z
    358e:	91 81       	ldd	r25, Z+1	; 0x01
    3590:	28 17       	cp	r18, r24
    3592:	39 07       	cpc	r19, r25
    3594:	e0 f4       	brcc	.+56     	; 0x35ce <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    3596:	ec 81       	ldd	r30, Y+4	; 0x04
    3598:	fd 81       	ldd	r31, Y+5	; 0x05
    359a:	40 81       	ld	r20, Z
    359c:	51 81       	ldd	r21, Z+1	; 0x01
    359e:	ea 81       	ldd	r30, Y+2	; 0x02
    35a0:	fb 81       	ldd	r31, Y+3	; 0x03
    35a2:	21 81       	ldd	r18, Z+1	; 0x01
    35a4:	32 81       	ldd	r19, Z+2	; 0x02
    35a6:	80 91 dc 04 	lds	r24, 0x04DC
    35aa:	90 91 dd 04 	lds	r25, 0x04DD
    35ae:	b9 01       	movw	r22, r18
    35b0:	68 1b       	sub	r22, r24
    35b2:	79 0b       	sbc	r23, r25
    35b4:	cb 01       	movw	r24, r22
    35b6:	84 0f       	add	r24, r20
    35b8:	95 1f       	adc	r25, r21
    35ba:	ec 81       	ldd	r30, Y+4	; 0x04
    35bc:	fd 81       	ldd	r31, Y+5	; 0x05
    35be:	91 83       	std	Z+1, r25	; 0x01
    35c0:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    35c2:	8a 81       	ldd	r24, Y+2	; 0x02
    35c4:	9b 81       	ldd	r25, Y+3	; 0x03
    35c6:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    35ca:	19 82       	std	Y+1, r1	; 0x01
    35cc:	02 c0       	rjmp	.+4      	; 0x35d2 <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    35ce:	81 e0       	ldi	r24, 0x01	; 1
    35d0:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    35d2:	0f 90       	pop	r0
    35d4:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    35d6:	89 81       	ldd	r24, Y+1	; 0x01
}
    35d8:	0f 90       	pop	r0
    35da:	0f 90       	pop	r0
    35dc:	0f 90       	pop	r0
    35de:	0f 90       	pop	r0
    35e0:	0f 90       	pop	r0
    35e2:	cf 91       	pop	r28
    35e4:	df 91       	pop	r29
    35e6:	08 95       	ret

000035e8 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    35e8:	df 93       	push	r29
    35ea:	cf 93       	push	r28
    35ec:	cd b7       	in	r28, 0x3d	; 61
    35ee:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    35f0:	81 e0       	ldi	r24, 0x01	; 1
    35f2:	80 93 e3 04 	sts	0x04E3, r24
}
    35f6:	cf 91       	pop	r28
    35f8:	df 91       	pop	r29
    35fa:	08 95       	ret

000035fc <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    35fc:	df 93       	push	r29
    35fe:	cf 93       	push	r28
    3600:	00 d0       	rcall	.+0      	; 0x3602 <prvIdleTask+0x6>
    3602:	cd b7       	in	r28, 0x3d	; 61
    3604:	de b7       	in	r29, 0x3e	; 62
    3606:	9a 83       	std	Y+2, r25	; 0x02
    3608:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    360a:	0e 94 9c 1b 	call	0x3738	; 0x3738 <prvCheckTasksWaitingTermination>
    360e:	fd cf       	rjmp	.-6      	; 0x360a <prvIdleTask+0xe>

00003610 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    3610:	0f 93       	push	r16
    3612:	1f 93       	push	r17
    3614:	df 93       	push	r29
    3616:	cf 93       	push	r28
    3618:	cd b7       	in	r28, 0x3d	; 61
    361a:	de b7       	in	r29, 0x3e	; 62
    361c:	29 97       	sbiw	r28, 0x09	; 9
    361e:	0f b6       	in	r0, 0x3f	; 63
    3620:	f8 94       	cli
    3622:	de bf       	out	0x3e, r29	; 62
    3624:	0f be       	out	0x3f, r0	; 63
    3626:	cd bf       	out	0x3d, r28	; 61
    3628:	9a 83       	std	Y+2, r25	; 0x02
    362a:	89 83       	std	Y+1, r24	; 0x01
    362c:	7c 83       	std	Y+4, r23	; 0x04
    362e:	6b 83       	std	Y+3, r22	; 0x03
    3630:	4d 83       	std	Y+5, r20	; 0x05
    3632:	3f 83       	std	Y+7, r19	; 0x07
    3634:	2e 83       	std	Y+6, r18	; 0x06
    3636:	19 87       	std	Y+9, r17	; 0x09
    3638:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    363a:	89 81       	ldd	r24, Y+1	; 0x01
    363c:	9a 81       	ldd	r25, Y+2	; 0x02
    363e:	49 96       	adiw	r24, 0x19	; 25
    3640:	2b 81       	ldd	r18, Y+3	; 0x03
    3642:	3c 81       	ldd	r19, Y+4	; 0x04
    3644:	b9 01       	movw	r22, r18
    3646:	48 e0       	ldi	r20, 0x08	; 8
    3648:	50 e0       	ldi	r21, 0x00	; 0
    364a:	0e 94 1f 1e 	call	0x3c3e	; 0x3c3e <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    364e:	e9 81       	ldd	r30, Y+1	; 0x01
    3650:	fa 81       	ldd	r31, Y+2	; 0x02
    3652:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    3654:	8d 81       	ldd	r24, Y+5	; 0x05
    3656:	8a 30       	cpi	r24, 0x0A	; 10
    3658:	10 f0       	brcs	.+4      	; 0x365e <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    365a:	89 e0       	ldi	r24, 0x09	; 9
    365c:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    365e:	e9 81       	ldd	r30, Y+1	; 0x01
    3660:	fa 81       	ldd	r31, Y+2	; 0x02
    3662:	8d 81       	ldd	r24, Y+5	; 0x05
    3664:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    3666:	89 81       	ldd	r24, Y+1	; 0x01
    3668:	9a 81       	ldd	r25, Y+2	; 0x02
    366a:	02 96       	adiw	r24, 0x02	; 2
    366c:	0e 94 3a 0d 	call	0x1a74	; 0x1a74 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    3670:	89 81       	ldd	r24, Y+1	; 0x01
    3672:	9a 81       	ldd	r25, Y+2	; 0x02
    3674:	0c 96       	adiw	r24, 0x0c	; 12
    3676:	0e 94 3a 0d 	call	0x1a74	; 0x1a74 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    367a:	e9 81       	ldd	r30, Y+1	; 0x01
    367c:	fa 81       	ldd	r31, Y+2	; 0x02
    367e:	89 81       	ldd	r24, Y+1	; 0x01
    3680:	9a 81       	ldd	r25, Y+2	; 0x02
    3682:	91 87       	std	Z+9, r25	; 0x09
    3684:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    3686:	8d 81       	ldd	r24, Y+5	; 0x05
    3688:	28 2f       	mov	r18, r24
    368a:	30 e0       	ldi	r19, 0x00	; 0
    368c:	8a e0       	ldi	r24, 0x0A	; 10
    368e:	90 e0       	ldi	r25, 0x00	; 0
    3690:	82 1b       	sub	r24, r18
    3692:	93 0b       	sbc	r25, r19
    3694:	e9 81       	ldd	r30, Y+1	; 0x01
    3696:	fa 81       	ldd	r31, Y+2	; 0x02
    3698:	95 87       	std	Z+13, r25	; 0x0d
    369a:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    369c:	e9 81       	ldd	r30, Y+1	; 0x01
    369e:	fa 81       	ldd	r31, Y+2	; 0x02
    36a0:	89 81       	ldd	r24, Y+1	; 0x01
    36a2:	9a 81       	ldd	r25, Y+2	; 0x02
    36a4:	93 8b       	std	Z+19, r25	; 0x13
    36a6:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    36a8:	29 96       	adiw	r28, 0x09	; 9
    36aa:	0f b6       	in	r0, 0x3f	; 63
    36ac:	f8 94       	cli
    36ae:	de bf       	out	0x3e, r29	; 62
    36b0:	0f be       	out	0x3f, r0	; 63
    36b2:	cd bf       	out	0x3d, r28	; 61
    36b4:	cf 91       	pop	r28
    36b6:	df 91       	pop	r29
    36b8:	1f 91       	pop	r17
    36ba:	0f 91       	pop	r16
    36bc:	08 95       	ret

000036be <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    36be:	df 93       	push	r29
    36c0:	cf 93       	push	r28
    36c2:	0f 92       	push	r0
    36c4:	cd b7       	in	r28, 0x3d	; 61
    36c6:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    36c8:	19 82       	std	Y+1, r1	; 0x01
    36ca:	13 c0       	rjmp	.+38     	; 0x36f2 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    36cc:	89 81       	ldd	r24, Y+1	; 0x01
    36ce:	28 2f       	mov	r18, r24
    36d0:	30 e0       	ldi	r19, 0x00	; 0
    36d2:	c9 01       	movw	r24, r18
    36d4:	88 0f       	add	r24, r24
    36d6:	99 1f       	adc	r25, r25
    36d8:	88 0f       	add	r24, r24
    36da:	99 1f       	adc	r25, r25
    36dc:	88 0f       	add	r24, r24
    36de:	99 1f       	adc	r25, r25
    36e0:	82 0f       	add	r24, r18
    36e2:	93 1f       	adc	r25, r19
    36e4:	8a 51       	subi	r24, 0x1A	; 26
    36e6:	9b 4f       	sbci	r25, 0xFB	; 251
    36e8:	0e 94 10 0d 	call	0x1a20	; 0x1a20 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    36ec:	89 81       	ldd	r24, Y+1	; 0x01
    36ee:	8f 5f       	subi	r24, 0xFF	; 255
    36f0:	89 83       	std	Y+1, r24	; 0x01
    36f2:	89 81       	ldd	r24, Y+1	; 0x01
    36f4:	8a 30       	cpi	r24, 0x0A	; 10
    36f6:	50 f3       	brcs	.-44     	; 0x36cc <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    36f8:	80 e4       	ldi	r24, 0x40	; 64
    36fa:	95 e0       	ldi	r25, 0x05	; 5
    36fc:	0e 94 10 0d 	call	0x1a20	; 0x1a20 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    3700:	89 e4       	ldi	r24, 0x49	; 73
    3702:	95 e0       	ldi	r25, 0x05	; 5
    3704:	0e 94 10 0d 	call	0x1a20	; 0x1a20 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    3708:	86 e5       	ldi	r24, 0x56	; 86
    370a:	95 e0       	ldi	r25, 0x05	; 5
    370c:	0e 94 10 0d 	call	0x1a20	; 0x1a20 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    3710:	8f e5       	ldi	r24, 0x5F	; 95
    3712:	95 e0       	ldi	r25, 0x05	; 5
    3714:	0e 94 10 0d 	call	0x1a20	; 0x1a20 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    3718:	80 e4       	ldi	r24, 0x40	; 64
    371a:	95 e0       	ldi	r25, 0x05	; 5
    371c:	90 93 53 05 	sts	0x0553, r25
    3720:	80 93 52 05 	sts	0x0552, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    3724:	89 e4       	ldi	r24, 0x49	; 73
    3726:	95 e0       	ldi	r25, 0x05	; 5
    3728:	90 93 55 05 	sts	0x0555, r25
    372c:	80 93 54 05 	sts	0x0554, r24
}
    3730:	0f 90       	pop	r0
    3732:	cf 91       	pop	r28
    3734:	df 91       	pop	r29
    3736:	08 95       	ret

00003738 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    3738:	df 93       	push	r29
    373a:	cf 93       	push	r28
    373c:	00 d0       	rcall	.+0      	; 0x373e <prvCheckTasksWaitingTermination+0x6>
    373e:	0f 92       	push	r0
    3740:	cd b7       	in	r28, 0x3d	; 61
    3742:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    3744:	80 91 da 04 	lds	r24, 0x04DA
    3748:	88 23       	and	r24, r24
    374a:	71 f1       	breq	.+92     	; 0x37a8 <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    374c:	0e 94 da 17 	call	0x2fb4	; 0x2fb4 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    3750:	80 91 5f 05 	lds	r24, 0x055F
    3754:	1b 82       	std	Y+3, r1	; 0x03
    3756:	88 23       	and	r24, r24
    3758:	11 f4       	brne	.+4      	; 0x375e <prvCheckTasksWaitingTermination+0x26>
    375a:	81 e0       	ldi	r24, 0x01	; 1
    375c:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    375e:	0e 94 e6 17 	call	0x2fcc	; 0x2fcc <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    3762:	8b 81       	ldd	r24, Y+3	; 0x03
    3764:	88 23       	and	r24, r24
    3766:	01 f5       	brne	.+64     	; 0x37a8 <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    3768:	0f b6       	in	r0, 0x3f	; 63
    376a:	f8 94       	cli
    376c:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    376e:	e0 91 64 05 	lds	r30, 0x0564
    3772:	f0 91 65 05 	lds	r31, 0x0565
    3776:	86 81       	ldd	r24, Z+6	; 0x06
    3778:	97 81       	ldd	r25, Z+7	; 0x07
    377a:	9a 83       	std	Y+2, r25	; 0x02
    377c:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    377e:	89 81       	ldd	r24, Y+1	; 0x01
    3780:	9a 81       	ldd	r25, Y+2	; 0x02
    3782:	02 96       	adiw	r24, 0x02	; 2
    3784:	0e 94 02 0e 	call	0x1c04	; 0x1c04 <vListRemove>
					--uxCurrentNumberOfTasks;
    3788:	80 91 db 04 	lds	r24, 0x04DB
    378c:	81 50       	subi	r24, 0x01	; 1
    378e:	80 93 db 04 	sts	0x04DB, r24
					--uxTasksDeleted;
    3792:	80 91 da 04 	lds	r24, 0x04DA
    3796:	81 50       	subi	r24, 0x01	; 1
    3798:	80 93 da 04 	sts	0x04DA, r24
				}
				taskEXIT_CRITICAL();
    379c:	0f 90       	pop	r0
    379e:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    37a0:	89 81       	ldd	r24, Y+1	; 0x01
    37a2:	9a 81       	ldd	r25, Y+2	; 0x02
    37a4:	0e 94 73 1c 	call	0x38e6	; 0x38e6 <prvDeleteTCB>
			}
		}
	}
	#endif
}
    37a8:	0f 90       	pop	r0
    37aa:	0f 90       	pop	r0
    37ac:	0f 90       	pop	r0
    37ae:	cf 91       	pop	r28
    37b0:	df 91       	pop	r29
    37b2:	08 95       	ret

000037b4 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    37b4:	df 93       	push	r29
    37b6:	cf 93       	push	r28
    37b8:	00 d0       	rcall	.+0      	; 0x37ba <prvAddCurrentTaskToDelayedList+0x6>
    37ba:	cd b7       	in	r28, 0x3d	; 61
    37bc:	de b7       	in	r29, 0x3e	; 62
    37be:	9a 83       	std	Y+2, r25	; 0x02
    37c0:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    37c2:	e0 91 d8 04 	lds	r30, 0x04D8
    37c6:	f0 91 d9 04 	lds	r31, 0x04D9
    37ca:	89 81       	ldd	r24, Y+1	; 0x01
    37cc:	9a 81       	ldd	r25, Y+2	; 0x02
    37ce:	93 83       	std	Z+3, r25	; 0x03
    37d0:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    37d2:	20 91 dc 04 	lds	r18, 0x04DC
    37d6:	30 91 dd 04 	lds	r19, 0x04DD
    37da:	89 81       	ldd	r24, Y+1	; 0x01
    37dc:	9a 81       	ldd	r25, Y+2	; 0x02
    37de:	82 17       	cp	r24, r18
    37e0:	93 07       	cpc	r25, r19
    37e2:	70 f4       	brcc	.+28     	; 0x3800 <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    37e4:	80 91 54 05 	lds	r24, 0x0554
    37e8:	90 91 55 05 	lds	r25, 0x0555
    37ec:	20 91 d8 04 	lds	r18, 0x04D8
    37f0:	30 91 d9 04 	lds	r19, 0x04D9
    37f4:	2e 5f       	subi	r18, 0xFE	; 254
    37f6:	3f 4f       	sbci	r19, 0xFF	; 255
    37f8:	b9 01       	movw	r22, r18
    37fa:	0e 94 96 0d 	call	0x1b2c	; 0x1b2c <vListInsert>
    37fe:	1e c0       	rjmp	.+60     	; 0x383c <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    3800:	40 91 52 05 	lds	r20, 0x0552
    3804:	50 91 53 05 	lds	r21, 0x0553
    3808:	80 91 d8 04 	lds	r24, 0x04D8
    380c:	90 91 d9 04 	lds	r25, 0x04D9
    3810:	9c 01       	movw	r18, r24
    3812:	2e 5f       	subi	r18, 0xFE	; 254
    3814:	3f 4f       	sbci	r19, 0xFF	; 255
    3816:	ca 01       	movw	r24, r20
    3818:	b9 01       	movw	r22, r18
    381a:	0e 94 96 0d 	call	0x1b2c	; 0x1b2c <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    381e:	20 91 a1 00 	lds	r18, 0x00A1
    3822:	30 91 a2 00 	lds	r19, 0x00A2
    3826:	89 81       	ldd	r24, Y+1	; 0x01
    3828:	9a 81       	ldd	r25, Y+2	; 0x02
    382a:	82 17       	cp	r24, r18
    382c:	93 07       	cpc	r25, r19
    382e:	30 f4       	brcc	.+12     	; 0x383c <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    3830:	89 81       	ldd	r24, Y+1	; 0x01
    3832:	9a 81       	ldd	r25, Y+2	; 0x02
    3834:	90 93 a2 00 	sts	0x00A2, r25
    3838:	80 93 a1 00 	sts	0x00A1, r24
		}
	}
}
    383c:	0f 90       	pop	r0
    383e:	0f 90       	pop	r0
    3840:	cf 91       	pop	r28
    3842:	df 91       	pop	r29
    3844:	08 95       	ret

00003846 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    3846:	df 93       	push	r29
    3848:	cf 93       	push	r28
    384a:	cd b7       	in	r28, 0x3d	; 61
    384c:	de b7       	in	r29, 0x3e	; 62
    384e:	28 97       	sbiw	r28, 0x08	; 8
    3850:	0f b6       	in	r0, 0x3f	; 63
    3852:	f8 94       	cli
    3854:	de bf       	out	0x3e, r29	; 62
    3856:	0f be       	out	0x3f, r0	; 63
    3858:	cd bf       	out	0x3d, r28	; 61
    385a:	9c 83       	std	Y+4, r25	; 0x04
    385c:	8b 83       	std	Y+3, r24	; 0x03
    385e:	7e 83       	std	Y+6, r23	; 0x06
    3860:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    3862:	81 e2       	ldi	r24, 0x21	; 33
    3864:	90 e0       	ldi	r25, 0x00	; 0
    3866:	0e 94 a4 0c 	call	0x1948	; 0x1948 <pvPortMalloc>
    386a:	9a 83       	std	Y+2, r25	; 0x02
    386c:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    386e:	89 81       	ldd	r24, Y+1	; 0x01
    3870:	9a 81       	ldd	r25, Y+2	; 0x02
    3872:	00 97       	sbiw	r24, 0x00	; 0
    3874:	69 f1       	breq	.+90     	; 0x38d0 <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    3876:	8d 81       	ldd	r24, Y+5	; 0x05
    3878:	9e 81       	ldd	r25, Y+6	; 0x06
    387a:	00 97       	sbiw	r24, 0x00	; 0
    387c:	39 f4       	brne	.+14     	; 0x388c <prvAllocateTCBAndStack+0x46>
    387e:	8b 81       	ldd	r24, Y+3	; 0x03
    3880:	9c 81       	ldd	r25, Y+4	; 0x04
    3882:	0e 94 a4 0c 	call	0x1948	; 0x1948 <pvPortMalloc>
    3886:	98 87       	std	Y+8, r25	; 0x08
    3888:	8f 83       	std	Y+7, r24	; 0x07
    388a:	04 c0       	rjmp	.+8      	; 0x3894 <prvAllocateTCBAndStack+0x4e>
    388c:	8d 81       	ldd	r24, Y+5	; 0x05
    388e:	9e 81       	ldd	r25, Y+6	; 0x06
    3890:	98 87       	std	Y+8, r25	; 0x08
    3892:	8f 83       	std	Y+7, r24	; 0x07
    3894:	e9 81       	ldd	r30, Y+1	; 0x01
    3896:	fa 81       	ldd	r31, Y+2	; 0x02
    3898:	8f 81       	ldd	r24, Y+7	; 0x07
    389a:	98 85       	ldd	r25, Y+8	; 0x08
    389c:	90 8f       	std	Z+24, r25	; 0x18
    389e:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    38a0:	e9 81       	ldd	r30, Y+1	; 0x01
    38a2:	fa 81       	ldd	r31, Y+2	; 0x02
    38a4:	87 89       	ldd	r24, Z+23	; 0x17
    38a6:	90 8d       	ldd	r25, Z+24	; 0x18
    38a8:	00 97       	sbiw	r24, 0x00	; 0
    38aa:	39 f4       	brne	.+14     	; 0x38ba <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    38ac:	89 81       	ldd	r24, Y+1	; 0x01
    38ae:	9a 81       	ldd	r25, Y+2	; 0x02
    38b0:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <vPortFree>
			pxNewTCB = NULL;
    38b4:	1a 82       	std	Y+2, r1	; 0x02
    38b6:	19 82       	std	Y+1, r1	; 0x01
    38b8:	0b c0       	rjmp	.+22     	; 0x38d0 <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    38ba:	e9 81       	ldd	r30, Y+1	; 0x01
    38bc:	fa 81       	ldd	r31, Y+2	; 0x02
    38be:	87 89       	ldd	r24, Z+23	; 0x17
    38c0:	90 8d       	ldd	r25, Z+24	; 0x18
    38c2:	2b 81       	ldd	r18, Y+3	; 0x03
    38c4:	3c 81       	ldd	r19, Y+4	; 0x04
    38c6:	65 ea       	ldi	r22, 0xA5	; 165
    38c8:	70 e0       	ldi	r23, 0x00	; 0
    38ca:	a9 01       	movw	r20, r18
    38cc:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <memset>
		}
	}

	return pxNewTCB;
    38d0:	89 81       	ldd	r24, Y+1	; 0x01
    38d2:	9a 81       	ldd	r25, Y+2	; 0x02
}
    38d4:	28 96       	adiw	r28, 0x08	; 8
    38d6:	0f b6       	in	r0, 0x3f	; 63
    38d8:	f8 94       	cli
    38da:	de bf       	out	0x3e, r29	; 62
    38dc:	0f be       	out	0x3f, r0	; 63
    38de:	cd bf       	out	0x3d, r28	; 61
    38e0:	cf 91       	pop	r28
    38e2:	df 91       	pop	r29
    38e4:	08 95       	ret

000038e6 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    38e6:	df 93       	push	r29
    38e8:	cf 93       	push	r28
    38ea:	00 d0       	rcall	.+0      	; 0x38ec <prvDeleteTCB+0x6>
    38ec:	cd b7       	in	r28, 0x3d	; 61
    38ee:	de b7       	in	r29, 0x3e	; 62
    38f0:	9a 83       	std	Y+2, r25	; 0x02
    38f2:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    38f4:	e9 81       	ldd	r30, Y+1	; 0x01
    38f6:	fa 81       	ldd	r31, Y+2	; 0x02
    38f8:	87 89       	ldd	r24, Z+23	; 0x17
    38fa:	90 8d       	ldd	r25, Z+24	; 0x18
    38fc:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <vPortFree>
		vPortFree( pxTCB );
    3900:	89 81       	ldd	r24, Y+1	; 0x01
    3902:	9a 81       	ldd	r25, Y+2	; 0x02
    3904:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <vPortFree>
	}
    3908:	0f 90       	pop	r0
    390a:	0f 90       	pop	r0
    390c:	cf 91       	pop	r28
    390e:	df 91       	pop	r29
    3910:	08 95       	ret

00003912 <INIT>:
		Order the Scheduler to make the Task Periodicity by 150
		vTaskDelay(50);
	}
}
*/
void INIT(){
    3912:	df 93       	push	r29
    3914:	cf 93       	push	r28
    3916:	cd b7       	in	r28, 0x3d	; 61
    3918:	de b7       	in	r29, 0x3e	; 62
	while(1){
	xSemaphoreGive(LCD_Semphor);
    391a:	80 91 6f 05 	lds	r24, 0x056F
    391e:	90 91 70 05 	lds	r25, 0x0570
    3922:	60 e0       	ldi	r22, 0x00	; 0
    3924:	70 e0       	ldi	r23, 0x00	; 0
    3926:	40 e0       	ldi	r20, 0x00	; 0
    3928:	50 e0       	ldi	r21, 0x00	; 0
    392a:	20 e0       	ldi	r18, 0x00	; 0
    392c:	0e 94 c6 11 	call	0x238c	; 0x238c <xQueueGenericSend>
	xSemaphoreTake(LCD_Semphor,portMAX_DELAY);
    3930:	80 91 6f 05 	lds	r24, 0x056F
    3934:	90 91 70 05 	lds	r25, 0x0570
    3938:	60 e0       	ldi	r22, 0x00	; 0
    393a:	70 e0       	ldi	r23, 0x00	; 0
    393c:	4f ef       	ldi	r20, 0xFF	; 255
    393e:	5f ef       	ldi	r21, 0xFF	; 255
    3940:	20 e0       	ldi	r18, 0x00	; 0
    3942:	0e 94 b1 12 	call	0x2562	; 0x2562 <xQueueGenericReceive>
	HCLCD_Init4Bit();
    3946:	0e 94 71 08 	call	0x10e2	; 0x10e2 <HCLCD_Init4Bit>
	//HCLCD_WriteString(data);

	HKPD_Init();
    394a:	0e 94 81 07 	call	0xf02	; 0xf02 <HKPD_Init>
	MADC_Init();
    394e:	0e 94 16 07 	call	0xe2c	; 0xe2c <MADC_Init>
	HCLCD_WriteString("welcome home!");
    3952:	85 e6       	ldi	r24, 0x65	; 101
    3954:	90 e0       	ldi	r25, 0x00	; 0
    3956:	0e 94 9d 09 	call	0x133a	; 0x133a <HCLCD_WriteString>
	vTaskDelay(2000);
    395a:	80 ed       	ldi	r24, 0xD0	; 208
    395c:	97 e0       	ldi	r25, 0x07	; 7
    395e:	0e 94 62 17 	call	0x2ec4	; 0x2ec4 <vTaskDelay>
	xSemaphoreGive(LCD_Semphor);
    3962:	80 91 6f 05 	lds	r24, 0x056F
    3966:	90 91 70 05 	lds	r25, 0x0570
    396a:	60 e0       	ldi	r22, 0x00	; 0
    396c:	70 e0       	ldi	r23, 0x00	; 0
    396e:	40 e0       	ldi	r20, 0x00	; 0
    3970:	50 e0       	ldi	r21, 0x00	; 0
    3972:	20 e0       	ldi	r18, 0x00	; 0
    3974:	0e 94 c6 11 	call	0x238c	; 0x238c <xQueueGenericSend>
	vTaskDelete(NULL);
    3978:	80 e0       	ldi	r24, 0x00	; 0
    397a:	90 e0       	ldi	r25, 0x00	; 0
    397c:	0e 94 8b 16 	call	0x2d16	; 0x2d16 <vTaskDelete>
    3980:	cc cf       	rjmp	.-104    	; 0x391a <INIT+0x8>

00003982 <KEYPAD_TASK>:

	}

}
void KEYPAD_TASK(void)
{
    3982:	df 93       	push	r29
    3984:	cf 93       	push	r28
    3986:	cd b7       	in	r28, 0x3d	; 61
    3988:	de b7       	in	r29, 0x3e	; 62

	/*Define Variables or one time operations */
		//xSemaphoreTake(LCD_Semphor,portMAX_DELAY);
		HCLCD_WriteCommand4Bit(DISPALY_CLEAR_COMMAND);
    398a:	81 e0       	ldi	r24, 0x01	; 1
    398c:	0e 94 33 08 	call	0x1066	; 0x1066 <HCLCD_WriteCommand4Bit>
		HCLCD_WriteString("ENTER(1)FOR ADC!");
    3990:	83 e7       	ldi	r24, 0x73	; 115
    3992:	90 e0       	ldi	r25, 0x00	; 0
    3994:	0e 94 9d 09 	call	0x133a	; 0x133a <HCLCD_WriteString>
	//	xSemaphoreGive(LCD_Semphor);
	while(1)
	{
		/*Put your Periodic Action */

		keypressed = HKPD_GetPressedButton();
    3998:	0e 94 d8 07 	call	0xfb0	; 0xfb0 <HKPD_GetPressedButton>
    399c:	80 93 af 00 	sts	0x00AF, r24

		if(keypressed!='$')
    39a0:	80 91 af 00 	lds	r24, 0x00AF
    39a4:	84 32       	cpi	r24, 0x24	; 36
    39a6:	61 f1       	breq	.+88     	; 0x3a00 <KEYPAD_TASK+0x7e>
//
//			keypressed ='$';
//			xSemaphoreGive(LCD_Semphor);
//			}

					xSemaphoreTake(LCD_Semphor,portMAX_DELAY);
    39a8:	80 91 6f 05 	lds	r24, 0x056F
    39ac:	90 91 70 05 	lds	r25, 0x0570
    39b0:	60 e0       	ldi	r22, 0x00	; 0
    39b2:	70 e0       	ldi	r23, 0x00	; 0
    39b4:	4f ef       	ldi	r20, 0xFF	; 255
    39b6:	5f ef       	ldi	r21, 0xFF	; 255
    39b8:	20 e0       	ldi	r18, 0x00	; 0
    39ba:	0e 94 b1 12 	call	0x2562	; 0x2562 <xQueueGenericReceive>
							if(keypressed=='1'){
    39be:	80 91 af 00 	lds	r24, 0x00AF
    39c2:	81 33       	cpi	r24, 0x31	; 49
    39c4:	39 f4       	brne	.+14     	; 0x39d4 <KEYPAD_TASK+0x52>
							flag =1;
    39c6:	81 e0       	ldi	r24, 0x01	; 1
    39c8:	80 93 68 05 	sts	0x0568, r24
							keypressed ='$';
    39cc:	84 e2       	ldi	r24, 0x24	; 36
    39ce:	80 93 af 00 	sts	0x00AF, r24
    39d2:	0b c0       	rjmp	.+22     	; 0x39ea <KEYPAD_TASK+0x68>

							}
						else {
							HCLCD_WriteCommand4Bit(DISPALY_CLEAR_COMMAND);
    39d4:	81 e0       	ldi	r24, 0x01	; 1
    39d6:	0e 94 33 08 	call	0x1066	; 0x1066 <HCLCD_WriteCommand4Bit>
							vTaskDelay(5);
    39da:	85 e0       	ldi	r24, 0x05	; 5
    39dc:	90 e0       	ldi	r25, 0x00	; 0
    39de:	0e 94 62 17 	call	0x2ec4	; 0x2ec4 <vTaskDelay>
							HCLCD_WriteString("Wrong Input!");
    39e2:	84 e8       	ldi	r24, 0x84	; 132
    39e4:	90 e0       	ldi	r25, 0x00	; 0
    39e6:	0e 94 9d 09 	call	0x133a	; 0x133a <HCLCD_WriteString>

						}
							xSemaphoreGive(LCD_Semphor);
    39ea:	80 91 6f 05 	lds	r24, 0x056F
    39ee:	90 91 70 05 	lds	r25, 0x0570
    39f2:	60 e0       	ldi	r22, 0x00	; 0
    39f4:	70 e0       	ldi	r23, 0x00	; 0
    39f6:	40 e0       	ldi	r20, 0x00	; 0
    39f8:	50 e0       	ldi	r21, 0x00	; 0
    39fa:	20 e0       	ldi	r18, 0x00	; 0
    39fc:	0e 94 c6 11 	call	0x238c	; 0x238c <xQueueGenericSend>

		}
		/*Order the Scheduler to make the Task Periodicity by 150*/

		vTaskDelay(50);
    3a00:	82 e3       	ldi	r24, 0x32	; 50
    3a02:	90 e0       	ldi	r25, 0x00	; 0
    3a04:	0e 94 62 17 	call	0x2ec4	; 0x2ec4 <vTaskDelay>
    3a08:	c7 cf       	rjmp	.-114    	; 0x3998 <KEYPAD_TASK+0x16>

00003a0a <ADC_TASK>:
	}

}
void ADC_TASK(void)
{
    3a0a:	df 93       	push	r29
    3a0c:	cf 93       	push	r28
    3a0e:	cd b7       	in	r28, 0x3d	; 61
    3a10:	de b7       	in	r29, 0x3e	; 62
	//xSemaphoreTake(LCD_Semphor,portMAX_DELAY);


	while(1)
	{
		if(flag==1){
    3a12:	80 91 68 05 	lds	r24, 0x0568
    3a16:	81 30       	cpi	r24, 0x01	; 1
    3a18:	e1 f7       	brne	.-8      	; 0x3a12 <ADC_TASK+0x8>
		Reading = MADC_StartConversion(MADC_CHANNEL_0);
    3a1a:	80 e0       	ldi	r24, 0x00	; 0
    3a1c:	0e 94 4e 07 	call	0xe9c	; 0xe9c <MADC_StartConversion>
    3a20:	90 93 6e 05 	sts	0x056E, r25
    3a24:	80 93 6d 05 	sts	0x056D, r24
		temp =(Reading*5)/1023;
    3a28:	20 91 6d 05 	lds	r18, 0x056D
    3a2c:	30 91 6e 05 	lds	r19, 0x056E
    3a30:	c9 01       	movw	r24, r18
    3a32:	88 0f       	add	r24, r24
    3a34:	99 1f       	adc	r25, r25
    3a36:	88 0f       	add	r24, r24
    3a38:	99 1f       	adc	r25, r25
    3a3a:	82 0f       	add	r24, r18
    3a3c:	93 1f       	adc	r25, r19
    3a3e:	2f ef       	ldi	r18, 0xFF	; 255
    3a40:	33 e0       	ldi	r19, 0x03	; 3
    3a42:	b9 01       	movw	r22, r18
    3a44:	0e 94 d9 1d 	call	0x3bb2	; 0x3bb2 <__udivmodhi4>
    3a48:	cb 01       	movw	r24, r22
    3a4a:	cc 01       	movw	r24, r24
    3a4c:	a0 e0       	ldi	r26, 0x00	; 0
    3a4e:	b0 e0       	ldi	r27, 0x00	; 0
    3a50:	80 93 69 05 	sts	0x0569, r24
    3a54:	90 93 6a 05 	sts	0x056A, r25
    3a58:	a0 93 6b 05 	sts	0x056B, r26
    3a5c:	b0 93 6c 05 	sts	0x056C, r27


				if(pdPASS==xSemaphoreTake(LCD_Semphor,portMAX_DELAY))
    3a60:	80 91 6f 05 	lds	r24, 0x056F
    3a64:	90 91 70 05 	lds	r25, 0x0570
    3a68:	60 e0       	ldi	r22, 0x00	; 0
    3a6a:	70 e0       	ldi	r23, 0x00	; 0
    3a6c:	4f ef       	ldi	r20, 0xFF	; 255
    3a6e:	5f ef       	ldi	r21, 0xFF	; 255
    3a70:	20 e0       	ldi	r18, 0x00	; 0
    3a72:	0e 94 b1 12 	call	0x2562	; 0x2562 <xQueueGenericReceive>
    3a76:	81 30       	cpi	r24, 0x01	; 1
    3a78:	69 f5       	brne	.+90     	; 0x3ad4 <ADC_TASK+0xca>
				{
						HCLCD_WriteCommand4Bit(DISPALY_CLEAR_COMMAND);
    3a7a:	81 e0       	ldi	r24, 0x01	; 1
    3a7c:	0e 94 33 08 	call	0x1066	; 0x1066 <HCLCD_WriteCommand4Bit>
						HCLCD_WriteString(data);
    3a80:	83 ea       	ldi	r24, 0xA3	; 163
    3a82:	90 e0       	ldi	r25, 0x00	; 0
    3a84:	0e 94 9d 09 	call	0x133a	; 0x133a <HCLCD_WriteString>
						HCLCD_SetCursorPosition(HCLCD_LINE_0,12);
    3a88:	80 e0       	ldi	r24, 0x00	; 0
    3a8a:	6c e0       	ldi	r22, 0x0C	; 12
    3a8c:	0e 94 05 09 	call	0x120a	; 0x120a <HCLCD_SetCursorPosition>
						HCLCD_WriteNumber(temp);
    3a90:	80 91 69 05 	lds	r24, 0x0569
    3a94:	90 91 6a 05 	lds	r25, 0x056A
    3a98:	a0 91 6b 05 	lds	r26, 0x056B
    3a9c:	b0 91 6c 05 	lds	r27, 0x056C
    3aa0:	bc 01       	movw	r22, r24
    3aa2:	cd 01       	movw	r24, r26
    3aa4:	0e 94 26 09 	call	0x124c	; 0x124c <HCLCD_WriteNumber>
						HCLCD_SetCursorPosition(HCLCD_LINE_1,14);
    3aa8:	81 e0       	ldi	r24, 0x01	; 1
    3aaa:	6e e0       	ldi	r22, 0x0E	; 14
    3aac:	0e 94 05 09 	call	0x120a	; 0x120a <HCLCD_SetCursorPosition>
						HCLCD_WriteChar4Bit('C');
    3ab0:	83 e4       	ldi	r24, 0x43	; 67
    3ab2:	0e 94 c7 08 	call	0x118e	; 0x118e <HCLCD_WriteChar4Bit>
						HCLCD_SetCursorPosition(HCLCD_LINE_0,0);
    3ab6:	80 e0       	ldi	r24, 0x00	; 0
    3ab8:	60 e0       	ldi	r22, 0x00	; 0
    3aba:	0e 94 05 09 	call	0x120a	; 0x120a <HCLCD_SetCursorPosition>
						xSemaphoreGive(LCD_Semphor);
    3abe:	80 91 6f 05 	lds	r24, 0x056F
    3ac2:	90 91 70 05 	lds	r25, 0x0570
    3ac6:	60 e0       	ldi	r22, 0x00	; 0
    3ac8:	70 e0       	ldi	r23, 0x00	; 0
    3aca:	40 e0       	ldi	r20, 0x00	; 0
    3acc:	50 e0       	ldi	r21, 0x00	; 0
    3ace:	20 e0       	ldi	r18, 0x00	; 0
    3ad0:	0e 94 c6 11 	call	0x238c	; 0x238c <xQueueGenericSend>
				}
				/*Order the Scheduler to make the Task Periodicity by 50*/
				vTaskDelay(50);
    3ad4:	82 e3       	ldi	r24, 0x32	; 50
    3ad6:	90 e0       	ldi	r25, 0x00	; 0
    3ad8:	0e 94 62 17 	call	0x2ec4	; 0x2ec4 <vTaskDelay>
    3adc:	9a cf       	rjmp	.-204    	; 0x3a12 <ADC_TASK+0x8>

00003ade <main>:
	}
}

}
int main ()
{
    3ade:	af 92       	push	r10
    3ae0:	bf 92       	push	r11
    3ae2:	cf 92       	push	r12
    3ae4:	df 92       	push	r13
    3ae6:	ef 92       	push	r14
    3ae8:	ff 92       	push	r15
    3aea:	0f 93       	push	r16
    3aec:	df 93       	push	r29
    3aee:	cf 93       	push	r28
    3af0:	cd b7       	in	r28, 0x3d	; 61
    3af2:	de b7       	in	r29, 0x3e	; 62

	/*define the Pins Direction */
	MDIO_SetPinDirection(PIN0,MDIO_PORTA,PIN_INPUT);
    3af4:	80 e0       	ldi	r24, 0x00	; 0
    3af6:	60 e0       	ldi	r22, 0x00	; 0
    3af8:	40 e0       	ldi	r20, 0x00	; 0
    3afa:	0e 94 cb 02 	call	0x596	; 0x596 <MDIO_SetPinDirection>
	/*Create Tasks */
	xTaskCreate(&INIT,NULL,200,NULL,9,NULL);
    3afe:	89 e8       	ldi	r24, 0x89	; 137
    3b00:	9c e1       	ldi	r25, 0x1C	; 28
    3b02:	60 e0       	ldi	r22, 0x00	; 0
    3b04:	70 e0       	ldi	r23, 0x00	; 0
    3b06:	48 ec       	ldi	r20, 0xC8	; 200
    3b08:	50 e0       	ldi	r21, 0x00	; 0
    3b0a:	20 e0       	ldi	r18, 0x00	; 0
    3b0c:	30 e0       	ldi	r19, 0x00	; 0
    3b0e:	09 e0       	ldi	r16, 0x09	; 9
    3b10:	ee 24       	eor	r14, r14
    3b12:	ff 24       	eor	r15, r15
    3b14:	cc 24       	eor	r12, r12
    3b16:	dd 24       	eor	r13, r13
    3b18:	aa 24       	eor	r10, r10
    3b1a:	bb 24       	eor	r11, r11
    3b1c:	0e 94 9e 15 	call	0x2b3c	; 0x2b3c <xTaskGenericCreate>
	xTaskCreate(&KEYPAD_TASK,NULL,200,NULL,5,NULL);
    3b20:	81 ec       	ldi	r24, 0xC1	; 193
    3b22:	9c e1       	ldi	r25, 0x1C	; 28
    3b24:	60 e0       	ldi	r22, 0x00	; 0
    3b26:	70 e0       	ldi	r23, 0x00	; 0
    3b28:	48 ec       	ldi	r20, 0xC8	; 200
    3b2a:	50 e0       	ldi	r21, 0x00	; 0
    3b2c:	20 e0       	ldi	r18, 0x00	; 0
    3b2e:	30 e0       	ldi	r19, 0x00	; 0
    3b30:	05 e0       	ldi	r16, 0x05	; 5
    3b32:	ee 24       	eor	r14, r14
    3b34:	ff 24       	eor	r15, r15
    3b36:	cc 24       	eor	r12, r12
    3b38:	dd 24       	eor	r13, r13
    3b3a:	aa 24       	eor	r10, r10
    3b3c:	bb 24       	eor	r11, r11
    3b3e:	0e 94 9e 15 	call	0x2b3c	; 0x2b3c <xTaskGenericCreate>
	xTaskCreate(&ADC_TASK,NULL,200,NULL,2,NULL);
    3b42:	85 e0       	ldi	r24, 0x05	; 5
    3b44:	9d e1       	ldi	r25, 0x1D	; 29
    3b46:	60 e0       	ldi	r22, 0x00	; 0
    3b48:	70 e0       	ldi	r23, 0x00	; 0
    3b4a:	48 ec       	ldi	r20, 0xC8	; 200
    3b4c:	50 e0       	ldi	r21, 0x00	; 0
    3b4e:	20 e0       	ldi	r18, 0x00	; 0
    3b50:	30 e0       	ldi	r19, 0x00	; 0
    3b52:	02 e0       	ldi	r16, 0x02	; 2
    3b54:	ee 24       	eor	r14, r14
    3b56:	ff 24       	eor	r15, r15
    3b58:	cc 24       	eor	r12, r12
    3b5a:	dd 24       	eor	r13, r13
    3b5c:	aa 24       	eor	r10, r10
    3b5e:	bb 24       	eor	r11, r11
    3b60:	0e 94 9e 15 	call	0x2b3c	; 0x2b3c <xTaskGenericCreate>
	/*Create the Binary Semaphor*/
	vSemaphoreCreateBinary(LCD_Semphor);
    3b64:	81 e0       	ldi	r24, 0x01	; 1
    3b66:	60 e0       	ldi	r22, 0x00	; 0
    3b68:	0e 94 1d 11 	call	0x223a	; 0x223a <xQueueCreate>
    3b6c:	90 93 70 05 	sts	0x0570, r25
    3b70:	80 93 6f 05 	sts	0x056F, r24
    3b74:	80 91 6f 05 	lds	r24, 0x056F
    3b78:	90 91 70 05 	lds	r25, 0x0570
    3b7c:	00 97       	sbiw	r24, 0x00	; 0
    3b7e:	59 f0       	breq	.+22     	; 0x3b96 <main+0xb8>
    3b80:	80 91 6f 05 	lds	r24, 0x056F
    3b84:	90 91 70 05 	lds	r25, 0x0570
    3b88:	60 e0       	ldi	r22, 0x00	; 0
    3b8a:	70 e0       	ldi	r23, 0x00	; 0
    3b8c:	40 e0       	ldi	r20, 0x00	; 0
    3b8e:	50 e0       	ldi	r21, 0x00	; 0
    3b90:	20 e0       	ldi	r18, 0x00	; 0
    3b92:	0e 94 c6 11 	call	0x238c	; 0x238c <xQueueGenericSend>

	/*Call The Schedular */
	vTaskStartScheduler();
    3b96:	0e 94 97 17 	call	0x2f2e	; 0x2f2e <vTaskStartScheduler>


	return 0 ;
    3b9a:	80 e0       	ldi	r24, 0x00	; 0
    3b9c:	90 e0       	ldi	r25, 0x00	; 0
}
    3b9e:	cf 91       	pop	r28
    3ba0:	df 91       	pop	r29
    3ba2:	0f 91       	pop	r16
    3ba4:	ff 90       	pop	r15
    3ba6:	ef 90       	pop	r14
    3ba8:	df 90       	pop	r13
    3baa:	cf 90       	pop	r12
    3bac:	bf 90       	pop	r11
    3bae:	af 90       	pop	r10
    3bb0:	08 95       	ret

00003bb2 <__udivmodhi4>:
    3bb2:	aa 1b       	sub	r26, r26
    3bb4:	bb 1b       	sub	r27, r27
    3bb6:	51 e1       	ldi	r21, 0x11	; 17
    3bb8:	07 c0       	rjmp	.+14     	; 0x3bc8 <__udivmodhi4_ep>

00003bba <__udivmodhi4_loop>:
    3bba:	aa 1f       	adc	r26, r26
    3bbc:	bb 1f       	adc	r27, r27
    3bbe:	a6 17       	cp	r26, r22
    3bc0:	b7 07       	cpc	r27, r23
    3bc2:	10 f0       	brcs	.+4      	; 0x3bc8 <__udivmodhi4_ep>
    3bc4:	a6 1b       	sub	r26, r22
    3bc6:	b7 0b       	sbc	r27, r23

00003bc8 <__udivmodhi4_ep>:
    3bc8:	88 1f       	adc	r24, r24
    3bca:	99 1f       	adc	r25, r25
    3bcc:	5a 95       	dec	r21
    3bce:	a9 f7       	brne	.-22     	; 0x3bba <__udivmodhi4_loop>
    3bd0:	80 95       	com	r24
    3bd2:	90 95       	com	r25
    3bd4:	bc 01       	movw	r22, r24
    3bd6:	cd 01       	movw	r24, r26
    3bd8:	08 95       	ret

00003bda <__udivmodsi4>:
    3bda:	a1 e2       	ldi	r26, 0x21	; 33
    3bdc:	1a 2e       	mov	r1, r26
    3bde:	aa 1b       	sub	r26, r26
    3be0:	bb 1b       	sub	r27, r27
    3be2:	fd 01       	movw	r30, r26
    3be4:	0d c0       	rjmp	.+26     	; 0x3c00 <__udivmodsi4_ep>

00003be6 <__udivmodsi4_loop>:
    3be6:	aa 1f       	adc	r26, r26
    3be8:	bb 1f       	adc	r27, r27
    3bea:	ee 1f       	adc	r30, r30
    3bec:	ff 1f       	adc	r31, r31
    3bee:	a2 17       	cp	r26, r18
    3bf0:	b3 07       	cpc	r27, r19
    3bf2:	e4 07       	cpc	r30, r20
    3bf4:	f5 07       	cpc	r31, r21
    3bf6:	20 f0       	brcs	.+8      	; 0x3c00 <__udivmodsi4_ep>
    3bf8:	a2 1b       	sub	r26, r18
    3bfa:	b3 0b       	sbc	r27, r19
    3bfc:	e4 0b       	sbc	r30, r20
    3bfe:	f5 0b       	sbc	r31, r21

00003c00 <__udivmodsi4_ep>:
    3c00:	66 1f       	adc	r22, r22
    3c02:	77 1f       	adc	r23, r23
    3c04:	88 1f       	adc	r24, r24
    3c06:	99 1f       	adc	r25, r25
    3c08:	1a 94       	dec	r1
    3c0a:	69 f7       	brne	.-38     	; 0x3be6 <__udivmodsi4_loop>
    3c0c:	60 95       	com	r22
    3c0e:	70 95       	com	r23
    3c10:	80 95       	com	r24
    3c12:	90 95       	com	r25
    3c14:	9b 01       	movw	r18, r22
    3c16:	ac 01       	movw	r20, r24
    3c18:	bd 01       	movw	r22, r26
    3c1a:	cf 01       	movw	r24, r30
    3c1c:	08 95       	ret

00003c1e <memcpy>:
    3c1e:	fb 01       	movw	r30, r22
    3c20:	dc 01       	movw	r26, r24
    3c22:	02 c0       	rjmp	.+4      	; 0x3c28 <memcpy+0xa>
    3c24:	01 90       	ld	r0, Z+
    3c26:	0d 92       	st	X+, r0
    3c28:	41 50       	subi	r20, 0x01	; 1
    3c2a:	50 40       	sbci	r21, 0x00	; 0
    3c2c:	d8 f7       	brcc	.-10     	; 0x3c24 <memcpy+0x6>
    3c2e:	08 95       	ret

00003c30 <memset>:
    3c30:	dc 01       	movw	r26, r24
    3c32:	01 c0       	rjmp	.+2      	; 0x3c36 <memset+0x6>
    3c34:	6d 93       	st	X+, r22
    3c36:	41 50       	subi	r20, 0x01	; 1
    3c38:	50 40       	sbci	r21, 0x00	; 0
    3c3a:	e0 f7       	brcc	.-8      	; 0x3c34 <memset+0x4>
    3c3c:	08 95       	ret

00003c3e <strncpy>:
    3c3e:	fb 01       	movw	r30, r22
    3c40:	dc 01       	movw	r26, r24
    3c42:	41 50       	subi	r20, 0x01	; 1
    3c44:	50 40       	sbci	r21, 0x00	; 0
    3c46:	48 f0       	brcs	.+18     	; 0x3c5a <strncpy+0x1c>
    3c48:	01 90       	ld	r0, Z+
    3c4a:	0d 92       	st	X+, r0
    3c4c:	00 20       	and	r0, r0
    3c4e:	c9 f7       	brne	.-14     	; 0x3c42 <strncpy+0x4>
    3c50:	01 c0       	rjmp	.+2      	; 0x3c54 <strncpy+0x16>
    3c52:	1d 92       	st	X+, r1
    3c54:	41 50       	subi	r20, 0x01	; 1
    3c56:	50 40       	sbci	r21, 0x00	; 0
    3c58:	e0 f7       	brcc	.-8      	; 0x3c52 <strncpy+0x14>
    3c5a:	08 95       	ret

00003c5c <_exit>:
    3c5c:	f8 94       	cli

00003c5e <__stop_program>:
    3c5e:	ff cf       	rjmp	.-2      	; 0x3c5e <__stop_program>
